下面来看页面不在内存中且页表项内容为空（!pte_present(entry)&& pte_none(entry)）的另外一种情况，即VMA定义了fault方法函数（vma->vm_ops->fault()）。

```
[handle_pte_fault()->do_fault()]
static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
		unsigned long address, pte_t *page_table, pmd_t *pmd,
		unsigned int flags, pte_t orig_pte)
{
	pgoff_t pgoff = (((address & PAGE_MASK)
			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	pte_unmap(page_table);
	if (!(flags & FAULT_FLAG_WRITE))
		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	if (!(vma->vm_flags & VM_SHARED))
		return do_cow_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	return do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
}
```

do_fault()函数处理VMA中的vm_ops操作函数集里定义了fault函数指针的情况，具体可以分成如下3种情况。

- flags不为FAULT_FLAG_WRITE,即只读异常，见do_read_fault()。
- VMA的vm_flags没有定义VM_SHARED，即这是一个私有映射且发生了写时复制COW，见do_cow_fault()。
- 其余情况是在共享映射中发生了写缺页异常，见do_shared_fault()。

下面首先来看只读异常的情况，即do_read_fault()函数。

```
[handle_pte_fault()->do_fault()->do_read_fault()]
static int do_read_fault(struct mm_struct *mm, struct vm_area_struct *vma,
		unsigned long address, pmd_t *pmd,
		pgoff_t pgoff, unsigned int flags, pte_t orig_pte)
{
	struct page *fault_page;
	spinlock_t *ptl;
	pte_t *pte;
	int ret = 0;

	/*
	 * Let's call ->map_pages() first and use ->fault() as fallback
	 * if page by the offset is not ready to be mapped (cold cache or
	 * something).
	 */
	if (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {
		pte = pte_offset_map_lock(mm, pmd, address, &ptl);
		do_fault_around(vma, address, pte, pgoff, flags);
		if (!pte_same(*pte, orig_pte))
			goto unlock_out;
		pte_unmap_unlock(pte, ptl);
	}

	ret = __do_fault(vma, address, pgoff, flags, NULL, &fault_page);
	if (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))
		return ret;

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
	if (unlikely(!pte_same(*pte, orig_pte))) {
		pte_unmap_unlock(pte, ptl);
		unlock_page(fault_page);
		page_cache_release(fault_page);
		return ret;
	}
	do_set_pte(vma, address, fault_page, pte, false, false);
	unlock_page(fault_page);
unlock_out:
	pte_unmap_unlock(pte, ptl);
	return ret;
}
```

第14行代码，VMA定义了map_pages()方法，可以围绕在缺页异常地址周围提前映射尽可能多的页面。提前建立进程地址空间和page cache的映射关系有利于减少发生缺页中断的次数，从而提高效率。注意，这里只是和现存的page cache提前建立映射关系，而不会去创建 page cache，创建新的page cache是在__do_fault()函数中。fault_around_bytes是一个全局变量，定义在mm/memory.c文件中，默认是65536Byte，即16个页面大小。

```
static unsigned long fault_around_bytes __read_mostly =
	rounddown_pow_of_two(65536);
```

第16行代码的do_fault_around()函数定义如下：

```
static void do_fault_around(struct vm_area_struct *vma, unsigned long address,
		pte_t *pte, pgoff_t pgoff, unsigned int flags)
{
	unsigned long start_addr, nr_pages, mask;
	pgoff_t max_pgoff;
	struct vm_fault vmf;
	int off;

	nr_pages = ACCESS_ONCE(fault_around_bytes) >> PAGE_SHIFT;
	mask = ~(nr_pages * PAGE_SIZE - 1) & PAGE_MASK;

	start_addr = max(address & mask, vma->vm_start);
	off = ((address - start_addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);
	pte -= off;
	pgoff -= off;

	/*
	 *  max_pgoff is either end of page table or end of vma
	 *  or fault_around_pages() from pgoff, depending what is nearest.
	 */
	max_pgoff = pgoff - ((start_addr >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)) +
		PTRS_PER_PTE - 1;
	max_pgoff = min3(max_pgoff, vma_pages(vma) + vma->vm_pgoff - 1,
			pgoff + nr_pages - 1);

	/* Check if it makes any sense to call ->map_pages */
	while (!pte_none(*pte)) {
		if (++pgoff > max_pgoff)
			return;
		start_addr += PAGE_SIZE;
		if (start_addr >= vma->vm_end)
			return;
		pte++;
	}

	vmf.virtual_address = (void __user *) start_addr;
	vmf.pte = pte;
	vmf.pgoff = pgoff;
	vmf.max_pgoff = max_pgoff;
	vmf.flags = flags;
	vma->vm_ops->map_pages(vma, &vmf);
}
```

do_fault_around()函数以当前缺页异常地址addr为中心，start_addr是以16个page大小对齐的起始地址，然后从start_addr开始检查相应的pte是否为空。若为空，则从这个PTE开始到max_pgoff为止使用VMA的操作函数map_pages()来映射PTE，除非所需要的的page cache还没有准备好或page cache被锁住了。该函数预测异常地址周围的page cache可能会被马上读取，所以把已经有的page cache提前建立好映射，有利于减少发生缺页中断的次数，但注意并不会去新建page cache。这个函数流程图如图2.21所示。

![](picture\do_fault_around()函数.png)

真正为异常地址分配page cache是在do_read_fault()函数第22行代码中的__do_fault()函数。