Linux内核在启动时会打印出内核内存空间的布局图，下面是ARM Vexpress平台打印出来的内存空间布局图：

![ARM32内核内存分布布局图](../picture/ARM32内核内存分布布局图.png)

这部分信息打印是在mem_init()函数中实现的。

```
[start_kernel->mm_init->mem_init]
	pr_notice("Virtual kernel memory layout:\n"
		  "    vmalloc : 0x%16lx - 0x%16lx   (%6ld GB)\n"
#ifdef CONFIG_SPARSEMEM_VMEMMAP
		  "    vmemmap : 0x%16lx - 0x%16lx   (%6ld GB maximum)\n"
		  "              0x%16lx - 0x%16lx   (%6ld MB actual)\n"
#endif
		  "    fixed   : 0x%16lx - 0x%16lx   (%6ld KB)\n"
		  "    PCI I/O : 0x%16lx - 0x%16lx   (%6ld MB)\n"
		  "    modules : 0x%16lx - 0x%16lx   (%6ld MB)\n"
		  "    memory  : 0x%16lx - 0x%16lx   (%6ld MB)\n"
		  "      .init : 0x%p" " - 0x%p" "   (%6ld KB)\n"
		  "      .text : 0x%p" " - 0x%p" "   (%6ld KB)\n"
		  "      .data : 0x%p" " - 0x%p" "   (%6ld KB)\n",
		  MLG(VMALLOC_START, VMALLOC_END),
#ifdef CONFIG_SPARSEMEM_VMEMMAP
		  MLG((unsigned long)vmemmap,
		      (unsigned long)vmemmap + VMEMMAP_SIZE),
		  MLM((unsigned long)virt_to_page(PAGE_OFFSET),
		      (unsigned long)virt_to_page(high_memory)),
#endif
		  MLK(FIXADDR_START, FIXADDR_TOP),
		  MLM(PCI_IO_START, PCI_IO_END),
		  MLM(MODULES_VADDR, MODULES_END),
		  MLM(PAGE_OFFSET, (unsigned long)high_memory),
		  MLK_ROUNDUP(__init_begin, __init_end),
		  MLK_ROUNDUP(_text, _etext),
		  MLK_ROUNDUP(_sdata, _edata));
```

编译器在编译目标文件并且链接完成之后，就可以知道内核映像文件最终的大小，接下来打包成二进制文件，该操作由`arch/arm/kernel/vmlinux.ld.S`控制，其中也划定了内核的内存布局。

内核image本身占据的内存空间从_text段到 _end段，并且分为如下几个段：

- 代码段：_text和 _etext为代码段的起始和结束地址，包含了编译后的内核代码。
- init段：`__init_begin` 和 `__init_end`为init段的起始和结束地址，包含了大部分的模块初始化的数据。
- 数据段：`_sdata`和`_edata`为数据段的起始和结束地址，包含了大部分内核的变量；
- BSS段：`__bss_start`和`__bss_stop`为BSS段的开始和结束地址，包含初始化为0的所有静态全局变量。

上述几个段的大小在编译链接时根据内核配置来确定，因为每种配置代码段和数据段长度都不相同，这取决与要编译哪些内核模块，但是起始地址`__text`总是相同的。内核编译完成后，会生成一个System.map文件，查询这个文件可以找到这些地址的具体数值。

![](../picture/Systemmap.png)

内核使用虚拟地址从MODULES_VADDR到MODULES_END这段14MB大小的内存区域。

```
#define MODULES_VADDR		(PAGE_OFFSET - SZ_16M)
#ifdef CONFIG_HIGHMEM
#define MODULES_END		(PAGE_OFFSET - PMD_SIZE)
#else
#define MODULES_END		(PAGE_OFFSET)
#endif
```

用户空间和内核空间使用3:1的划分方法时，内核空间只有1GB大小。这1GB的映射空间，其中有一部分用于直接映射物理地址。这个区域称为线性映射区。在ARM32平台上，物理地址[0:760MB]的这一部分内存被线性映射到[3GB:3GB+768MB]的虚拟地址上。线性映射区的虚拟地址和物理地址相差PAGE_OFFSET，即3GB。内核中有相关的宏来实现

