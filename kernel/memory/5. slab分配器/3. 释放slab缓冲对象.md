释放slab缓冲对象的API函数是kmem_cache_free()函数。

```
/**
 * kmem_cache_free - Deallocate an object
 * @cachep: The cache the allocation was from.
 * @objp: The previously allocated object.
 *
 * Free an object which was previously allocated from this
 * cache.
 */
void kmem_cache_free(struct kmem_cache *cachep, void *objp)
{
	unsigned long flags;
	cachep = cache_from_obj(cachep, objp);
	if (!cachep)
		return;

	local_irq_save(flags);
	debug_check_no_locks_freed(objp, cachep->object_size);
	if (!(cachep->flags & SLAB_DEBUG_OBJECTS))
		debug_check_no_obj_freed(objp, cachep->object_size);
	__cache_free(cachep, objp, _RET_IP_);
	local_irq_restore(flags);

	trace_kmem_cache_free(_RET_IP_, objp);
}
```

首先，cache_from_obj()通过要释放对象的obj的虚拟地址找到对应的struct kmem_cache数据结构。由对象的虚拟地址通过virt_to_pfn()找到相应的pfn，然后通过pfn_to_page()由pfn找到对应的page结构。在这个slab中，第一个页面page结构中page->slab_cache指向这个struct kmem_cache数据结构。

```
#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
static inline struct page *virt_to_head_page(const void *x)
{
	struct page *page = virt_to_page(x);

	/*
	 * We don't need to worry about synchronization of tail flag
	 * when we call virt_to_head_page() since it is only called for
	 * already allocated page and this page won't be freed until
	 * this virt_to_head_page() is finished. So use _fast variant.
	 */
	return compound_head_fast(page);
}
static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)
{
	struct kmem_cache *cachep;
	struct page *page;

	/*
	 * When kmemcg is not being used, both assignments should return the
	 * same value. but we don't want to pay the assignment price in that
	 * case. If it is not compiled in, the compiler should be smart enough
	 * to not do even the assignment. In that case, slab_equal_or_root
	 * will also be a constant.
	 */
	if (!memcg_kmem_enabled() && !unlikely(s->flags & SLAB_DEBUG_FREE))
		return s;

	page = virt_to_head_page(x);
	cachep = page->slab_cache;
	if (slab_equal_or_root(cachep, s))
		return cachep;

	pr_err("%s: Wrong slab cache. %s but object is from %s\n",
	       __func__, cachep->name, s->name);
	WARN_ON_ONCE(1);
	return s;
}
```

