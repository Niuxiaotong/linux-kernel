通过阅读上面代码，我们知道slab系统由slab描述符、slab节点、本地对象缓冲池，共享对象缓冲池，3个slab链表，n个slab，以及众多的slab缓存对象，如图2.10所示：

![](https://img2020.cnblogs.com/blog/811006/202006/811006-20200630141154612-108549117.png)

那么每个slab由多少个页面组成的呢？每个slab由一个或n个page连续页面组成，是一个连续的物理空间。创建slab描述符会计算一个slab究竟需要占用多少个page页面。即2^gfporder。要等到分配slab对象时，发现本地缓冲池和共享缓冲池都是空的，然后查询3大链表也没有空闲对象，那么只好分配一个slab了。这时才会分配2^gfporder个页面，并且把这个slab挂入slabs_free链表中。

如果一个slab描述符中有许多空闲对象，那么系统是否要回收一些空闲的缓存对象从而释放内存归还系统呢？这个是必须考虑的问题。否则系统有大量的slab描述符，每个slab描述符还有大量不用的、空闲的slab对象，这怎么行呢？slab系统有两种方式来回收内存。

（1）使用kmem_cache_free释放一个对象，当本地和共享对象缓冲池中的空闲对象数目ac->avail大于缓冲值的极限值ac->limit时，系统会主动释放batchcount个对象。当系统所有空闲对象数目大于系统空闲对象数目极限值，并且这个slab没有活跃对象时，那么系统就会销毁这个slab，从而回收内存。

（2）slab系统还注册了一个定时器，定时去扫描所有slab描述符，回收一部分空闲对象，达到条件的slab也会被销毁，实现函数在cache_reap()，大家可以自行阅读。

另外一个利用cache的场景是Per-CPU类型的本地对象缓冲池。slab分配器的一个重要的目的是硬件和cache的使用效率。使用Per-CPU类型的本地对象缓冲池有如下两个好处。

- 让一个对象尽可能的运行在同一个CPU上，可以让对象尽可能的使用同一个CPU的cache，有助于提高性能。
- 访问Per-CPU类型的本地缓冲池不需要获取额外的自旋锁，因为不会有其他的CPU来访问这些Per-CPU类型的对象缓冲池，避免自旋锁的争用。

尽管slab分配器在很多工作负荷下都工作良好，但在一些情况下也无法提供最优的性能。例如一些微小的嵌入式系统或者大量物理内存的超级计算机。在大内存的超级计算机中，slab系统所需要的元数据占用了好几个GB的内存，对于微小的嵌入式系统，slab 的代码量和复杂性也很高，因此Linux内核中提供了另外两种替代品，slob和slub。slob适合于微小的嵌入式系统，slub分配器在大型系统中能提供比slab更好的性能。





