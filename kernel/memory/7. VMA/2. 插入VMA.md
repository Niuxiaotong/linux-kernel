insert_vm_struct()是内核提供的插入VMA的核心API函数。

```
int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)
{
	struct vm_area_struct *prev;
	struct rb_node **rb_link, *rb_parent;

	/*
	 * The vm_pgoff of a purely anonymous vma should be irrelevant
	 * until its first write fault, when page's anon_vma and index
	 * are set.  But now set the vm_pgoff it will almost certainly
	 * end up with (unless mremap moves it elsewhere before that
	 * first wfault), so /proc/pid/maps tells a consistent story.
	 *
	 * By setting it to reflect the virtual start address of the
	 * vma, merges and splits can happen in a seamless way, just
	 * using the existing file pgoff checks and manipulations.
	 * Similarly in do_mmap_pgoff and in do_brk.
	 */
	if (!vma->vm_file) {
		BUG_ON(vma->anon_vma);
		vma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;
	}
	if (find_vma_links(mm, vma->vm_start, vma->vm_end,
			   &prev, &rb_link, &rb_parent))
		return -ENOMEM;
	if ((vma->vm_flags & VM_ACCOUNT) &&
	     security_vm_enough_memory_mm(mm, vma_pages(vma)))
		return -ENOMEM;

	vma_link(mm, vma, prev, rb_link, rb_parent);
	return 0;
}
```

insert_vm_struct()函数向VMA链表和红黑树插入一个新的VMA。参数mm是进程的内存描述符，vma是要插入的线性区VMA。

第5~8行代码，如果vma不是文件映射，设置vm_pgoff成员

第9行代码，find_vma_links()查找要插入的位置。

第16行代码，将vma插入链表和红黑树中。

```
static int find_vma_links(struct mm_struct *mm, unsigned long addr,
		unsigned long end, struct vm_area_struct **pprev,
		struct rb_node ***rb_link, struct rb_node **rb_parent)
{
	struct rb_node **__rb_link, *__rb_parent, *rb_prev;

	__rb_link = &mm->mm_rb.rb_node;
	rb_prev = __rb_parent = NULL;

	while (*__rb_link) {
		struct vm_area_struct *vma_tmp;

		__rb_parent = *__rb_link;
		vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);

		if (vma_tmp->vm_end > addr) {
			/* Fail if an existing vma overlaps the area */
			if (vma_tmp->vm_start < end)
				return -ENOMEM;
			__rb_link = &__rb_parent->rb_left;
		} else {
			rb_prev = __rb_parent;
			__rb_link = &__rb_parent->rb_right;
		}
	}

	*pprev = NULL;
	if (rb_prev)
		*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);
	*rb_link = __rb_link;
	*rb_parent = __rb_parent;
	return 0;
}
```

find_vma_links()函数为新vma查找合适的插入位置。

第6行代码，__rb_link指向红黑树的根节点。

第9~24行代码，遍历这个红黑树来寻找合适的插入位置。如果addr小于某个节点VMA的结束地址，那么继续遍历当前VMA的左子树。如果要插入的vma恰好和现有的VMA有小部分重叠，那么返回错误码-ENOMEM。见第17~18行代码。如果addr大于节点的VMA结束地址，那么遍历这个节点的右子树。while循环一直遍历下去，直到某个节点没有子节点为止。

第28行代码，rb_prev指向待插入节点的前继节点，这里获取前继节点的结构体。

第29行代码，*rb_link指向__rb_parent->rb_right或 __rb_parent->rb_left指针本身的结构体

第30行代码，__rb_parent指向找到的待插入节点的父节点。

注意，这里是用来二级和三级指针作为形参，例如find_vma_links()函数的rb_parent是二级指针作为形参，rb_link是三级指针作为形参，这里很容易混淆，以rb_link为例，如图2.12所示，假设rb_link指针本身地址为0x5555，它在insert_vm_struct()函数中是一个二级指针，并且是局部变量，把rb_link指针的地址0x5555作为形参传递给find_vma_links()函数。指针函数作为函数形参调用时会分配一个副本，假设副本名字为rb_link1，这是rb_link1指向地址0x5555。find_vma_links()函数第29行代码让*rb_link1指向__rb_parent->rb_right或者 __rb_parent->rb_left指针本身的地址，可以理解为地址0x5555存在一个指针，该指针指向__rb_parent->rb_right或  __rb_parent->rb_left指针本身的地址。

所以find_vma_links()函数返回之后，rb_link指向__rb_parent->rb_right或  `__rb_parent->rb_left`指针本身的地址。*rb_link便可以指向`__rb_parent->rb_right`或  `__rb_parent->rb_left`指针指向的节点，在__vma_link()->__vma_link_rb()->rb_link_node()会使用到。

find_vma_links()函数主要贡献是精确的找到了新VMA要加入某个节点的子节点上，rb_parent指针指向要插入的节点的父节点；rb_link要指向要插入节点指针的本身地址；pprev指针指向要插入的节点的父节点的指向的VMA数据结构，如图2.13所示。

在Linux内核代码中经常使用二级指针，Linux内核创始人linus torvalds曾经公开批评过许多内核开发者不会使用指针的指针。可见二级指针在Linux内核中的重要性，二级指针在Linux内核中主要两种用法，一是作为函数形参，例如上述的find_vma_links()函数；二是链表操作，例如RCU的代码。下面是用二级指针实现的一个简单链表操作的例子，忽略了异常处理部分。

![](picture/多级指针作为函数形参.png)![多级指针作为函数形参](picture/多级指针作为函数形参.png)