mmap机制在 Linux内核中实现的代码框架和brk机制非常类似,其中有很多关于VMA的操作,在第2.7节中已经详细介绍过。mmap机制和缺页中断机制结合在一起会变得复杂很多。 Dirty Cow,这个在2016年被发现的最恐怖的内存漏洞就是利用了mmap和缺页中断的相关漏洞,学习这个例子有助于加深对mmap和缺页中断机制的理解,详见第2.8节mmap机制在 Linux内核中的代码流程如图2.18所示。

![mmap流程图](picture/mmap流程图.png)

除了 Dirty Cow之外,下面收集了几个有意思的小问题。

问题1:请阅读 Linux内核中mmap相关代码,找出第二次调用mmap会成功的原因? 下面是 strace抓取到的log信息。

```
# strace捕捉某个app调用mmap的情况 
mmap(0x20000000, 819200, PROT_READ | PROT_WRITE,MAP_PRIVATE | MAP_FIXED | MAP_ ANONYMOUS,-1, 0) =0x20000000 
....
mmap(0x20000000, 4096, PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_FIXED| MAP_ANONYMOUS, -1, 0)=0x20000000
```

这里以指定的地址0x20000000来建立一个私有的匿名映射，为什么第二次调用mmap时，Linux内核没有捕捉到地址重叠并返回失败呢？

查看mmap系统调用的代码实现，在do_mmappgoff()->mmap_region())函数里有如下一段代码：

```
[sys_mmap_pgoff()->vm_mmap_pgoff()->do_mmap_pgoff()->mmap_region()]
unsigned long mmap_region()
```

