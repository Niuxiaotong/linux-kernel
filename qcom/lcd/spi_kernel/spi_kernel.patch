diff --git a/kernel/Documentation/devicetree/bindings/fb/mdss-spi-client.txt b/kernel/Documentation/devicetree/bindings/fb/mdss-spi-client.txt
new file mode 100644
index 0000000..4851d33
--- /dev/null
+++ b/kernel/Documentation/devicetree/bindings/fb/mdss-spi-client.txt
@@ -0,0 +1,30 @@
+Qualcomm Technologies, Inc mdss-spi-client
+
+mdss-spi-client is for spi display send the FB data to spi master.
+
+Required properties:
+- compatible : should be "qcom,mdss-spi-client"
+- spi-max-frequency : Maximum SPI clocking speed of device in Hz
+- dc-gpio: Pull down this gpio indicate current package is command,
+	   Pull up this gpio indicate current package is parameter or pixel.
+
+Optional properties:
+- label: A string used to describe the controller used.
+ - spi-cpol : Empty property indicating device requires inverse
+  clock polarity (CPOL) mode
+- spi-cpha :  Empty property indicating device requires shifted
+  clock phase (CPHA) mode
+- spi-cs-high :  Empty property indicating device requires
+  chip select active high
+
+Example:
+spi@78b9000 { /* BLSP1 QUP5 */
+               qcom,mdss_spi_client{
+               reg = <0>;
+               compatible = "qcom,mdss-spi-client";
+               label = "MDSS SPI QUP5 CLIENT";
+               dc-gpio = <&msm_gpio 110 0>;
+               spi-max-frequency = <50000000>;
+               };
+       };
+};
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8909-mdss.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8909-mdss.dtsi
old mode 100644
new mode 100755
index b4e2660..ff6799e
--- a/kernel/arch/arm/boot/dts/qcom/msm8909-mdss.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8909-mdss.dtsi
@@ -31,7 +31,7 @@
                 mdss_fb0: qcom,mdss_fb_primary {
 			cell-index = <0>;
 			compatible = "qcom,mdss-fb";
-			qcom,mdss-fb-format = "rgba8888";
+			qcom,mdss-fb-format = "rgb565";
 			qcom,cont-splash-memory {
 				linux,contiguous-region = <&cont_splash_mem>;
 			};
@@ -128,6 +128,39 @@
 			};
 		};
 	};
+
+	mdss_spi: qcom,mdss_spi {
+		compatible = "qcom,mdss-spi-display";
+		label = "mdss spi panel";
+
+		qcom,mdss-fb-map = <&mdss_fb0>;
+		qcom,mdss-mdp = <&mdss_mdp>;
+		vdd-supply = <&pm8909_l17>;
+		vddio-supply = <&pm8909_l6>;
+
+		qcom,panel-supply-entries {
+		#address-cells = <1>;
+			#size-cells = <0>;
+
+			qcom,panel-supply-entry@0 {
+				reg = <0>;
+				qcom,supply-name = "vdd";
+				qcom,supply-min-voltage = <2850000>;
+				qcom,supply-max-voltage = <2850000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+			};
+
+			qcom,panel-supply-entry@1 {
+				reg = <1>;
+				qcom,supply-name = "vddio";
+				qcom,supply-min-voltage = <1800000>;
+				qcom,supply-max-voltage = <1800000>;
+				qcom,supply-enable-load = <100000>;
+				qcom,supply-disable-load = <100>;
+			};
+		};
+	};
 };
 
 #include "dsi-panel-sim-video.dtsi"
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8909-pm8916.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8909-pm8916.dtsi
old mode 100644
new mode 100755
index d5beb72..dfd3920
--- a/kernel/arch/arm/boot/dts/qcom/msm8909-pm8916.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8909-pm8916.dtsi
@@ -192,6 +192,11 @@
 		vddio-supply = <&pm8916_l6>;
 	};
 
+	qcom,mdss_spi {
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+	};
+	
 	qcom,msm-thermal {
 		vdd-dig-supply = <&pm8916_s1_floor_corner>;
 
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dts b/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dts
old mode 100644
new mode 100755
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dtsi
old mode 100644
new mode 100755
index 2acd1a0..88a02f3
--- a/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8909-qrd-skua.dtsi
@@ -20,6 +20,27 @@
 
 &soc {
 	i2c@78b9000 { /* BLSP1 QUP5 */
+		it7259@46 {
+			compatible = "ite,it7259_ts";
+			reg = <0x46>;
+			interrupt-parent = <&msm_gpio>;	
+			vdd-supply = <&pm8909_l6>;
+			avdd-supply = <&pm8909_l17>;
+			ite,reset-gpio = <&msm_gpio 12 0x0>;
+			ite,irq-gpio = <&msm_gpio 13 0x0>;
+			ite,num-fingers = <2>;
+			//ite,wakeup
+			//ite,palm-detect-en
+			//ite,fw-name
+			//ite,cfg-name
+			ite,reset-delay = <120>;
+			//ite,avdd-lpm-cur
+			//ite,low-reset;
+			ite,display-coords = <0 0 240 320>;
+			ite,panel-coords = <0 0 240 320>;
+			status = "ok";
+		};
+
 		focaltech@38 {
 			compatible = "focaltech,5x06";
 			reg = <0x38>;
@@ -53,6 +74,7 @@
 			focaltech,fw-delay-era-flsh-ms = <2000>;
 			focaltech,fw-auto-cal;
 			focaltech,ignore-id-check;
+			status = "disabled";
 		};
 	};
 
@@ -213,34 +235,9 @@
 	/delete-property/ cd-gpios;
 };
 
-&pm8909_mpps {
-	mpp@a000 { /* MPP 1 */
-		/* VDD_PX */
-		status = "disabled";
-	};
-
-	mpp@a100 { /* MPP 2 */
-		/* Backlight PWM */
-		qcom,mode = <1>;		/* Digital output */
-		qcom,invert = <0>;		/* Disable invert */
-		qcom,src-sel = <4>;		/* DTEST1 */
-		qcom,vin-sel = <0>;		/* VPH_PWR */
-		qcom,master-en = <1>;		/* Enable MPP */
-	};
-
-	mpp@a200 { /* MPP 3 */
-		/* VREF DAC */
-		status = "disabled";
-	};
-
-	mpp@a300 { /* MPP 4 */
-		/* HR LED */
-		status = "disabled";
-	};
-};
-
+#if 0
 #include "dsi-panel-hx8379a-fwvga-skua-video.dtsi"
-
+//because this is mipi,so it be annotated
 &mdss_mdp {
 	qcom,mdss-pref-prim-intf = "dsi";
 };
@@ -267,3 +264,98 @@
 
 	qcom,platform-reset-gpio = <&msm_gpio 25 0>;
 };
+#else
+&soc {
+	spi@78ba000 { /* BLSP1 QUP6 */
+		status = "okay";
+		qcom,mdss_spi_client {
+			reg = <0>;
+			compatible = "qcom,mdss-spi-client";
+			label = "MDSS SPI QUP5 CLIENT";
+			dc-gpio = <&msm_gpio 15 0>;
+			spi-max-frequency = <50000000>;
+		};
+	};
+
+	i2c@78ba000 {/* BLSP1 QUP5 */
+		status = "disabled";//hanyiyi
+	};
+
+	i2c@78b8000 { /* BLSP1 QUP4 */
+
+		status = "disabled";
+	};
+
+};
+
+
+&pm8909_mpps {
+		mpp@a000 { /* MPP 1 */
+			/* VDD_PX */
+			status = "disabled";
+		};
+
+		mpp@a100 { /* MPP 2 */
+			/* Backlight PWM */
+			qcom,mode = <1>;		/* Digital output */
+			qcom,invert = <0>;		/* Disable invert */
+			qcom,src-sel = <4>; 	/* DTEST1 */
+			qcom,vin-sel = <0>; 	/* VPH_PWR */
+			qcom,master-en = <1>;		/* Enable MPP */
+		};
+
+		mpp@a200 { /* MPP 3 */
+			/* VREF DAC */
+			status = "disabled";
+		};
+
+		mpp@a300 { /* MPP 4 */
+			/* HR LED */
+			status = "disabled";
+		};
+};
+
+
+#include "spi-panel-st7789v-qvga-cmd.dtsi"
+
+
+&mdss_mdp {
+	qcom,mdss-pref-prim-intf = "spi";
+};
+
+&spi_st7789v_qvga_cmd {
+	qcom,mdss-spi-bl-pmic-control-type = "bl_ctrl_pwm";
+	qcom,mdss-spi-bl-pmic-pwm-frequency = <100>;
+	qcom,mdss-spi-bl-pmic-bank-select = <0>;
+	qcom,mdss-spi-pwm-gpio = <&pm8909_mpps 2 0>;
+//	qcom,cont-splash-enabled;
+};
+
+&pmx_mdss_te {
+	qcom,pin-func = <0>;
+	qcom,num-grp-pins = <1>;
+	qcom,pins = <&gp 24>;
+};
+
+&mdss_spi {
+	qcom,spi-pref-prim-pan = <&spi_st7789v_qvga_cmd>;
+	pinctrl-names = "mdss_default", "mdss_sleep";
+	pinctrl-0 = <&mdss_te_active>;
+	pinctrl-1 = <&mdss_te_suspend>;
+
+	qcom,platform-te-gpio = <&msm_gpio 24 0>;
+	qcom,platform-reset-gpio = <&msm_gpio 25 0>;
+};
+
+&pm8909_gpios {
+	gpio@c000 { /* GPIO 1 */
+		qcom,mode = <2>; /* QPNP_PIN_MODE_DIG_OUT */
+		qcom,output-type = <0>;
+		qcom,pull = <5>; /* QPNP_PIN_PULL_NO */
+		qcom,vin-sel = <0>; /* QPNP_PIN_VIN2 */
+		qcom,src-sel = <2>; /* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;
+		status = "okay";
+	};
+};
+#endif 
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8909.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8909.dtsi
old mode 100644
new mode 100755
index 6511593..b644d26
--- a/kernel/arch/arm/boot/dts/qcom/msm8909.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8909.dtsi
@@ -43,6 +43,7 @@
 		sdhc1 = &sdhc_1; /* SDC1 eMMC slot */
 		sdhc2 = &sdhc_2; /* SDC2 SD card slot */
 		spi0 = &spi_0; /* SPI0 controller device */
+//		spi5 = &spi_5;	/* SPI5 controller device */
 		 i2c5 = &i2c_5; /* I2c5 cntroller device */
 		i2c3 = &i2c_3; /* I2C3 controller */
 		i2c1 = &i2c_1; /* I2C1 controller */
@@ -1123,7 +1124,7 @@
                       <0x7884000 0x23000>;
                 interrupt-names = "spi_irq", "spi_bam_irq";
                 interrupts = <0 100 0>, <0 238 0>;
-                spi-max-frequency = <19200000>;
+                spi-max-frequency = <50000000>;
                 pinctrl-names = "spi_default", "spi_sleep";
                 pinctrl-0 = <&spi0_default &spi0_cs0_active>;
                 pinctrl-1 = <&spi0_sleep &spi0_cs0_sleep>;
@@ -1137,6 +1138,7 @@
                 qcom,bam-consumer-pipe-index = <14>;
                 qcom,bam-producer-pipe-index = <15>;
                 qcom,master-id = <86>;
+                status = "okay";
 	};
 
 	dma_blsp1: qcom,sps-dma@7884000 { /* BLSP1 */
diff --git a/kernel/arch/arm/boot/dts/qcom/spi-panel-st7789v-qvga-cmd.dtsi b/kernel/arch/arm/boot/dts/qcom/spi-panel-st7789v-qvga-cmd.dtsi
new file mode 100755
index 0000000..060ee6d
--- /dev/null
+++ b/kernel/arch/arm/boot/dts/qcom/spi-panel-st7789v-qvga-cmd.dtsi
@@ -0,0 +1,60 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&mdss_mdp {
+	spi_st7789v_qvga_cmd: qcom,mdss_spi_st7789v_qvga_cmd {
+		qcom,mdss-spi-panel-name = "st7789v qvga command mode spi panel";
+		qcom,mdss-spi-panel-destination = "display_1";
+		qcom,mdss-spi-panel-controller = <&mdss_spi>;
+		qcom,mdss-spi-panel-framerate = <60>;
+		qcom,mdss-spi-panel-width = <240>;
+		qcom,mdss-spi-panel-height = <320>;
+		qcom,mdss-spi-h-front-porch = <38>;
+		qcom,mdss-spi-h-back-porch = <20>;
+		qcom,mdss-spi-h-pulse-width = <10>;
+		qcom,mdss-spi-v-back-porch = <4>;
+		qcom,mdss-spi-v-front-porch = <8>;
+		qcom,mdss-spi-v-pulse-width = <4>;
+		qcom,mdss-spi-h-left-border = <0>;
+		qcom,mdss-spi-h-right-border = <0>;
+		qcom,mdss-spi-v-top-border = <0>;
+		qcom,mdss-spi-v-bottom-border = <0>;
+		qcom,mdss-spi-bpp = <16>;
+		qcom,mdss-spi-on-command = [
+			78 01 11
+			00 02 36 00
+			00 02 3A 05
+			//00 04 B1 40 04 0A
+			//00 06 B2 0C 0C 00 33 33
+			//00 04 B3 00 0F 0F
+			00 01 21
+			00 02 B7 35
+			00 02 BB 1F
+			00 02 C2 01
+			00 02 C3 19
+			00 02 C4 20
+			00 02 C6 0F
+			00 03 D0 A4 A1
+			00 02 D6 A1
+			00 0F E0 D0 06 0C 0A 09 0A 32 33 49 19 14 15 2B 34
+			00 0F E1 D0 D6 0C 0A 09 11 37 33 49 19 14 15 2D 34
+			78 01 11
+			00 01 29
+			00 01 2C];
+		qcom,mdss-spi-off-command = [20 01 28
+				 20 01 10];
+		qcom,mdss-spi-bl-min-level = <1>;
+		qcom,mdss-spi-bl-max-level = <4095>;
+		qcom,mdss-spi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-spi-reset-sequence = <1 20>, <0 120>, <1 20>;
+	};
+};
diff --git a/kernel/arch/arm/configs/msm8909-1gb-perf_defconfig b/kernel/arch/arm/configs/msm8909-1gb-perf_defconfig
old mode 100644
new mode 100755
index fe540ce..ad0efe0
--- a/kernel/arch/arm/configs/msm8909-1gb-perf_defconfig
+++ b/kernel/arch/arm/configs/msm8909-1gb-perf_defconfig
@@ -354,6 +354,7 @@ CONFIG_HAS_DMA=y
 CONFIG_QCOM_SPS_DMA=y
 CONFIG_SPI=y
 CONFIG_SPI_QUP=y
+CONFIG_FB_MSM_MDSS_SPI_PANEL=y
 CONFIG_SPI_SPIDEV=m
 CONFIG_SPMI=y
 CONFIG_SPMI_MSM_PMIC_ARB=y
diff --git a/kernel/arch/arm/configs/msm8909-1gb_defconfig b/kernel/arch/arm/configs/msm8909-1gb_defconfig
old mode 100644
new mode 100755
index 588663b..b2b122c
--- a/kernel/arch/arm/configs/msm8909-1gb_defconfig
+++ b/kernel/arch/arm/configs/msm8909-1gb_defconfig
@@ -361,6 +361,7 @@ CONFIG_HAS_DMA=y
 CONFIG_QCOM_SPS_DMA=y
 CONFIG_SPI=y
 CONFIG_SPI_QUP=y
+CONFIG_FB_MSM_MDSS_SPI_PANEL=y
 CONFIG_SPI_SPIDEV=m
 CONFIG_SPMI=y
 CONFIG_SPMI_MSM_PMIC_ARB=y
diff --git a/kernel/arch/arm/configs/msm8909_defconfig b/kernel/arch/arm/configs/msm8909_defconfig
index fa8c2c0..d73c1ec 100644
--- a/kernel/arch/arm/configs/msm8909_defconfig
+++ b/kernel/arch/arm/configs/msm8909_defconfig
@@ -312,6 +312,8 @@ CONFIG_TOUCHSCREEN_GEN_VKEYS=y
 CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=y
 CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV=y
 CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+CONFIG_FRAME_WARN=2048
+CONFIG_TOUCHSCREEN_IT725X=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_UINPUT=y
 CONFIG_INPUT_GPIO=m
@@ -342,6 +344,7 @@ CONFIG_HAS_DMA=y
 CONFIG_QCOM_SPS_DMA=y
 CONFIG_SPI=y
 CONFIG_SPI_QUP=y
+CONFIG_FB_MSM_MDSS_SPI_PANEL=y
 CONFIG_SPI_SPIDEV=m
 CONFIG_SPMI=y
 CONFIG_SPMI_MSM_PMIC_ARB=y
diff --git a/kernel/drivers/input/Kconfig b/kernel/drivers/input/Kconfig
index bb469e3..8137580 100644
--- a/kernel/drivers/input/Kconfig
+++ b/kernel/drivers/input/Kconfig
@@ -199,6 +199,8 @@ config SENSORS_HALL
 	---help---
 	 Say y here if you want to use this hall sensor driver, it
 	 is like a switch. For example, lid.
+	
+
 
 comment "Input Device Drivers"
 
diff --git a/kernel/drivers/input/touchscreen/Kconfig b/kernel/drivers/input/touchscreen/Kconfig
index e3a4474..b29304b 100644
--- a/kernel/drivers/input/touchscreen/Kconfig
+++ b/kernel/drivers/input/touchscreen/Kconfig
@@ -1073,4 +1073,11 @@ config TOUCHSCREEN_IT7260_I2C
 	  To compile this driver as a module, choose M here: the
 	  module will be called it7258_ts_i2c.
 
+config TOUCHSCREEN_IT725X
+       tristate "IT725X touchscreens"
+       depends on I2C
+       help
+         Say Y here if you have a IT725X touchscreen.
+
+         If unsure, say N.
 endif
diff --git a/kernel/drivers/input/touchscreen/Makefile b/kernel/drivers/input/touchscreen/Makefile
index ad85d91..15e5e28 100644
--- a/kernel/drivers/input/touchscreen/Makefile
+++ b/kernel/drivers/input/touchscreen/Makefile
@@ -83,3 +83,4 @@ obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
 obj-$(CONFIG_TOUCHSCREEN_BU21150)	+= bu21150.o
 obj-$(CONFIG_INPUT_MT_WRAPPER)		+= input_mt_wrapper.o
 obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)    += it7258_ts_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_IT725X)		+= it7259_ts_i2c.o
diff --git a/kernel/drivers/input/touchscreen/it7258_ts_i2c.c b/kernel/drivers/input/touchscreen/it7258_ts_i2c.c
index f51490e..b1d0429 100644
--- a/kernel/drivers/input/touchscreen/it7258_ts_i2c.c
+++ b/kernel/drivers/input/touchscreen/it7258_ts_i2c.c
@@ -1,7 +1,7 @@
 /* drivers/input/touchscreen/it7258_ts_i2c.c
  *
  * Copyright (C) 2014 ITE Tech. Inc.
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -9,7 +9,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  */
@@ -30,7 +30,7 @@
 #include <linux/string.h>
 
 #define MAX_BUFFER_SIZE			144
-#define DEVICE_NAME			"IT7260"
+#define DEVICE_NAME			"it7260"
 #define SCREEN_X_RESOLUTION		320
 #define SCREEN_Y_RESOLUTION		320
 #define DEBUGFS_DIR_NAME		"ts_debug"
@@ -99,23 +99,25 @@
 #define FW_WRITE_CHUNK_SIZE		128
 #define FW_WRITE_RETRY_COUNT		4
 #define CHIP_FLASH_SIZE			0x8000
-#define DEVICE_READY_MAX_WAIT		500
-#define DEVICE_READY_WAIT_10		10
+#define DEVICE_READY_COUNT_MAX		500
+#define DEVICE_READY_COUNT_20		20
+#define IT_I2C_WAIT_10MS		10
+#define IT_I2C_READ_RET			2
+#define IT_I2C_WRITE_RET		1
 
 /* result of reading with BUF_QUERY bits */
 #define CMD_STATUS_BITS			0x07
 #define CMD_STATUS_DONE			0x00
 #define CMD_STATUS_BUSY			0x01
 #define CMD_STATUS_ERROR		0x02
+#define CMD_STATUS_NO_CONN		0x07
 #define PT_INFO_BITS			0xF8
-#define BT_INFO_NONE			0x00
 #define PT_INFO_YES			0x80
-/* no new data but finder(s) still down */
-#define BT_INFO_NONE_BUT_DOWN		0x08
 
 #define PD_FLAGS_DATA_TYPE_BITS		0xF0
 /* other types (like chip-detected gestures) exist but we do not care */
 #define PD_FLAGS_DATA_TYPE_TOUCH	0x00
+#define PD_FLAGS_IDLE_TO_ACTIVE		0x10
 /* a bit for each finger data that is valid (from lsb to msb) */
 #define PD_FLAGS_HAVE_FINGERS		0x07
 #define PD_PALM_FLAG_BIT		0x01
@@ -134,22 +136,21 @@
 #define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
 #define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
 #define PINCTRL_STATE_RELEASE	"pmx_ts_release"
-#define IT_I2C_WAIT		1000
 
-struct FingerData {
-	uint8_t xLo;
-	uint8_t hi;
-	uint8_t yLo;
-	uint8_t pressure;
+struct finger_data {
+	u8 xLo;
+	u8 hi;
+	u8 yLo;
+	u8 pressure;
 }  __packed;
 
-struct PointData {
-	uint8_t flags;
-	uint8_t palm;
-	struct FingerData fd[3];
+struct point_data {
+	u8 flags;
+	u8 gesture_id;
+	struct finger_data fd[3];
 }  __packed;
 
-struct IT7260_ts_platform_data {
+struct it7260_ts_platform_data {
 	u32 irq_gpio;
 	u32 irq_gpio_flags;
 	u32 reset_gpio;
@@ -173,23 +174,23 @@ struct IT7260_ts_platform_data {
 	bool low_reset;
 };
 
-struct IT7260_ts_data {
+struct it7260_ts_data {
 	struct i2c_client *client;
 	struct input_dev *input_dev;
-	const struct IT7260_ts_platform_data *pdata;
+	const struct it7260_ts_platform_data *pdata;
 	struct regulator *vdd;
 	struct regulator *avdd;
-	bool device_needs_wakeup;
+	struct work_struct work_pm_relax;
+	struct mutex fw_cfg_mutex;
+	bool in_low_power_mode;
 	bool suspended;
 	bool fw_upgrade_result;
 	bool cfg_upgrade_result;
 	bool fw_cfg_uploading;
-	struct work_struct work_pm_relax;
 	bool calibration_success;
 	bool had_finger_down;
 	char fw_name[MAX_BUFFER_SIZE];
 	char cfg_name[MAX_BUFFER_SIZE];
-	struct mutex fw_cfg_mutex;
 	u8 fw_ver[VER_BUFFER_SIZE];
 	u8 cfg_ver[VER_BUFFER_SIZE];
 #ifdef CONFIG_FB
@@ -205,44 +206,49 @@ struct IT7260_ts_data {
 /* Function declarations */
 static int fb_notifier_callback(struct notifier_block *self,
 			unsigned long event, void *data);
-static int IT7260_ts_resume(struct device *dev);
-static int IT7260_ts_suspend(struct device *dev);
+static int it7260_ts_resume(struct device *dev);
+static int it7260_ts_suspend(struct device *dev);
 
-static struct IT7260_ts_data *gl_ts;
-
-static int IT7260_debug_suspend_set(void *_data, u64 val)
+static int it7260_debug_suspend_set(void *_data, u64 val)
 {
+	struct it7260_ts_data *ts_data = _data;
+
 	if (val)
-		IT7260_ts_suspend(&gl_ts->client->dev);
+		it7260_ts_suspend(&ts_data->client->dev);
 	else
-		IT7260_ts_resume(&gl_ts->client->dev);
+		it7260_ts_resume(&ts_data->client->dev);
 
 	return 0;
 }
 
-static int IT7260_debug_suspend_get(void *_data, u64 *val)
+static int it7260_debug_suspend_get(void *_data, u64 *val)
 {
-	*val = gl_ts->suspended;
+	struct it7260_ts_data *ts_data = _data;
+
+	mutex_lock(&ts_data->input_dev->mutex);
+	*val = ts_data->suspended;
+	mutex_lock(&ts_data->input_dev->mutex);
 
 	return 0;
 }
 
-DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, IT7260_debug_suspend_get,
-				IT7260_debug_suspend_set, "%lld\n");
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, it7260_debug_suspend_get,
+				it7260_debug_suspend_set, "%lld\n");
 
 /* internal use func - does not make sure chip is ready before read */
-static bool IT7260_i2cReadNoReadyCheck(uint8_t buf_index, uint8_t *buffer,
-							uint16_t buf_len)
+static int it7260_i2c_read_no_ready_check(struct it7260_ts_data *ts_data,
+			uint8_t buf_index, uint8_t *buffer, uint16_t buf_len)
 {
+	int ret;
 	struct i2c_msg msgs[2] = {
 		{
-			.addr = gl_ts->client->addr,
+			.addr = ts_data->client->addr,
 			.flags = I2C_M_NOSTART,
 			.len = 1,
 			.buf = &buf_index
 		},
 		{
-			.addr = gl_ts->client->addr,
+			.addr = ts_data->client->addr,
 			.flags = I2C_M_RD,
 			.len = buf_len,
 			.buf = buffer
@@ -251,15 +257,20 @@ static bool IT7260_i2cReadNoReadyCheck(uint8_t buf_index, uint8_t *buffer,
 
 	memset(buffer, 0xFF, buf_len);
 
-	return i2c_transfer(gl_ts->client->adapter, msgs, 2);
+	ret = i2c_transfer(ts_data->client->adapter, msgs, 2);
+	if (ret < 0)
+		dev_err(&ts_data->client->dev, "i2c read failed %d\n", ret);
+
+	return ret;
 }
 
-static bool IT7260_i2cWriteNoReadyCheck(uint8_t buf_index,
-			const uint8_t *buffer, uint16_t buf_len)
+static int it7260_i2c_write_no_ready_check(struct it7260_ts_data *ts_data,
+		uint8_t buf_index, const uint8_t *buffer, uint16_t buf_len)
 {
 	uint8_t txbuf[257];
+	int ret;
 	struct i2c_msg msg = {
-		.addr = gl_ts->client->addr,
+		.addr = ts_data->client->addr,
 		.flags = 0,
 		.len = buf_len + 1,
 		.buf = txbuf
@@ -267,110 +278,178 @@ static bool IT7260_i2cWriteNoReadyCheck(uint8_t buf_index,
 
 	/* just to be careful */
 	if (buf_len > sizeof(txbuf) - 1) {
-		dev_err(&gl_ts->client->dev, "buf length is out of limit\n");
+		dev_err(&ts_data->client->dev, "buf length is out of limit\n");
 		return false;
 	}
 
 	txbuf[0] = buf_index;
 	memcpy(txbuf + 1, buffer, buf_len);
 
-	return i2c_transfer(gl_ts->client->adapter, &msg, 1);
+	ret = i2c_transfer(ts_data->client->adapter, &msg, 1);
+	if (ret < 0)
+		dev_err(&ts_data->client->dev, "i2c write failed %d\n", ret);
+
+	return ret;
 }
 
 /*
- * Device is apparently always ready for i2c but not for actual
- * register reads/writes. This function ascertains it is ready
- * for that too. the results of this call often were ignored.
+ * Device is apparently always ready for I2C communication but not for
+ * actual register reads/writes. This function checks if it is ready
+ * for that too. The results of this call often were ignored.
+ * If forever is set to TRUE, then check the device's status until it
+ * becomes ready with 500 retries at max. Otherwise retry 25 times only.
+ * If slowly is set to TRUE, then add sleep of 50 ms in each retry,
+ * otherwise don't sleep.
  */
-static bool IT7260_waitDeviceReady(bool forever, bool slowly)
+static int it7260_wait_device_ready(struct it7260_ts_data *ts_data,
+					bool forever, bool slowly)
 {
 	uint8_t query;
-	uint32_t count = DEVICE_READY_WAIT_10;
+	uint32_t count = DEVICE_READY_COUNT_20;
+	int ret;
 
-	if (gl_ts->fw_cfg_uploading || forever)
-		count = DEVICE_READY_MAX_WAIT;
+	if (ts_data->fw_cfg_uploading || forever)
+		count = DEVICE_READY_COUNT_MAX;
 
 	do {
-		if (!IT7260_i2cReadNoReadyCheck(BUF_QUERY, &query,
-						sizeof(query)))
-			query = CMD_STATUS_BUSY;
+		ret = it7260_i2c_read_no_ready_check(ts_data, BUF_QUERY, &query,
+						sizeof(query));
+		if (ret < 0 && ((query & CMD_STATUS_BITS)
+						== CMD_STATUS_NO_CONN))
+			continue;
 
+		if ((query & CMD_STATUS_BITS) == CMD_STATUS_DONE)
+			break;
+
+		query = CMD_STATUS_BUSY;
 		if (slowly)
-			msleep(IT_I2C_WAIT);
-	} while ((query & CMD_STATUS_BUSY) && --count);
+			msleep(IT_I2C_WAIT_10MS);
+	} while (--count);
 
-	return !query;
+	return ((!(query & CMD_STATUS_BITS)) ? 0 : -ENODEV);
 }
 
-static bool IT7260_i2cRead(uint8_t buf_index, uint8_t *buffer,
-						uint16_t buf_len)
+static int it7260_i2c_read(struct it7260_ts_data *ts_data, uint8_t buf_index,
+				uint8_t *buffer, uint16_t buf_len)
 {
-	IT7260_waitDeviceReady(false, false);
-	return IT7260_i2cReadNoReadyCheck(buf_index, buffer, buf_len);
+	int ret;
+
+	ret = it7260_wait_device_ready(ts_data, false, false);
+	if (ret < 0)
+		return ret;
+
+	return it7260_i2c_read_no_ready_check(ts_data, buf_index,
+					buffer, buf_len);
 }
 
-static bool IT7260_i2cWrite(uint8_t buf_index, const uint8_t *buffer,
-							uint16_t buf_len)
+static int it7260_i2c_write(struct it7260_ts_data *ts_data, uint8_t buf_index,
+			const uint8_t *buffer, uint16_t buf_len)
 {
-	IT7260_waitDeviceReady(false, false);
-	return IT7260_i2cWriteNoReadyCheck(buf_index, buffer, buf_len);
+	int ret;
+
+	ret = it7260_wait_device_ready(ts_data, false, false);
+	if (ret < 0)
+		return ret;
+
+	return it7260_i2c_write_no_ready_check(ts_data, buf_index,
+					buffer, buf_len);
 }
 
-static bool IT7260_firmware_reinitialize(u8 command)
+static int it7260_firmware_reinitialize(struct it7260_ts_data *ts_data,
+						u8 command)
 {
 	uint8_t cmd[] = {command};
 	uint8_t rsp[2];
+	int ret;
 
-	if (!IT7260_i2cWrite(BUF_COMMAND, cmd, sizeof(cmd)))
-		return false;
+	ret = it7260_i2c_write(ts_data, BUF_COMMAND, cmd, sizeof(cmd));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to write fw reinit command %d\n", ret);
+		return ret;
+	}
 
-	if (!IT7260_i2cRead(BUF_RESPONSE, rsp, sizeof(rsp)))
-		return false;
+	ret = it7260_i2c_read(ts_data, BUF_RESPONSE, rsp, sizeof(rsp));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read any response from chip %d\n", ret);
+		return ret;
+	}
 
 	/* a reply of two zero bytes signifies success */
-	return !rsp[0] && !rsp[1];
+	if (rsp[0] == 0 && rsp[1] == 0)
+		return 0;
+	else
+		return -EIO;
 }
 
-static bool IT7260_enter_exit_fw_ugrade_mode(bool enter)
+static int it7260_enter_exit_fw_ugrade_mode(struct it7260_ts_data *ts_data,
+							bool enter)
 {
 	uint8_t cmd[] = {CMD_FIRMWARE_UPGRADE, 0, 'I', 'T', '7', '2',
 						'6', '0', 0x55, 0xAA};
 	uint8_t resp[2];
+	int ret;
 
 	cmd[1] = enter ? SUB_CMD_ENTER_FW_UPGRADE_MODE :
 				SUB_CMD_EXIT_FW_UPGRADE_MODE;
-	if (!IT7260_i2cWrite(BUF_COMMAND, cmd, sizeof(cmd)))
-		return false;
 
-	if (!IT7260_i2cRead(BUF_RESPONSE, resp, sizeof(resp)))
-		return false;
+	ret = it7260_i2c_write(ts_data, BUF_COMMAND, cmd, sizeof(cmd));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to write CMD_FIRMWARE_UPGRADE %d\n", ret);
+		return ret;
+	}
+
+	ret = it7260_i2c_read(ts_data, BUF_RESPONSE, resp, sizeof(resp));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read any response from chip %d\n", ret);
+		return ret;
+	}
 
 	/* a reply of two zero bytes signifies success */
-	return !resp[0] && !resp[1];
+	if (resp[0] == 0 && resp[1] == 0)
+		return 0;
+	else
+		return -EIO;
 }
 
-static bool IT7260_chipSetStartOffset(uint16_t offset)
+static int it7260_set_start_offset(struct it7260_ts_data *ts_data,
+					uint16_t offset)
 {
 	uint8_t cmd[] = {CMD_SET_START_OFFSET, 0, ((uint8_t)(offset)),
 				((uint8_t)((offset) >> 8))};
 	uint8_t resp[2];
+	int ret;
 
-	if (!IT7260_i2cWrite(BUF_COMMAND, cmd, 4))
-		return false;
-
+	ret = it7260_i2c_write(ts_data, BUF_COMMAND, cmd, 4);
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to write CMD_SET_START_OFFSET %d\n", ret);
+		return ret;
+	}
 
-	if (!IT7260_i2cRead(BUF_RESPONSE, resp, sizeof(resp)))
-		return false;
 
+	ret = it7260_i2c_read(ts_data, BUF_RESPONSE, resp, sizeof(resp));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read any response from chip %d\n", ret);
+		return ret;
+	}
 
 	/* a reply of two zero bytes signifies success */
-	return !resp[0] && !resp[1];
+	if (resp[0] == 0 && resp[1] == 0)
+		return 0;
+	else
+		return -EIO;
 }
 
 
 /* write fw_length bytes from fw_data at chip offset wr_start_offset */
-static bool IT7260_fw_flash_write_verify(unsigned int fw_length,
-			const uint8_t *fw_data, uint16_t wr_start_offset)
+static int it7260_fw_flash_write_verify(struct it7260_ts_data *ts_data,
+			unsigned int fw_length,	const uint8_t *fw_data,
+			uint16_t wr_start_offset)
 {
 	uint32_t cur_data_off;
 
@@ -399,18 +478,19 @@ static bool IT7260_fw_flash_write_verify(unsigned int fw_length,
 		for (retries = 0; retries < FW_WRITE_RETRY_COUNT;
 							retries++) {
 
-			/* set write offset and write the data*/
-			IT7260_chipSetStartOffset(
+			/* set write offset and write the data */
+			it7260_set_start_offset(ts_data,
 					wr_start_offset + cur_data_off);
-			IT7260_i2cWrite(BUF_COMMAND, cmd_write,
+			it7260_i2c_write(ts_data, BUF_COMMAND, cmd_write,
 					cur_wr_size + 2);
 
 			/* set offset and read the data back */
-			IT7260_chipSetStartOffset(
+			it7260_set_start_offset(ts_data,
 					wr_start_offset + cur_data_off);
-			IT7260_i2cWrite(BUF_COMMAND, cmd_read,
+			it7260_i2c_write(ts_data, BUF_COMMAND, cmd_read,
 					sizeof(cmd_read));
-			IT7260_i2cRead(BUF_RESPONSE, buf_read, cur_wr_size);
+			it7260_i2c_read(ts_data, BUF_RESPONSE, buf_read,
+								cur_wr_size);
 
 			/* verify. If success break out of retry loop */
 			i = 0;
@@ -419,70 +499,99 @@ static bool IT7260_fw_flash_write_verify(unsigned int fw_length,
 				i++;
 			if (i == cur_wr_size)
 				break;
-			dev_err(&gl_ts->client->dev,
+		}
+		/* if we've failed after all the retries, tell the caller */
+		if (retries == FW_WRITE_RETRY_COUNT) {
+			dev_err(&ts_data->client->dev,
 				"write of data offset %u failed on try %u at byte %u/%u\n",
 				cur_data_off, retries, i, cur_wr_size);
+			return -EIO;
 		}
-		/* if we've failed after all the retries, tell the caller */
-		if (retries == FW_WRITE_RETRY_COUNT)
-			return false;
 	}
 
-	return true;
+	return 0;
 }
 
 /*
  * this code to get versions from the chip via i2c transactions, and save
  * them in driver data structure.
  */
-static void IT7260_get_chip_versions(struct device *dev)
+static void it7260_get_chip_versions(struct it7260_ts_data *ts_data)
 {
 	static const u8 cmd_read_fw_ver[] = {CMD_READ_VERSIONS,
 						SUB_CMD_READ_FIRMWARE_VERSION};
 	static const u8 cmd_read_cfg_ver[] = {CMD_READ_VERSIONS,
 						SUB_CMD_READ_CONFIG_VERSION};
 	u8 ver_fw[VERSION_LENGTH], ver_cfg[VERSION_LENGTH];
-	bool ret = true;
+	int ret;
 
-	ret = IT7260_i2cWrite(BUF_COMMAND, cmd_read_fw_ver,
+	ret = it7260_i2c_write(ts_data, BUF_COMMAND, cmd_read_fw_ver,
 					sizeof(cmd_read_fw_ver));
-	if (ret) {
-		ret = IT7260_i2cRead(BUF_RESPONSE, ver_fw, VERSION_LENGTH);
-		if (ret)
-			memcpy(gl_ts->fw_ver, ver_fw + (5 * sizeof(u8)),
+	if (ret == IT_I2C_WRITE_RET) {
+		/*
+		 * Sometimes, the controller may not respond immediately after
+		 * writing the command, so wait for device to get ready.
+		 */
+		ret = it7260_wait_device_ready(ts_data, true, false);
+		if (ret < 0)
+			dev_err(&ts_data->client->dev,
+				"failed to read chip status %d\n", ret);
+
+		ret = it7260_i2c_read_no_ready_check(ts_data, BUF_RESPONSE,
+					ver_fw, VERSION_LENGTH);
+		if (ret == IT_I2C_READ_RET)
+			memcpy(ts_data->fw_ver, ver_fw + (5 * sizeof(u8)),
 					VER_BUFFER_SIZE * sizeof(u8));
+		else
+			dev_err(&ts_data->client->dev,
+				"failed to read fw-ver from chip %d\n", ret);
+	} else {
+		dev_err(&ts_data->client->dev,
+				"failed to write fw-read command %d\n", ret);
 	}
-	if (!ret)
-		dev_err(dev, "failed to read fw version from chip\n");
 
-	ret = IT7260_i2cWrite(BUF_COMMAND, cmd_read_cfg_ver,
+	ret = it7260_i2c_write(ts_data, BUF_COMMAND, cmd_read_cfg_ver,
 					sizeof(cmd_read_cfg_ver));
-	if (ret) {
-		ret = IT7260_i2cRead(BUF_RESPONSE, ver_cfg, VERSION_LENGTH)
-					&& ret;
-		if (ret)
-			memcpy(gl_ts->cfg_ver, ver_cfg + (1 * sizeof(u8)),
+	if (ret == IT_I2C_WRITE_RET) {
+		/*
+		 * Sometimes, the controller may not respond immediately after
+		 * writing the command, so wait for device to get ready.
+		 */
+		ret = it7260_wait_device_ready(ts_data, true, false);
+		if (ret < 0)
+			dev_err(&ts_data->client->dev,
+				"failed to read chip status %d\n", ret);
+
+		ret = it7260_i2c_read_no_ready_check(ts_data, BUF_RESPONSE,
+					ver_cfg, VERSION_LENGTH);
+		if (ret == IT_I2C_READ_RET)
+			memcpy(ts_data->cfg_ver, ver_cfg + (1 * sizeof(u8)),
 					VER_BUFFER_SIZE * sizeof(u8));
+		else
+			dev_err(&ts_data->client->dev,
+				"failed to read cfg-ver from chip %d\n", ret);
+	} else {
+		dev_err(&ts_data->client->dev,
+				"failed to write cfg-read command %d\n", ret);
 	}
-	if (!ret)
-		dev_err(dev, "failed to read cfg version from chip\n");
 
-	dev_info(dev, "Current fw{%X.%X.%X.%X} cfg{%X.%X.%X.%X}\n",
-		gl_ts->fw_ver[0], gl_ts->fw_ver[1], gl_ts->fw_ver[2],
-		gl_ts->fw_ver[3], gl_ts->cfg_ver[0], gl_ts->cfg_ver[1],
-		gl_ts->cfg_ver[2], gl_ts->cfg_ver[3]);
+	dev_info(&ts_data->client->dev, "Current fw{%X.%X.%X.%X} cfg{%X.%X.%X.%X}\n",
+		ts_data->fw_ver[0], ts_data->fw_ver[1], ts_data->fw_ver[2],
+		ts_data->fw_ver[3], ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+		ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
 }
 
-static int IT7260_cfg_upload(struct device *dev, bool force)
+static int it7260_cfg_upload(struct it7260_ts_data *ts_data, bool force)
 {
 	const struct firmware *cfg = NULL;
 	int ret;
-	bool success, cfg_upgrade = false;
+	bool cfg_upgrade = false;
+	struct device *dev = &ts_data->client->dev;
 
-	ret = request_firmware(&cfg, gl_ts->cfg_name, dev);
+	ret = request_firmware(&cfg, ts_data->cfg_name, dev);
 	if (ret) {
 		dev_err(dev, "failed to get config data %s for it7260 %d\n",
-					gl_ts->cfg_name, ret);
+					ts_data->cfg_name, ret);
 		return ret;
 	}
 
@@ -493,43 +602,59 @@ static int IT7260_cfg_upload(struct device *dev, bool force)
 	 */
 	if (force)
 		cfg_upgrade = true;
-	else if (IT_CFG_CHECK(gl_ts->cfg_ver, cfg))
+	else if (IT_CFG_CHECK(ts_data->cfg_ver, cfg))
 		cfg_upgrade = true;
 
 	if (!cfg_upgrade) {
-		dev_err(dev, "CFG upgrade no required ...\n");
+		dev_err(dev, "CFG upgrade not required ...\n");
+		dev_info(dev,
+			"Chip CFG : %X.%X.%X.%X Binary CFG : %X.%X.%X.%X\n",
+			ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+			ts_data->cfg_ver[2], ts_data->cfg_ver[3],
+			cfg->data[cfg->size - 8], cfg->data[cfg->size - 7],
+			cfg->data[cfg->size - 6], cfg->data[cfg->size - 5]);
 		ret = -EFAULT;
 		goto out;
 	} else {
 		dev_info(dev, "Config upgrading...\n");
 
-		disable_irq(gl_ts->client->irq);
+		disable_irq(ts_data->client->irq);
 		/* enter cfg upload mode */
-		success = IT7260_enter_exit_fw_ugrade_mode(true);
-		if (!success) {
-			dev_err(dev, "Can't enter cfg upgrade mode\n");
-			ret = -EIO;
+		ret = it7260_enter_exit_fw_ugrade_mode(ts_data, true);
+		if (ret < 0) {
+			dev_err(dev, "Can't enter cfg upgrade mode %d\n", ret);
+			enable_irq(ts_data->client->irq);
 			goto out;
 		}
 		/* flash config data if requested */
-		success  = IT7260_fw_flash_write_verify(cfg->size, cfg->data,
-						CHIP_FLASH_SIZE - cfg->size);
-		if (!success) {
-			dev_err(dev, "failed to upgrade touch cfg data\n");
-			IT7260_enter_exit_fw_ugrade_mode(false);
-			IT7260_firmware_reinitialize(CMD_FIRMWARE_REINIT_6F);
+		ret  = it7260_fw_flash_write_verify(ts_data, cfg->size,
+					cfg->data, CHIP_FLASH_SIZE - cfg->size);
+		if (ret < 0) {
+			dev_err(dev,
+				"failed to upgrade touch cfg data %d\n", ret);
+			ret = it7260_enter_exit_fw_ugrade_mode(ts_data, false);
+			if (ret < 0)
+				dev_err(dev,
+					"Can't exit cfg upgrade mode%d\n", ret);
+
+			ret = it7260_firmware_reinitialize(ts_data,
+						CMD_FIRMWARE_REINIT_6F);
+			if (ret < 0)
+				dev_err(dev, "Can't reinit cfg %d\n", ret);
+
 			ret = -EIO;
+			enable_irq(ts_data->client->irq);
 			goto out;
 		} else {
-			memcpy(gl_ts->cfg_ver, cfg->data +
+			memcpy(ts_data->cfg_ver, cfg->data +
 					(cfg->size - 8 * sizeof(u8)),
 					VER_BUFFER_SIZE * sizeof(u8));
 			dev_info(dev, "CFG upgrade is success. New cfg ver: %X.%X.%X.%X\n",
-					gl_ts->cfg_ver[0], gl_ts->cfg_ver[1],
-					gl_ts->cfg_ver[2], gl_ts->cfg_ver[3]);
+				ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+				ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
 
 		}
-		enable_irq(gl_ts->client->irq);
+		enable_irq(ts_data->client->irq);
 	}
 
 out:
@@ -538,16 +663,17 @@ out:
 	return ret;
 }
 
-static int IT7260_fw_upload(struct device *dev, bool force)
+static int it7260_fw_upload(struct it7260_ts_data *ts_data, bool force)
 {
 	const struct firmware *fw = NULL;
 	int ret;
-	bool success, fw_upgrade = false;
+	bool fw_upgrade = false;
+	struct device *dev = &ts_data->client->dev;
 
-	ret = request_firmware(&fw, gl_ts->fw_name, dev);
+	ret = request_firmware(&fw, ts_data->fw_name, dev);
 	if (ret) {
 		dev_err(dev, "failed to get firmware %s for it7260 %d\n",
-					gl_ts->fw_name, ret);
+					ts_data->fw_name, ret);
 		return ret;
 	}
 
@@ -558,40 +684,55 @@ static int IT7260_fw_upload(struct device *dev, bool force)
 	 */
 	if (force)
 		fw_upgrade = true;
-	else if (IT_FW_CHECK(gl_ts->fw_ver, fw))
+	else if (IT_FW_CHECK(ts_data->fw_ver, fw))
 		fw_upgrade = true;
 
 	if (!fw_upgrade) {
 		dev_err(dev, "FW upgrade not required ...\n");
+		dev_info(dev, "Chip FW : %X.%X.%X.%X Binary FW : %X.%X.%X.%X\n",
+			ts_data->fw_ver[0], ts_data->fw_ver[1],
+			ts_data->fw_ver[2], ts_data->fw_ver[3],
+			fw->data[8], fw->data[9], fw->data[10], fw->data[11]);
 		ret = -EFAULT;
 		goto out;
 	} else {
 		dev_info(dev, "Firmware upgrading...\n");
 
-		disable_irq(gl_ts->client->irq);
+		disable_irq(ts_data->client->irq);
 		/* enter fw upload mode */
-		success = IT7260_enter_exit_fw_ugrade_mode(true);
-		if (!success) {
-			dev_err(dev, "Can't enter fw upgrade mode\n");
-			ret = -EIO;
+		ret = it7260_enter_exit_fw_ugrade_mode(ts_data, true);
+		if (ret < 0) {
+			dev_err(dev, "Can't enter fw upgrade mode %d\n", ret);
+			enable_irq(ts_data->client->irq);
 			goto out;
 		}
 		/* flash the firmware if requested */
-		success = IT7260_fw_flash_write_verify(fw->size, fw->data, 0);
-		if (!success) {
-			dev_err(dev, "failed to upgrade touch firmware\n");
-			IT7260_enter_exit_fw_ugrade_mode(false);
-			IT7260_firmware_reinitialize(CMD_FIRMWARE_REINIT_6F);
+		ret = it7260_fw_flash_write_verify(ts_data, fw->size,
+							fw->data, 0);
+		if (ret < 0) {
+			dev_err(dev,
+				"failed to upgrade touch firmware %d\n", ret);
+			ret = it7260_enter_exit_fw_ugrade_mode(ts_data, false);
+			if (ret < 0)
+				dev_err(dev,
+					"Can't exit fw upgrade mode %d\n", ret);
+
+			ret = it7260_firmware_reinitialize(ts_data,
+						CMD_FIRMWARE_REINIT_6F);
+			if (ret < 0)
+				dev_err(dev, "Can't reinit firmware %d\n", ret);
+
 			ret = -EIO;
+			enable_irq(ts_data->client->irq);
 			goto out;
 		} else {
-			memcpy(gl_ts->fw_ver, fw->data + (8 * sizeof(u8)),
+			memcpy(ts_data->fw_ver, fw->data + (8 * sizeof(u8)),
 					VER_BUFFER_SIZE * sizeof(u8));
 			dev_info(dev, "FW upgrade is success. New fw ver: %X.%X.%X.%X\n",
-					gl_ts->fw_ver[0], gl_ts->fw_ver[1],
-					gl_ts->fw_ver[2], gl_ts->fw_ver[3]);
+					ts_data->fw_ver[0], ts_data->fw_ver[1],
+					ts_data->fw_ver[2], ts_data->fw_ver[3]);
 		}
-		enable_irq(gl_ts->client->irq);
+		enable_irq(ts_data->client->irq);
 	}
 
 out:
@@ -600,50 +741,66 @@ out:
 	return ret;
 }
 
-static int IT7260_ts_chipLowPowerMode(const u8 sleep_type)
+static int it7260_ts_chip_low_power_mode(struct it7260_ts_data *ts_data,
+					const u8 sleep_type)
 {
-	const uint8_t cmd_sleep[] = {CMD_PWR_CTL, 0x00, sleep_type};
-	uint8_t dummy;
+	const u8 cmd_sleep[] = {CMD_PWR_CTL, 0x00, sleep_type};
+	u8 dummy;
+	int ret;
 
-	if (sleep_type)
-		IT7260_i2cWriteNoReadyCheck(BUF_COMMAND, cmd_sleep,
-					sizeof(cmd_sleep));
-	else
-		IT7260_i2cReadNoReadyCheck(BUF_QUERY, &dummy, sizeof(dummy));
+	if (sleep_type) {
+		ret = it7260_i2c_write_no_ready_check(ts_data, BUF_COMMAND,
+					cmd_sleep, sizeof(cmd_sleep));
+		if (ret != IT_I2C_WRITE_RET)
+			dev_err(&ts_data->client->dev,
+				"Can't go to sleep or low power mode(%d) %d\n",
+				sleep_type, ret);
+		else
+			ret = 0;
+	} else {
+		ret = it7260_i2c_read_no_ready_check(ts_data, BUF_QUERY, &dummy,
+						sizeof(dummy));
+		if (ret != IT_I2C_READ_RET)
+			dev_err(&ts_data->client->dev,
+				"Can't go to active mode %d\n", ret);
+		else
+			ret = 0;
+	}
 
 	msleep(WAIT_CHANGE_MODE);
-	return 0;
+	return ret;
 }
 
 static ssize_t sysfs_fw_upgrade_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int mode = 0, ret;
 
-	if (gl_ts->suspended) {
+	if (ts_data->suspended) {
 		dev_err(dev, "Device is suspended, can't flash fw!!!\n");
 		return -EBUSY;
 	}
 
-	ret = sscanf(buf, "%d", &mode);
-	if (!ret) {
+	ret = kstrtoint(buf, 10, &mode);
+	if (ret) {
 		dev_err(dev, "failed to read input for sysfs\n");
 		return -EINVAL;
 	}
 
-	mutex_lock(&gl_ts->fw_cfg_mutex);
+	mutex_lock(&ts_data->fw_cfg_mutex);
 	if (mode == 1) {
-		gl_ts->fw_cfg_uploading = true;
-		ret = IT7260_fw_upload(dev, false);
+		ts_data->fw_cfg_uploading = true;
+		ret = it7260_fw_upload(ts_data, false);
 		if (ret) {
 			dev_err(dev, "Failed to flash fw: %d", ret);
-			gl_ts->fw_upgrade_result = false;
+			ts_data->fw_upgrade_result = false;
 		 } else {
-			gl_ts->fw_upgrade_result = true;
+			ts_data->fw_upgrade_result = true;
 		}
-		gl_ts->fw_cfg_uploading = false;
+		ts_data->fw_cfg_uploading = false;
 	}
-	mutex_unlock(&gl_ts->fw_cfg_mutex);
+	mutex_unlock(&ts_data->fw_cfg_mutex);
 
 	return count;
 }
@@ -651,32 +808,33 @@ static ssize_t sysfs_fw_upgrade_store(struct device *dev,
 static ssize_t sysfs_cfg_upgrade_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int mode = 0, ret;
 
-	if (gl_ts->suspended) {
+	if (ts_data->suspended) {
 		dev_err(dev, "Device is suspended, can't flash cfg!!!\n");
 		return -EBUSY;
 	}
 
-	ret = sscanf(buf, "%d", &mode);
-	if (!ret) {
+	ret = kstrtoint(buf, 10, &mode);
+	if (ret) {
 		dev_err(dev, "failed to read input for sysfs\n");
 		return -EINVAL;
 	}
 
-	mutex_lock(&gl_ts->fw_cfg_mutex);
+	mutex_lock(&ts_data->fw_cfg_mutex);
 	if (mode == 1) {
-		gl_ts->fw_cfg_uploading = true;
-		ret = IT7260_cfg_upload(dev, false);
+		ts_data->fw_cfg_uploading = true;
+		ret = it7260_cfg_upload(ts_data, false);
 		if (ret) {
 			dev_err(dev, "Failed to flash cfg: %d", ret);
-			gl_ts->cfg_upgrade_result = false;
+			ts_data->cfg_upgrade_result = false;
 		} else {
-			gl_ts->cfg_upgrade_result = true;
+			ts_data->cfg_upgrade_result = true;
 		}
-		gl_ts->fw_cfg_uploading = false;
+		ts_data->fw_cfg_uploading = false;
 	}
-	mutex_unlock(&gl_ts->fw_cfg_mutex);
+	mutex_unlock(&ts_data->fw_cfg_mutex);
 
 	return count;
 }
@@ -684,46 +842,51 @@ static ssize_t sysfs_cfg_upgrade_store(struct device *dev,
 static ssize_t sysfs_fw_upgrade_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
 	return scnprintf(buf, MAX_BUFFER_SIZE, "%d\n",
-				gl_ts->fw_upgrade_result);
+				ts_data->fw_upgrade_result);
 }
 
 static ssize_t sysfs_cfg_upgrade_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
 	return scnprintf(buf, MAX_BUFFER_SIZE, "%d\n",
-				gl_ts->cfg_upgrade_result);
+				ts_data->cfg_upgrade_result);
 }
 
 static ssize_t sysfs_force_fw_upgrade_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int mode = 0, ret;
 
-	if (gl_ts->suspended) {
+	if (ts_data->suspended) {
 		dev_err(dev, "Device is suspended, can't flash fw!!!\n");
 		return -EBUSY;
 	}
 
-	ret = sscanf(buf, "%d", &mode);
-	if (!ret) {
+	ret = kstrtoint(buf, 10, &mode);
+	if (ret) {
 		dev_err(dev, "failed to read input for sysfs\n");
 		return -EINVAL;
 	}
 
-	mutex_lock(&gl_ts->fw_cfg_mutex);
+	mutex_lock(&ts_data->fw_cfg_mutex);
 	if (mode == 1) {
-		gl_ts->fw_cfg_uploading = true;
-		ret = IT7260_fw_upload(dev, true);
+		ts_data->fw_cfg_uploading = true;
+		ret = it7260_fw_upload(ts_data, true);
 		if (ret) {
 			dev_err(dev, "Failed to force flash fw: %d", ret);
-			gl_ts->fw_upgrade_result = false;
+			ts_data->fw_upgrade_result = false;
 		} else {
-			gl_ts->fw_upgrade_result = true;
+			ts_data->fw_upgrade_result = true;
 		}
-		gl_ts->fw_cfg_uploading = false;
+		ts_data->fw_cfg_uploading = false;
 	}
-	mutex_unlock(&gl_ts->fw_cfg_mutex);
+	mutex_unlock(&ts_data->fw_cfg_mutex);
 
 	return count;
 }
@@ -731,32 +894,33 @@ static ssize_t sysfs_force_fw_upgrade_store(struct device *dev,
 static ssize_t sysfs_force_cfg_upgrade_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int mode = 0, ret;
 
-	if (gl_ts->suspended) {
+	if (ts_data->suspended) {
 		dev_err(dev, "Device is suspended, can't flash cfg!!!\n");
 		return -EBUSY;
 	}
 
-	ret = sscanf(buf, "%d", &mode);
-	if (!ret) {
+	ret = kstrtoint(buf, 10, &mode);
+	if (ret) {
 		dev_err(dev, "failed to read input for sysfs\n");
 		return -EINVAL;
 	}
 
-	mutex_lock(&gl_ts->fw_cfg_mutex);
+	mutex_lock(&ts_data->fw_cfg_mutex);
 	if (mode == 1) {
-		gl_ts->fw_cfg_uploading = true;
-		ret = IT7260_cfg_upload(dev, true);
+		ts_data->fw_cfg_uploading = true;
+		ret = it7260_cfg_upload(ts_data, true);
 		if (ret) {
 			dev_err(dev, "Failed to force flash cfg: %d", ret);
-			gl_ts->cfg_upgrade_result = false;
+			ts_data->cfg_upgrade_result = false;
 		} else {
-			gl_ts->cfg_upgrade_result = true;
+			ts_data->cfg_upgrade_result = true;
 		}
-		gl_ts->fw_cfg_uploading = false;
+		ts_data->fw_cfg_uploading = false;
 	}
-	mutex_unlock(&gl_ts->fw_cfg_mutex);
+	mutex_unlock(&ts_data->fw_cfg_mutex);
 
 	return count;
 }
@@ -764,50 +928,65 @@ static ssize_t sysfs_force_cfg_upgrade_store(struct device *dev,
 static ssize_t sysfs_force_fw_upgrade_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, MAX_BUFFER_SIZE, "%d", gl_ts->fw_upgrade_result);
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, MAX_BUFFER_SIZE, "%d", ts_data->fw_upgrade_result);
 }
 
 static ssize_t sysfs_force_cfg_upgrade_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, MAX_BUFFER_SIZE, "%d", gl_ts->cfg_upgrade_result);
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, MAX_BUFFER_SIZE, "%d",
+				ts_data->cfg_upgrade_result);
 }
 
 static ssize_t sysfs_calibration_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
 	return scnprintf(buf, MAX_BUFFER_SIZE, "%d\n",
-				gl_ts->calibration_success);
+				ts_data->calibration_success);
 }
 
-static bool IT7260_chipSendCalibrationCmd(bool auto_tune_on)
+static int it7260_ts_send_calibration_cmd(struct it7260_ts_data *ts_data,
+						bool auto_tune_on)
 {
 	uint8_t cmd_calibrate[] = {CMD_CALIBRATE, 0,
 					auto_tune_on ? 1 : 0, 0, 0};
-	return IT7260_i2cWrite(BUF_COMMAND, cmd_calibrate,
+
+	return it7260_i2c_write(ts_data, BUF_COMMAND, cmd_calibrate,
 					sizeof(cmd_calibrate));
 }
 
 static ssize_t sysfs_calibration_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	uint8_t resp;
+	int ret;
 
-	if (!IT7260_chipSendCalibrationCmd(false))
+	ret = it7260_ts_send_calibration_cmd(ts_data, false);
+	if (ret < 0) {
 		dev_err(dev, "failed to send calibration command\n");
-	else {
-		gl_ts->calibration_success =
-			IT7260_i2cRead(BUF_RESPONSE, &resp, sizeof(resp));
+	} else {
+		ret = it7260_i2c_read(ts_data, BUF_RESPONSE, &resp,
+							sizeof(resp));
+		if (ret == IT_I2C_READ_RET)
+			ts_data->calibration_success = true;
 
-		/* previous logic that was here never called
-		 * IT7260_firmware_reinitialize() due to checking a
+		/*
+		 * previous logic that was here never called
+		 * it7260_firmware_reinitialize() due to checking a
 		 * guaranteed-not-null value against null. We now
 		 * call it. Hopefully this is OK
 		 */
 		if (!resp)
-			dev_info(dev, "IT7260_firmware_reinitialize-> %s\n",
-			IT7260_firmware_reinitialize(CMD_FIRMWARE_REINIT_6F)
-			? "success" : "fail");
+			dev_dbg(dev, "it7260_firmware_reinitialize-> %s\n",
+				it7260_firmware_reinitialize(ts_data,
+				CMD_FIRMWARE_REINIT_6F) ? "success" : "fail");
 	}
 
 	return count;
@@ -816,25 +995,27 @@ static ssize_t sysfs_calibration_store(struct device *dev,
 static ssize_t sysfs_point_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	uint8_t point_data[sizeof(struct PointData)];
-	bool readSuccess;
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+	uint8_t pt_data[sizeof(struct point_data)];
+	int readSuccess;
 	ssize_t ret;
 
-	readSuccess = IT7260_i2cReadNoReadyCheck(BUF_POINT_INFO, point_data,
-							sizeof(point_data));
-	if (readSuccess) {
+	readSuccess = it7260_i2c_read_no_ready_check(ts_data, BUF_POINT_INFO,
+					pt_data, sizeof(pt_data));
+
+	if (readSuccess == IT_I2C_READ_RET) {
 		ret = scnprintf(buf, MAX_BUFFER_SIZE,
 			"point_show read ret[%d]--point[%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x]\n",
-			readSuccess, point_data[0], point_data[1],
-			point_data[2], point_data[3], point_data[4],
-			point_data[5], point_data[6], point_data[7],
-			point_data[8], point_data[9], point_data[10],
-			point_data[11], point_data[12], point_data[13]);
+			readSuccess, pt_data[0], pt_data[1],
+			pt_data[2], pt_data[3], pt_data[4],
+			pt_data[5], pt_data[6], pt_data[7],
+			pt_data[8], pt_data[9], pt_data[10],
+			pt_data[11], pt_data[12], pt_data[13]);
 	} else {
 		 ret = scnprintf(buf, MAX_BUFFER_SIZE,
 			"failed to read point data\n");
 	}
-	dev_info(dev, "%s", buf);
+	dev_dbg(dev, "%s", buf);
 
 	return ret;
 }
@@ -842,51 +1023,57 @@ static ssize_t sysfs_point_show(struct device *dev,
 static ssize_t sysfs_version_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
 	return scnprintf(buf, MAX_BUFFER_SIZE,
 			"fw{%X.%X.%X.%X} cfg{%X.%X.%X.%X}\n",
-			gl_ts->fw_ver[0], gl_ts->fw_ver[1], gl_ts->fw_ver[2],
-			gl_ts->fw_ver[3], gl_ts->cfg_ver[0], gl_ts->cfg_ver[1],
-			gl_ts->cfg_ver[2], gl_ts->cfg_ver[3]);
+			ts_data->fw_ver[0], ts_data->fw_ver[1],
+			ts_data->fw_ver[2], ts_data->fw_ver[3],
+			ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+			ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
 }
 
 static ssize_t sysfs_sleep_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	/*
 	 * The usefulness of this was questionable at best - we were at least
 	 * leaking a byte of kernel data (by claiming to return a byte but not
 	 * writing to buf. To fix this now we actually return the sleep status
 	 */
-	*buf = gl_ts->suspended ? '1' : '0';
+	*buf = ts_data->suspended ? '1' : '0';
+
 	return 1;
 }
 
 static ssize_t sysfs_sleep_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int go_to_sleep, ret;
 
-	ret = sscanf(buf, "%d", &go_to_sleep);
+	ret = kstrtoint(buf, 10, &go_to_sleep);
 
-	/* (gl_ts->suspended == true && goToSleepVal > 0) means
+	/* (ts_data->suspended == true && goToSleepVal > 0) means
 	 * device is already suspended and you want it to be in sleep,
-	 * (gl_ts->suspended == false && goToSleepVal == 0) means
+	 * (ts_data->suspended == false && goToSleepVal == 0) means
 	 * device is already active and you also want it to be active.
 	 */
-	if ((gl_ts->suspended && go_to_sleep > 0) ||
-			(!gl_ts->suspended && go_to_sleep == 0))
+	if ((ts_data->suspended && go_to_sleep > 0) ||
+			(!ts_data->suspended && go_to_sleep == 0))
 		dev_err(dev, "duplicate request to %s chip\n",
 			go_to_sleep ? "sleep" : "wake");
 	else if (go_to_sleep) {
-		disable_irq(gl_ts->client->irq);
-		IT7260_ts_chipLowPowerMode(PWR_CTL_SLEEP_MODE);
+		disable_irq(ts_data->client->irq);
+		it7260_ts_chip_low_power_mode(ts_data, PWR_CTL_SLEEP_MODE);
 		dev_dbg(dev, "touch is going to sleep...\n");
 	} else {
-		IT7260_ts_chipLowPowerMode(PWR_CTL_ACTIVE_MODE);
-		enable_irq(gl_ts->client->irq);
+		it7260_ts_chip_low_power_mode(ts_data, PWR_CTL_ACTIVE_MODE);
+		enable_irq(ts_data->client->irq);
 		dev_dbg(dev, "touch is going to wake!\n");
 	}
-	gl_ts->suspended = go_to_sleep;
+	ts_data->suspended = go_to_sleep;
 
 	return count;
 }
@@ -894,6 +1081,7 @@ static ssize_t sysfs_sleep_store(struct device *dev,
 static ssize_t sysfs_cfg_name_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	char *strptr;
 
 	if (count >= MAX_BUFFER_SIZE) {
@@ -907,7 +1095,7 @@ static ssize_t sysfs_cfg_name_store(struct device *dev,
 		return -EINVAL;
 	}
 
-	strlcpy(gl_ts->cfg_name, buf, count);
+	strlcpy(ts_data->cfg_name, buf, count);
 
 	return count;
 }
@@ -915,9 +1103,11 @@ static ssize_t sysfs_cfg_name_store(struct device *dev,
 static ssize_t sysfs_cfg_name_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	if (strnlen(gl_ts->cfg_name, MAX_BUFFER_SIZE) > 0)
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
+	if (strnlen(ts_data->cfg_name, MAX_BUFFER_SIZE) > 0)
 		return scnprintf(buf, MAX_BUFFER_SIZE, "%s\n",
-				gl_ts->cfg_name);
+				ts_data->cfg_name);
 	else
 		return scnprintf(buf, MAX_BUFFER_SIZE,
 			"No config file name given\n");
@@ -926,6 +1116,7 @@ static ssize_t sysfs_cfg_name_show(struct device *dev,
 static ssize_t sysfs_fw_name_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	char *strptr;
 
 	if (count >= MAX_BUFFER_SIZE) {
@@ -939,21 +1130,57 @@ static ssize_t sysfs_fw_name_store(struct device *dev,
 		return -EINVAL;
 	}
 
-	strlcpy(gl_ts->fw_name, buf, count);
+	strlcpy(ts_data->fw_name, buf, count);
 	return count;
 }
 
 static ssize_t sysfs_fw_name_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	if (strnlen(gl_ts->fw_name, MAX_BUFFER_SIZE) > 0)
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+
+	if (strnlen(ts_data->fw_name, MAX_BUFFER_SIZE) > 0)
 		return scnprintf(buf, MAX_BUFFER_SIZE, "%s\n",
-			gl_ts->fw_name);
+			ts_data->fw_name);
 	else
 		return scnprintf(buf, MAX_BUFFER_SIZE,
 			"No firmware file name given\n");
 }
 
+static ssize_t sysfs_enable_wakeup_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
+	int mode = 0, ret;
+
+	if (ts_data->suspended) {
+		dev_err(dev, "Device is suspended, can't flash fw!!!\n");
+		return -EBUSY;
+	}
+
+	ret = kstrtoint(buf, 10, &mode);
+	if (ret) {
+		dev_err(dev, "failed to read input for sysfs\n");
+		return -EINVAL;
+	}
+
+	if (mode == 1)
+		device_init_wakeup(dev, true);
+	else if (mode == 0)
+		device_init_wakeup(dev, false);
+	else
+		dev_err(dev, "Wrong input, try again\n");
+
+	return count;
+}
+
+static ssize_t sysfs_enable_wakeup_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, MAX_BUFFER_SIZE, "%s\n",
+			device_may_wakeup(dev) ? "true" : "false");
+}
+
 static DEVICE_ATTR(version, S_IRUGO | S_IWUSR,
 			sysfs_version_show, NULL);
 static DEVICE_ATTR(sleep, S_IRUGO | S_IWUSR,
@@ -976,6 +1203,9 @@ static DEVICE_ATTR(force_fw_update, S_IRUGO | S_IWUSR,
 static DEVICE_ATTR(force_cfg_update, S_IRUGO | S_IWUSR,
 			sysfs_force_cfg_upgrade_show,
 			sysfs_force_cfg_upgrade_store);
+static DEVICE_ATTR(enable_wakeup, S_IRUGO | S_IWUSR,
+			sysfs_enable_wakeup_show,
+			sysfs_enable_wakeup_store);
 
 static struct attribute *it7260_attributes[] = {
 	&dev_attr_version.attr,
@@ -988,6 +1218,7 @@ static struct attribute *it7260_attributes[] = {
 	&dev_attr_cfg_name.attr,
 	&dev_attr_force_fw_update.attr,
 	&dev_attr_force_cfg_update.attr,
+	&dev_attr_enable_wakeup.attr,
 	NULL
 };
 
@@ -995,104 +1226,103 @@ static const struct attribute_group it7260_attr_group = {
 	.attrs = it7260_attributes,
 };
 
-static void IT7260_chipExternalCalibration(bool autoTuneEnabled)
-{
-	uint8_t resp[2];
-
-	dev_info(&gl_ts->client->dev, "sent calibration command -> %d\n",
-			IT7260_chipSendCalibrationCmd(autoTuneEnabled));
-	IT7260_waitDeviceReady(true, true);
-	IT7260_i2cReadNoReadyCheck(BUF_RESPONSE, resp, sizeof(resp));
-	IT7260_firmware_reinitialize(CMD_FIRMWARE_REINIT_C);
-}
-
-void IT7260_sendCalibrationCmd(void)
-{
-	IT7260_chipExternalCalibration(false);
-}
-EXPORT_SYMBOL(IT7260_sendCalibrationCmd);
-
-static void IT7260_ts_release_all(void)
+static void it7260_ts_release_all(struct it7260_ts_data *ts_data)
 {
 	int finger;
 
-	for (finger = 0; finger < gl_ts->pdata->num_of_fingers; finger++) {
-		input_mt_slot(gl_ts->input_dev, finger);
-		input_mt_report_slot_state(gl_ts->input_dev,
+	for (finger = 0; finger < ts_data->pdata->num_of_fingers; finger++) {
+		input_mt_slot(ts_data->input_dev, finger);
+		input_mt_report_slot_state(ts_data->input_dev,
 				MT_TOOL_FINGER, 0);
 	}
 
-	input_report_key(gl_ts->input_dev, BTN_TOUCH, 0);
-	input_sync(gl_ts->input_dev);
+	input_report_key(ts_data->input_dev, BTN_TOUCH, 0);
+	input_sync(ts_data->input_dev);
 }
 
-static irqreturn_t IT7260_ts_threaded_handler(int irq, void *devid)
+static irqreturn_t it7260_ts_threaded_handler(int irq, void *devid)
 {
-	struct PointData point_data;
-	struct input_dev *input_dev = gl_ts->input_dev;
+	struct point_data pt_data;
+	struct it7260_ts_data *ts_data = devid;
+	struct input_dev *input_dev = ts_data->input_dev;
 	u8 dev_status, finger, touch_count = 0, finger_status;
 	u8 pressure = FD_PRESSURE_NONE;
 	u16 x, y;
 	bool palm_detected;
+	int ret;
 
 	/* verify there is point data to read & it is readable and valid */
-	IT7260_i2cReadNoReadyCheck(BUF_QUERY, &dev_status, sizeof(dev_status));
-	if (!((dev_status & PT_INFO_BITS) & PT_INFO_YES))
-		return IRQ_HANDLED;
-	if (!IT7260_i2cReadNoReadyCheck(BUF_POINT_INFO, (void *)&point_data,
-						sizeof(point_data))) {
-		dev_err(&gl_ts->client->dev,
+	ret = it7260_i2c_read_no_ready_check(ts_data, BUF_QUERY, &dev_status,
+						sizeof(dev_status));
+	if (ret == IT_I2C_READ_RET)
+		if (!((dev_status & PT_INFO_BITS) & PT_INFO_YES))
+			return IRQ_HANDLED;
+	ret = it7260_i2c_read_no_ready_check(ts_data, BUF_POINT_INFO,
+				(void *)&pt_data, sizeof(pt_data));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
 			"failed to read point data buffer\n");
 		return IRQ_HANDLED;
 	}
 
 	/* Check if controller moves from idle to active state */
-	if ((point_data.flags & PD_FLAGS_DATA_TYPE_BITS) !=
+	if ((pt_data.flags & PD_FLAGS_DATA_TYPE_BITS) !=
 					PD_FLAGS_DATA_TYPE_TOUCH) {
 		/*
 		 * This code adds the touch-to-wake functionality to the ITE
 		 * tech driver. When user puts a finger on touch controller in
 		 * idle state, the controller moves to active state and driver
 		 * sends the KEY_WAKEUP event to wake the device. The
-		 * pm_stay_awake() call tells the pm core to stay awake untill
+		 * pm_stay_awake() call tells the pm core to stay awake until
 		 * the CPU cores are up already. The schedule_work() call
 		 * schedule a work that tells the pm core to relax once the CPU
 		 * cores are up.
 		 */
-		if (gl_ts->device_needs_wakeup) {
-			pm_stay_awake(&gl_ts->client->dev);
+		if ((pt_data.flags & PD_FLAGS_DATA_TYPE_BITS) ==
+				PD_FLAGS_IDLE_TO_ACTIVE &&
+				pt_data.gesture_id == 0 &&
+				device_may_wakeup(&ts_data->client->dev)) {
+			pm_stay_awake(&ts_data->client->dev);
 			input_report_key(input_dev, KEY_WAKEUP, 1);
 			input_sync(input_dev);
 			input_report_key(input_dev, KEY_WAKEUP, 0);
 			input_sync(input_dev);
-			schedule_work(&gl_ts->work_pm_relax);
-			return IRQ_HANDLED;
+			schedule_work(&ts_data->work_pm_relax);
+		} else {
+			dev_dbg(&ts_data->client->dev,
+				"Ignore the touch data\n");
 		}
+		return IRQ_HANDLED;
 	}
 
-	palm_detected = point_data.palm & PD_PALM_FLAG_BIT;
-	if (palm_detected && gl_ts->pdata->palm_detect_en) {
+	/*
+	 * Check if touch data also includes any palm gesture or not.
+	 * If palm gesture is detected, then send the keycode parsed
+	 * from the DT.
+	 */
+	palm_detected = pt_data.gesture_id & PD_PALM_FLAG_BIT;
+	if (palm_detected && ts_data->pdata->palm_detect_en) {
 		input_report_key(input_dev,
-				gl_ts->pdata->palm_detect_keycode, 1);
+				ts_data->pdata->palm_detect_keycode, 1);
 		input_sync(input_dev);
 		input_report_key(input_dev,
-				gl_ts->pdata->palm_detect_keycode, 0);
+				ts_data->pdata->palm_detect_keycode, 0);
 		input_sync(input_dev);
 	}
 
-	for (finger = 0; finger < gl_ts->pdata->num_of_fingers; finger++) {
-		finger_status = point_data.flags & (0x01 << finger);
+	for (finger = 0; finger < ts_data->pdata->num_of_fingers; finger++) {
+		finger_status = pt_data.flags & (0x01 << finger);
 
 		input_mt_slot(input_dev, finger);
 		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER,
 					finger_status != 0);
 
-		x = point_data.fd[finger].xLo +
-			(((u16)(point_data.fd[finger].hi & 0x0F)) << 8);
-		y = point_data.fd[finger].yLo +
-			(((u16)(point_data.fd[finger].hi & 0xF0)) << 4);
+		x = pt_data.fd[finger].xLo +
+			(((u16)(pt_data.fd[finger].hi & 0x0F)) << 8);
+		y = pt_data.fd[finger].yLo +
+			(((u16)(pt_data.fd[finger].hi & 0xF0)) << 4);
 
-		pressure = point_data.fd[finger].pressure & FD_PRESSURE_BITS;
+		pressure = pt_data.fd[finger].pressure & FD_PRESSURE_BITS;
 
 		if (finger_status) {
 			if (pressure >= FD_PRESSURE_LIGHT) {
@@ -1112,35 +1342,66 @@ static irqreturn_t IT7260_ts_threaded_handler(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
-static void IT7260_ts_work_func(struct work_struct *work)
+static void it7260_ts_work_func(struct work_struct *work)
 {
-	pm_relax(&gl_ts->client->dev);
+	struct it7260_ts_data *ts_data = container_of(work,
+				struct it7260_ts_data, work_pm_relax);
+
+	pm_relax(&ts_data->client->dev);
 }
 
-static int IT7260_chipIdentify(void)
+static int it7260_ts_chip_identify(struct it7260_ts_data *ts_data)
 {
 	static const uint8_t cmd_ident[] = {CMD_IDENT_CHIP};
 	static const uint8_t expected_id[] = {0x0A, 'I', 'T', 'E', '7',
 							'2', '6', '0'};
 	uint8_t chip_id[10] = {0,};
+	int ret;
 
-	IT7260_waitDeviceReady(false, false);
+	/*
+	 * Sometimes, the controller may not respond immediately after
+	 * writing the command, so wait for device to get ready.
+	 * FALSE means to retry 20 times at max to read the chip status.
+	 * TRUE means to add delay in each retry.
+	 */
+	ret = it7260_wait_device_ready(ts_data, false, true);
+	if (ret < 0) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip status %d\n", ret);
+		return ret;
+	}
 
-	if (!IT7260_i2cWriteNoReadyCheck(BUF_COMMAND, cmd_ident,
-							sizeof(cmd_ident))) {
-		dev_err(&gl_ts->client->dev, "failed to write CMD_IDENT_CHIP\n");
-		return -ENODEV;
+	ret = it7260_i2c_write_no_ready_check(ts_data, BUF_COMMAND, cmd_ident,
+							sizeof(cmd_ident));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to write CMD_IDENT_CHIP %d\n", ret);
+		return ret;
 	}
 
-	IT7260_waitDeviceReady(false, false);
+	/*
+	 * Sometimes, the controller may not respond immediately after
+	 * writing the command, so wait for device to get ready.
+	 * TRUE means to retry 500 times at max to read the chip status.
+	 * FALSE means to avoid unnecessary delays in each retry.
+	 */
+	ret = it7260_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip status %d\n", ret);
+		return ret;
+	}
 
-	if (!IT7260_i2cReadNoReadyCheck(BUF_RESPONSE, chip_id,
-							sizeof(chip_id))) {
-		dev_err(&gl_ts->client->dev, "failed to read chip-id\n");
-		return -ENODEV;
+
+	ret = it7260_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, chip_id,
+							sizeof(chip_id));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip-id %d\n", ret);
+		return ret;
 	}
-	dev_info(&gl_ts->client->dev,
-		"IT7260_chipIdentify read id: %02X %c%c%c%c%c%c%c %c%c\n",
+	dev_info(&ts_data->client->dev,
+		"it7260_ts_chip_identify read id: %02X %c%c%c%c%c%c%c %c%c\n",
 		chip_id[0], chip_id[1], chip_id[2], chip_id[3], chip_id[4],
 		chip_id[5], chip_id[6], chip_id[7], chip_id[8], chip_id[9]);
 
@@ -1148,11 +1409,11 @@ static int IT7260_chipIdentify(void)
 		return -EINVAL;
 
 	if (chip_id[8] == '5' && chip_id[9] == '6')
-		dev_info(&gl_ts->client->dev, "rev BX3 found\n");
+		dev_info(&ts_data->client->dev, "rev BX3 found\n");
 	else if (chip_id[8] == '6' && chip_id[9] == '6')
-		dev_info(&gl_ts->client->dev, "rev BX4 found\n");
+		dev_info(&ts_data->client->dev, "rev BX4 found\n");
 	else
-		dev_info(&gl_ts->client->dev, "unknown revision (0x%02X 0x%02X) found\n",
+		dev_info(&ts_data->client->dev, "unknown revision (0x%02X 0x%02X) found\n",
 						chip_id[8], chip_id[9]);
 
 	return 0;
@@ -1164,44 +1425,44 @@ static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
 		regulator_set_optimum_mode(reg, load_uA) : 0;
 }
 
-static int IT7260_regulator_configure(bool on)
+static int it7260_regulator_configure(struct it7260_ts_data *ts_data, bool on)
 {
 	int retval;
 
 	if (on == false)
 		goto hw_shutdown;
 
-	gl_ts->vdd = devm_regulator_get(&gl_ts->client->dev, "vdd");
-	if (IS_ERR(gl_ts->vdd)) {
-		dev_err(&gl_ts->client->dev,
+	ts_data->vdd = devm_regulator_get(&ts_data->client->dev, "vdd");
+	if (IS_ERR(ts_data->vdd)) {
+		dev_err(&ts_data->client->dev,
 				"%s: Failed to get vdd regulator\n", __func__);
-		return PTR_ERR(gl_ts->vdd);
+		return PTR_ERR(ts_data->vdd);
 	}
 
-	if (regulator_count_voltages(gl_ts->vdd) > 0) {
-		retval = regulator_set_voltage(gl_ts->vdd,
+	if (regulator_count_voltages(ts_data->vdd) > 0) {
+		retval = regulator_set_voltage(ts_data->vdd,
 			IT_VTG_MIN_UV, IT_VTG_MAX_UV);
 		if (retval) {
-			dev_err(&gl_ts->client->dev,
+			dev_err(&ts_data->client->dev,
 				"regulator set_vtg failed retval =%d\n",
 				retval);
 			goto err_set_vtg_vdd;
 		}
 	}
 
-	gl_ts->avdd = devm_regulator_get(&gl_ts->client->dev, "avdd");
-	if (IS_ERR(gl_ts->avdd)) {
-		dev_err(&gl_ts->client->dev,
+	ts_data->avdd = devm_regulator_get(&ts_data->client->dev, "avdd");
+	if (IS_ERR(ts_data->avdd)) {
+		dev_err(&ts_data->client->dev,
 				"%s: Failed to get i2c regulator\n", __func__);
-		retval = PTR_ERR(gl_ts->avdd);
+		retval = PTR_ERR(ts_data->avdd);
 		goto err_get_vtg_i2c;
 	}
 
-	if (regulator_count_voltages(gl_ts->avdd) > 0) {
-		retval = regulator_set_voltage(gl_ts->avdd,
+	if (regulator_count_voltages(ts_data->avdd) > 0) {
+		retval = regulator_set_voltage(ts_data->avdd,
 			IT_I2C_VTG_MIN_UV, IT_I2C_VTG_MAX_UV);
 		if (retval) {
-			dev_err(&gl_ts->client->dev,
+			dev_err(&ts_data->client->dev,
 				"reg set i2c vtg failed retval =%d\n",
 				retval);
 		goto err_set_vtg_i2c;
@@ -1212,55 +1473,55 @@ static int IT7260_regulator_configure(bool on)
 
 err_set_vtg_i2c:
 err_get_vtg_i2c:
-	if (regulator_count_voltages(gl_ts->vdd) > 0)
-		regulator_set_voltage(gl_ts->vdd, 0, IT_VTG_MAX_UV);
+	if (regulator_count_voltages(ts_data->vdd) > 0)
+		regulator_set_voltage(ts_data->vdd, 0, IT_VTG_MAX_UV);
 err_set_vtg_vdd:
 	return retval;
 
 hw_shutdown:
-	if (regulator_count_voltages(gl_ts->vdd) > 0)
-		regulator_set_voltage(gl_ts->vdd, 0, IT_VTG_MAX_UV);
-	if (regulator_count_voltages(gl_ts->avdd) > 0)
-		regulator_set_voltage(gl_ts->avdd, 0, IT_I2C_VTG_MAX_UV);
+	if (regulator_count_voltages(ts_data->vdd) > 0)
+		regulator_set_voltage(ts_data->vdd, 0, IT_VTG_MAX_UV);
+	if (regulator_count_voltages(ts_data->avdd) > 0)
+		regulator_set_voltage(ts_data->avdd, 0, IT_I2C_VTG_MAX_UV);
 	return 0;
 };
 
-static int IT7260_power_on(bool on)
+static int it7260_power_on(struct it7260_ts_data *ts_data, bool on)
 {
 	int retval;
 
 	if (on == false)
 		goto power_off;
 
-	retval = reg_set_optimum_mode_check(gl_ts->vdd,
+	retval = reg_set_optimum_mode_check(ts_data->vdd,
 		IT_ACTIVE_LOAD_UA);
 	if (retval < 0) {
-		dev_err(&gl_ts->client->dev,
+		dev_err(&ts_data->client->dev,
 			"Regulator vdd set_opt failed rc=%d\n",
 			retval);
 		return retval;
 	}
 
-	retval = regulator_enable(gl_ts->vdd);
+	retval = regulator_enable(ts_data->vdd);
 	if (retval) {
-		dev_err(&gl_ts->client->dev,
+		dev_err(&ts_data->client->dev,
 			"Regulator vdd enable failed rc=%d\n",
 			retval);
 		goto error_reg_en_vdd;
 	}
 
-	retval = reg_set_optimum_mode_check(gl_ts->avdd,
+	retval = reg_set_optimum_mode_check(ts_data->avdd,
 		IT_I2C_ACTIVE_LOAD_UA);
 	if (retval < 0) {
-		dev_err(&gl_ts->client->dev,
+		dev_err(&ts_data->client->dev,
 			"Regulator avdd set_opt failed rc=%d\n",
 			retval);
 		goto error_reg_opt_i2c;
 	}
 
-	retval = regulator_enable(gl_ts->avdd);
+	retval = regulator_enable(ts_data->avdd);
 	if (retval) {
-		dev_err(&gl_ts->client->dev,
+		dev_err(&ts_data->client->dev,
 			"Regulator avdd enable failed rc=%d\n",
 			retval);
 		goto error_reg_en_avdd;
@@ -1269,118 +1530,119 @@ static int IT7260_power_on(bool on)
 	return 0;
 
 error_reg_en_avdd:
-	reg_set_optimum_mode_check(gl_ts->avdd, 0);
+	reg_set_optimum_mode_check(ts_data->avdd, 0);
 error_reg_opt_i2c:
-	regulator_disable(gl_ts->vdd);
+	regulator_disable(ts_data->vdd);
 error_reg_en_vdd:
-	reg_set_optimum_mode_check(gl_ts->vdd, 0);
+	reg_set_optimum_mode_check(ts_data->vdd, 0);
 	return retval;
 
 power_off:
-	reg_set_optimum_mode_check(gl_ts->vdd, 0);
-	regulator_disable(gl_ts->vdd);
-	reg_set_optimum_mode_check(gl_ts->avdd, 0);
-	regulator_disable(gl_ts->avdd);
+	reg_set_optimum_mode_check(ts_data->vdd, 0);
+	regulator_disable(ts_data->vdd);
+	reg_set_optimum_mode_check(ts_data->avdd, 0);
+	regulator_disable(ts_data->avdd);
 
 	return 0;
 }
 
-static int IT7260_gpio_configure(bool on)
+static int it7260_gpio_configure(struct it7260_ts_data *ts_data, bool on)
 {
 	int retval = 0;
 
 	if (on) {
-		if (gpio_is_valid(gl_ts->pdata->irq_gpio)) {
+		if (gpio_is_valid(ts_data->pdata->irq_gpio)) {
 			/* configure touchscreen irq gpio */
-			retval = gpio_request(gl_ts->pdata->irq_gpio,
+			retval = gpio_request(ts_data->pdata->irq_gpio,
 					"ite_irq_gpio");
 			if (retval) {
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"unable to request irq gpio [%d]\n",
 					retval);
 				goto err_irq_gpio_req;
 			}
 
-			retval = gpio_direction_input(gl_ts->pdata->irq_gpio);
+			retval = gpio_direction_input(ts_data->pdata->irq_gpio);
 			if (retval) {
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"unable to set direction for irq gpio [%d]\n",
 					retval);
 				goto err_irq_gpio_dir;
 			}
 		} else {
-			dev_err(&gl_ts->client->dev,
+			dev_err(&ts_data->client->dev,
 				"irq gpio not provided\n");
 				goto err_irq_gpio_req;
 		}
 
-		if (gpio_is_valid(gl_ts->pdata->reset_gpio)) {
+		if (gpio_is_valid(ts_data->pdata->reset_gpio)) {
 			/* configure touchscreen reset out gpio */
-			retval = gpio_request(gl_ts->pdata->reset_gpio,
+			retval = gpio_request(ts_data->pdata->reset_gpio,
 					"ite_reset_gpio");
 			if (retval) {
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"unable to request reset gpio [%d]\n",
 					retval);
 					goto err_reset_gpio_req;
 			}
 
 			retval = gpio_direction_output(
-					gl_ts->pdata->reset_gpio, 1);
+					ts_data->pdata->reset_gpio, 1);
 			if (retval) {
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"unable to set direction for reset gpio [%d]\n",
 					retval);
 				goto err_reset_gpio_dir;
 			}
 
-			if (gl_ts->pdata->low_reset)
-				gpio_set_value(gl_ts->pdata->reset_gpio, 0);
+			if (ts_data->pdata->low_reset)
+				gpio_set_value(ts_data->pdata->reset_gpio, 0);
 			else
-				gpio_set_value(gl_ts->pdata->reset_gpio, 1);
+				gpio_set_value(ts_data->pdata->reset_gpio, 1);
 
-			msleep(gl_ts->pdata->reset_delay);
+			msleep(ts_data->pdata->reset_delay);
 		} else {
-			dev_err(&gl_ts->client->dev,
+			dev_err(&ts_data->client->dev,
 				"reset gpio not provided\n");
 				goto err_reset_gpio_req;
 		}
 	} else {
-		if (gpio_is_valid(gl_ts->pdata->irq_gpio))
-			gpio_free(gl_ts->pdata->irq_gpio);
-		if (gpio_is_valid(gl_ts->pdata->reset_gpio)) {
+		if (gpio_is_valid(ts_data->pdata->irq_gpio))
+			gpio_free(ts_data->pdata->irq_gpio);
+		if (gpio_is_valid(ts_data->pdata->reset_gpio)) {
 			/*
 			 * This is intended to save leakage current
 			 * only. Even if the call(gpio_direction_input)
 			 * fails, only leakage current will be more but
 			 * functionality will not be affected.
 			 */
-			retval = gpio_direction_input(gl_ts->pdata->reset_gpio);
+			retval = gpio_direction_input(
+					ts_data->pdata->reset_gpio);
 			if (retval) {
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"unable to set direction for gpio reset [%d]\n",
 					retval);
 			}
-			gpio_free(gl_ts->pdata->reset_gpio);
+			gpio_free(ts_data->pdata->reset_gpio);
 		}
 	}
 
 	return 0;
 
 err_reset_gpio_dir:
-	if (gpio_is_valid(gl_ts->pdata->reset_gpio))
-		gpio_free(gl_ts->pdata->reset_gpio);
+	if (gpio_is_valid(ts_data->pdata->reset_gpio))
+		gpio_free(ts_data->pdata->reset_gpio);
 err_reset_gpio_req:
 err_irq_gpio_dir:
-	if (gpio_is_valid(gl_ts->pdata->irq_gpio))
-		gpio_free(gl_ts->pdata->irq_gpio);
+	if (gpio_is_valid(ts_data->pdata->irq_gpio))
+		gpio_free(ts_data->pdata->irq_gpio);
 err_irq_gpio_req:
 	return retval;
 }
 
 #if CONFIG_OF
-static int IT7260_get_dt_coords(struct device *dev, char *name,
-				struct IT7260_ts_platform_data *pdata)
+static int it7260_get_dt_coords(struct device *dev, char *name,
+				struct it7260_ts_platform_data *pdata)
 {
 	u32 coords[IT7260_COORDS_ARR_SIZE];
 	struct property *prop;
@@ -1433,9 +1695,10 @@ static int IT7260_get_dt_coords(struct device *dev, char *name,
 	return 0;
 }
 
-static int IT7260_parse_dt(struct device *dev,
-				struct IT7260_ts_platform_data *pdata)
+static int it7260_parse_dt(struct device *dev,
+				struct it7260_ts_platform_data *pdata)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	struct device_node *np = dev->of_node;
 	u32 temp_val;
 	int rc;
@@ -1479,9 +1742,9 @@ static int IT7260_parse_dt(struct device *dev,
 		return rc;
 	}
 
-	snprintf(gl_ts->fw_name, MAX_BUFFER_SIZE, "%s",
+	snprintf(ts_data->fw_name, MAX_BUFFER_SIZE, "%s",
 		(pdata->fw_name != NULL) ? pdata->fw_name : FW_NAME);
-	snprintf(gl_ts->cfg_name, MAX_BUFFER_SIZE, "%s",
+	snprintf(ts_data->cfg_name, MAX_BUFFER_SIZE, "%s",
 		(pdata->cfg_name != NULL) ? pdata->cfg_name : CFG_NAME);
 
 	rc = of_property_read_u32(np, "ite,reset-delay", &temp_val);
@@ -1502,25 +1765,25 @@ static int IT7260_parse_dt(struct device *dev,
 
 	pdata->low_reset = of_property_read_bool(np, "ite,low-reset");
 
-	rc = IT7260_get_dt_coords(dev, "ite,display-coords", pdata);
+	rc = it7260_get_dt_coords(dev, "ite,display-coords", pdata);
 	if (rc && (rc != -EINVAL))
 		return rc;
 
-	rc = IT7260_get_dt_coords(dev, "ite,panel-coords", pdata);
+	rc = it7260_get_dt_coords(dev, "ite,panel-coords", pdata);
 	if (rc && (rc != -EINVAL))
 		return rc;
 
 	return 0;
 }
 #else
-static inline int IT7260_ts_parse_dt(struct device *dev,
-				struct IT7260_ts_platform_data *pdata)
+static inline int it7260_ts_parse_dt(struct device *dev,
+				struct it7260_ts_platform_data *pdata)
 {
 	return 0;
 }
 #endif
 
-static int IT7260_ts_pinctrl_init(struct IT7260_ts_data *ts_data)
+static int it7260_ts_pinctrl_init(struct it7260_ts_data *ts_data)
 {
 	int retval;
 
@@ -1574,11 +1837,12 @@ err_pinctrl_get:
 	return retval;
 }
 
-static int IT7260_ts_probe(struct i2c_client *client,
+static int it7260_ts_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
 {
 	static const uint8_t cmd_start[] = {CMD_UNKNOWN_7};
-	struct IT7260_ts_platform_data *pdata;
+	struct it7260_ts_data *ts_data;
+	struct it7260_ts_platform_data *pdata;
 	uint8_t rsp[2];
 	int ret = -1, err;
 	struct dentry *temp;
@@ -1588,23 +1852,19 @@ static int IT7260_ts_probe(struct i2c_client *client,
 		return -ENODEV;
 	}
 
-	gl_ts = devm_kzalloc(&client->dev, sizeof(*gl_ts), GFP_KERNEL);
-	if (!gl_ts) {
-		dev_err(&client->dev, "Failed to allocate memory for driver data\n");
+	ts_data = devm_kzalloc(&client->dev, sizeof(*ts_data), GFP_KERNEL);
+	if (!ts_data)
 		return -ENOMEM;
-	}
 
-	gl_ts->client = client;
-	i2c_set_clientdata(client, gl_ts);
+	ts_data->client = client;
+	i2c_set_clientdata(client, ts_data);
 
 	if (client->dev.of_node) {
-		pdata = devm_kzalloc(&client->dev,
-			sizeof(struct IT7260_ts_platform_data), GFP_KERNEL);
-		if (!pdata) {
-			dev_err(&client->dev, "Failed to allocate memory for pdata\n");
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
 			return -ENOMEM;
-		}
-		ret = IT7260_parse_dt(&client->dev, pdata);
+
+		ret = it7260_parse_dt(&client->dev, pdata);
 		if (ret)
 			return ret;
 	} else {
@@ -1612,19 +1872,19 @@ static int IT7260_ts_probe(struct i2c_client *client,
 	}
 
 	if (!pdata) {
-		dev_err(&client->dev, "Invalid pdata\n");
-		return -EINVAL;
+		dev_err(&client->dev, "No platform data found\n");
+		return -ENOMEM;
 	}
 
-	gl_ts->pdata = pdata;
+	ts_data->pdata = pdata;
 
-	ret = IT7260_regulator_configure(true);
+	ret = it7260_regulator_configure(ts_data, true);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to configure regulators\n");
 		goto err_reg_configure;
 	}
 
-	ret = IT7260_power_on(true);
+	ret = it7260_power_on(ts_data, true);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to power on\n");
 		goto err_power_device;
@@ -1636,81 +1896,82 @@ static int IT7260_ts_probe(struct i2c_client *client,
 	 */
 	msleep(DELAY_VTG_REG_EN);
 
-	ret = IT7260_ts_pinctrl_init(gl_ts);
-	if (!ret && gl_ts->ts_pinctrl) {
+	ret = it7260_ts_pinctrl_init(ts_data);
+	if (!ret && ts_data->ts_pinctrl) {
 		/*
 		 * Pinctrl handle is optional. If pinctrl handle is found
 		 * let pins to be configured in active state. If not
 		 * found continue further without error.
 		 */
-		ret = pinctrl_select_state(gl_ts->ts_pinctrl,
-					gl_ts->pinctrl_state_active);
+		ret = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_active);
 		if (ret < 0) {
-			dev_err(&gl_ts->client->dev,
+			dev_err(&ts_data->client->dev,
 				"failed to select pin to active state %d",
 				ret);
 		}
 	} else {
-		ret = IT7260_gpio_configure(true);
+		ret = it7260_gpio_configure(ts_data, true);
 		if (ret < 0) {
 			dev_err(&client->dev, "Failed to configure gpios\n");
 			goto err_gpio_config;
 		}
 	}
 
-	ret = IT7260_chipIdentify();
+	ret = it7260_ts_chip_identify(ts_data);
 	if (ret) {
 		dev_err(&client->dev, "Failed to identify chip %d!!!", ret);
 		goto err_identification_fail;
 	}
 
-	IT7260_get_chip_versions(&client->dev);
+	it7260_get_chip_versions(ts_data);
 
-	gl_ts->input_dev = input_allocate_device();
-	if (!gl_ts->input_dev) {
+	ts_data->input_dev = input_allocate_device();
+	if (!ts_data->input_dev) {
 		dev_err(&client->dev, "failed to allocate input device\n");
 		ret = -ENOMEM;
 		goto err_input_alloc;
 	}
 
 	/* Initialize mutex for fw and cfg upgrade */
-	mutex_init(&gl_ts->fw_cfg_mutex);
-
-	gl_ts->input_dev->name = DEVICE_NAME;
-	gl_ts->input_dev->phys = "I2C";
-	gl_ts->input_dev->id.bustype = BUS_I2C;
-	gl_ts->input_dev->id.vendor = 0x0001;
-	gl_ts->input_dev->id.product = 0x7260;
-	set_bit(EV_SYN, gl_ts->input_dev->evbit);
-	set_bit(EV_KEY, gl_ts->input_dev->evbit);
-	set_bit(EV_ABS, gl_ts->input_dev->evbit);
-	set_bit(INPUT_PROP_DIRECT, gl_ts->input_dev->propbit);
-	set_bit(BTN_TOUCH, gl_ts->input_dev->keybit);
-	input_set_abs_params(gl_ts->input_dev, ABS_MT_POSITION_X,
-		gl_ts->pdata->disp_minx, gl_ts->pdata->disp_maxx, 0, 0);
-	input_set_abs_params(gl_ts->input_dev, ABS_MT_POSITION_Y,
-		gl_ts->pdata->disp_miny, gl_ts->pdata->disp_maxy, 0, 0);
-	input_mt_init_slots(gl_ts->input_dev, gl_ts->pdata->num_of_fingers, 0);
-
-	input_set_drvdata(gl_ts->input_dev, gl_ts);
+	mutex_init(&ts_data->fw_cfg_mutex);
+
+	ts_data->input_dev->name = DEVICE_NAME;
+	ts_data->input_dev->phys = "I2C";
+	ts_data->input_dev->id.bustype = BUS_I2C;
+	ts_data->input_dev->id.vendor = 0x0001;
+	ts_data->input_dev->id.product = 0x7260;
+	set_bit(EV_SYN, ts_data->input_dev->evbit);
+	set_bit(EV_KEY, ts_data->input_dev->evbit);
+	set_bit(EV_ABS, ts_data->input_dev->evbit);
+	set_bit(INPUT_PROP_DIRECT, ts_data->input_dev->propbit);
+	set_bit(BTN_TOUCH, ts_data->input_dev->keybit);
+	input_set_abs_params(ts_data->input_dev, ABS_MT_POSITION_X,
+		ts_data->pdata->disp_minx, ts_data->pdata->disp_maxx, 0, 0);
+	input_set_abs_params(ts_data->input_dev, ABS_MT_POSITION_Y,
+		ts_data->pdata->disp_miny, ts_data->pdata->disp_maxy, 0, 0);
+	input_mt_init_slots(ts_data->input_dev,
+					ts_data->pdata->num_of_fingers, 0);
+
+	input_set_drvdata(ts_data->input_dev, ts_data);
 
 	if (pdata->wakeup) {
-		set_bit(KEY_WAKEUP, gl_ts->input_dev->keybit);
-		INIT_WORK(&gl_ts->work_pm_relax, IT7260_ts_work_func);
+		set_bit(KEY_WAKEUP, ts_data->input_dev->keybit);
+		INIT_WORK(&ts_data->work_pm_relax, it7260_ts_work_func);
 		device_init_wakeup(&client->dev, pdata->wakeup);
 	}
 
 	if (pdata->palm_detect_en)
-		set_bit(gl_ts->pdata->palm_detect_keycode,
-					gl_ts->input_dev->keybit);
+		set_bit(ts_data->pdata->palm_detect_keycode,
+					ts_data->input_dev->keybit);
 
-	if (input_register_device(gl_ts->input_dev)) {
+	if (input_register_device(ts_data->input_dev)) {
 		dev_err(&client->dev, "failed to register input device\n");
 		goto err_input_register;
 	}
 
-	if (request_threaded_irq(client->irq, NULL, IT7260_ts_threaded_handler,
-		IRQF_TRIGGER_LOW | IRQF_ONESHOT, client->name, gl_ts)) {
+	if (request_threaded_irq(client->irq, NULL, it7260_ts_threaded_handler,
+		IRQF_TRIGGER_LOW | IRQF_ONESHOT, client->name, ts_data)) {
 		dev_err(&client->dev, "request_irq failed\n");
 		goto err_irq_reg;
 	}
@@ -1721,30 +1982,31 @@ static int IT7260_ts_probe(struct i2c_client *client,
 	}
 
 #if defined(CONFIG_FB)
-	gl_ts->fb_notif.notifier_call = fb_notifier_callback;
+	ts_data->fb_notif.notifier_call = fb_notifier_callback;
 
-	ret = fb_register_client(&gl_ts->fb_notif);
+	ret = fb_register_client(&ts_data->fb_notif);
 	if (ret)
 		dev_err(&client->dev, "Unable to register fb_notifier %d\n",
 					ret);
 #endif
 	
-	IT7260_i2cWriteNoReadyCheck(BUF_COMMAND, cmd_start, sizeof(cmd_start));
+	it7260_i2c_write_no_ready_check(ts_data, BUF_COMMAND, cmd_start,
+							sizeof(cmd_start));
 	msleep(pdata->reset_delay);
-	IT7260_i2cReadNoReadyCheck(BUF_RESPONSE, rsp, sizeof(rsp));
+	it7260_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, rsp, sizeof(rsp));
 	msleep(pdata->reset_delay);
 
-	gl_ts->dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);
-	if (gl_ts->dir == NULL || IS_ERR(gl_ts->dir)) {
+	ts_data->dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);
+	if (ts_data->dir == NULL || IS_ERR(ts_data->dir)) {
 		dev_err(&client->dev,
 			"%s: Failed to create debugfs directory, ret = %ld\n",
-			__func__, PTR_ERR(gl_ts->dir));
-		ret = PTR_ERR(gl_ts->dir);
+			__func__, PTR_ERR(ts_data->dir));
+		ret = PTR_ERR(ts_data->dir);
 		goto err_create_debugfs_dir;
 	}
 
-	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, gl_ts->dir,
-					gl_ts, &debug_suspend_fops);
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, ts_data->dir,
+					ts_data, &debug_suspend_fops);
 	if (temp == NULL || IS_ERR(temp)) {
 		dev_err(&client->dev,
 			"%s: Failed to create suspend debugfs file, ret = %ld\n",
@@ -1756,40 +2018,40 @@ static int IT7260_ts_probe(struct i2c_client *client,
 	return 0;
 
 err_create_debugfs_file:
-	debugfs_remove_recursive(gl_ts->dir);
+	debugfs_remove_recursive(ts_data->dir);
 err_create_debugfs_dir:
 #if defined(CONFIG_FB)
-	if (fb_unregister_client(&gl_ts->fb_notif))
+	if (fb_unregister_client(&ts_data->fb_notif))
 		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
 #endif
 	sysfs_remove_group(&(client->dev.kobj), &it7260_attr_group);
 
 err_sysfs_grp_create:
-	free_irq(client->irq, gl_ts);
+	free_irq(client->irq, ts_data);
 
 err_irq_reg:
-	input_unregister_device(gl_ts->input_dev);
+	input_unregister_device(ts_data->input_dev);
 
 err_input_register:
 	if (pdata->wakeup) {
-		cancel_work_sync(&gl_ts->work_pm_relax);
+		cancel_work_sync(&ts_data->work_pm_relax);
 		device_init_wakeup(&client->dev, false);
 	}
-	if (gl_ts->input_dev)
-		input_free_device(gl_ts->input_dev);
-	gl_ts->input_dev = NULL;
+	if (ts_data->input_dev)
+		input_free_device(ts_data->input_dev);
+	ts_data->input_dev = NULL;
 
 err_input_alloc:
 err_identification_fail:
-	if (gl_ts->ts_pinctrl) {
-		if (IS_ERR_OR_NULL(gl_ts->pinctrl_state_release)) {
-			devm_pinctrl_put(gl_ts->ts_pinctrl);
-			gl_ts->ts_pinctrl = NULL;
+	if (ts_data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(ts_data->pinctrl_state_release)) {
+			devm_pinctrl_put(ts_data->ts_pinctrl);
+			ts_data->ts_pinctrl = NULL;
 		} else {
-			err = pinctrl_select_state(gl_ts->ts_pinctrl,
-					gl_ts->pinctrl_state_release);
+			err = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_release);
 			if (err)
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"failed to select relase pinctrl state %d\n",
 					err);
 		}
@@ -1801,54 +2063,55 @@ err_identification_fail:
 	}
 
 err_gpio_config:
-	IT7260_power_on(false);
+	it7260_power_on(ts_data, false);
 
 err_power_device:
-	IT7260_regulator_configure(false);
+	it7260_regulator_configure(ts_data, false);
 
 err_reg_configure:
 	return ret;
 }
 
-static int IT7260_ts_remove(struct i2c_client *client)
+static int it7260_ts_remove(struct i2c_client *client)
 {
+	struct it7260_ts_data *ts_data = i2c_get_clientdata(client);
 	int ret;
 
-	debugfs_remove_recursive(gl_ts->dir);
+	debugfs_remove_recursive(ts_data->dir);
 #if defined(CONFIG_FB)
-	if (fb_unregister_client(&gl_ts->fb_notif))
+	if (fb_unregister_client(&ts_data->fb_notif))
 		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
 #endif
 	sysfs_remove_group(&(client->dev.kobj), &it7260_attr_group);
-	free_irq(client->irq, gl_ts);
-	input_unregister_device(gl_ts->input_dev);
-	if (gl_ts->input_dev)
-		input_free_device(gl_ts->input_dev);
-	gl_ts->input_dev = NULL;
-	if (gl_ts->pdata->wakeup) {
-		cancel_work_sync(&gl_ts->work_pm_relax);
+	free_irq(client->irq, ts_data);
+	input_unregister_device(ts_data->input_dev);
+	if (ts_data->input_dev)
+		input_free_device(ts_data->input_dev);
+	ts_data->input_dev = NULL;
+	if (ts_data->pdata->wakeup) {
+		cancel_work_sync(&ts_data->work_pm_relax);
 		device_init_wakeup(&client->dev, false);
 	}
-	if (gl_ts->ts_pinctrl) {
-		if (IS_ERR_OR_NULL(gl_ts->pinctrl_state_release)) {
-			devm_pinctrl_put(gl_ts->ts_pinctrl);
-			gl_ts->ts_pinctrl = NULL;
+	if (ts_data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(ts_data->pinctrl_state_release)) {
+			devm_pinctrl_put(ts_data->ts_pinctrl);
+			ts_data->ts_pinctrl = NULL;
 		} else {
-			ret = pinctrl_select_state(gl_ts->ts_pinctrl,
-					gl_ts->pinctrl_state_release);
+			ret = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_release);
 			if (ret)
-				dev_err(&gl_ts->client->dev,
+				dev_err(&ts_data->client->dev,
 					"failed to select relase pinctrl state %d\n",
 					ret);
 		}
 	} else {
-		if (gpio_is_valid(gl_ts->pdata->reset_gpio))
-			gpio_free(gl_ts->pdata->reset_gpio);
-		if (gpio_is_valid(gl_ts->pdata->irq_gpio))
-			gpio_free(gl_ts->pdata->irq_gpio);
+		if (gpio_is_valid(ts_data->pdata->reset_gpio))
+			gpio_free(ts_data->pdata->reset_gpio);
+		if (gpio_is_valid(ts_data->pdata->irq_gpio))
+			gpio_free(ts_data->pdata->irq_gpio);
 	}
-	IT7260_power_on(false);
-	IT7260_regulator_configure(false);
+	it7260_power_on(ts_data, false);
+	it7260_regulator_configure(ts_data, false);
 
 	return 0;
 }
@@ -1857,17 +2120,19 @@ static int IT7260_ts_remove(struct i2c_client *client)
 static int fb_notifier_callback(struct notifier_block *self,
 			unsigned long event, void *data)
 {
+	struct it7260_ts_data *ts_data = container_of(self,
+					struct it7260_ts_data, fb_notif);
 	struct fb_event *evdata = data;
 	int *blank;
 
-	if (evdata && evdata->data && gl_ts && gl_ts->client) {
+	if (evdata && evdata->data && ts_data && ts_data->client) {
 		if (event == FB_EVENT_BLANK) {
 			blank = evdata->data;
 			if (*blank == FB_BLANK_UNBLANK)
-				IT7260_ts_resume(&(gl_ts->client->dev));
+				it7260_ts_resume(&(ts_data->client->dev));
 			else if (*blank == FB_BLANK_POWERDOWN ||
 					*blank == FB_BLANK_VSYNC_SUSPEND)
-				IT7260_ts_suspend(&(gl_ts->client->dev));
+				it7260_ts_suspend(&(ts_data->client->dev));
 		}
 	}
 
@@ -1876,139 +2141,193 @@ static int fb_notifier_callback(struct notifier_block *self,
 #endif
 
 #ifdef CONFIG_PM
-static int IT7260_ts_resume(struct device *dev)
+static int it7260_ts_resume(struct device *dev)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int retval;
 
 	if (device_may_wakeup(dev)) {
-		if (gl_ts->device_needs_wakeup) {
+		if (ts_data->in_low_power_mode) {
 			/* Set active current for the avdd regulator */
-			if (gl_ts->pdata->avdd_lpm_cur) {
-				retval = reg_set_optimum_mode_check(gl_ts->avdd,
+			if (ts_data->pdata->avdd_lpm_cur) {
+				retval = reg_set_optimum_mode_check(
+						ts_data->avdd,
 						IT_I2C_ACTIVE_LOAD_UA);
 				if (retval < 0)
 					dev_err(dev, "Regulator avdd set_opt failed at resume rc=%d\n",
 					retval);
 			}
 
-			gl_ts->device_needs_wakeup = false;
-			disable_irq_wake(gl_ts->client->irq);
+			ts_data->in_low_power_mode = false;
+			disable_irq_wake(ts_data->client->irq);
 		}
 		return 0;
 	}
 
-	if (gl_ts->ts_pinctrl) {
-		retval = pinctrl_select_state(gl_ts->ts_pinctrl,
-				gl_ts->pinctrl_state_active);
+	if (regulator_is_enabled(ts_data->vdd) &&
+				regulator_is_enabled(ts_data->vdd)) {
+		retval = it7260_power_on(ts_data, true);
+		if (retval < 0) {
+			dev_err(dev, "Cannot enable regulators, %d\n", retval);
+			goto err_power_on;
+		}
+	}
+
+	if (ts_data->ts_pinctrl) {
+		retval = pinctrl_select_state(ts_data->ts_pinctrl,
+				ts_data->pinctrl_state_active);
 		if (retval < 0) {
 			dev_err(dev, "Cannot get default pinctrl state %d\n",
 				retval);
 			goto err_pinctrl_select_suspend;
 		}
+	} else {
+		retval = it7260_gpio_configure(ts_data, true);
+		if (retval < 0) {
+			dev_err(dev, "Failed to configure gpios %d\n",
+								retval);
+			goto err_gpio_config;
+		}
 	}
 
-	enable_irq(gl_ts->client->irq);
-	gl_ts->suspended = false;
+	enable_irq(ts_data->client->irq);
+	ts_data->suspended = false;
 	return 0;
 
 err_pinctrl_select_suspend:
+err_gpio_config:
+	if (it7260_power_on(ts_data, false))
+		dev_err(dev, "Cannot disable regulators, %d\n", retval);
+err_power_on:
 	return retval;
 }
 
-static int IT7260_ts_suspend(struct device *dev)
+static int it7260_ts_suspend(struct device *dev)
 {
+	struct it7260_ts_data *ts_data = dev_get_drvdata(dev);
 	int retval;
 
-	if (gl_ts->fw_cfg_uploading) {
+	if (ts_data->fw_cfg_uploading) {
 		dev_dbg(dev, "Fw/cfg uploading. Can't go to suspend.\n");
 		return -EBUSY;
 	}
 
 	if (device_may_wakeup(dev)) {
-		if (!gl_ts->device_needs_wakeup) {
+		if (!ts_data->in_low_power_mode) {
 			/* put the device in low power idle mode */
-			IT7260_ts_chipLowPowerMode(PWR_CTL_LOW_POWER_MODE);
+			retval = it7260_ts_chip_low_power_mode(ts_data,
+						PWR_CTL_LOW_POWER_MODE);
+			if (retval)
+				dev_err(dev, "Can't go to low power mode %d\n",
+						retval);
 
 			/* Set lpm current for avdd regulator */
-			if (gl_ts->pdata->avdd_lpm_cur) {
-				retval = reg_set_optimum_mode_check(gl_ts->avdd,
-						gl_ts->pdata->avdd_lpm_cur);
+			if (ts_data->pdata->avdd_lpm_cur) {
+				retval = reg_set_optimum_mode_check(
+						ts_data->avdd,
+						ts_data->pdata->avdd_lpm_cur);
 				if (retval < 0)
 					dev_err(dev, "Regulator avdd set_opt failed at suspend rc=%d\n",
 						retval);
 			}
 
-			gl_ts->device_needs_wakeup = true;
-			enable_irq_wake(gl_ts->client->irq);
+			ts_data->in_low_power_mode = true;
+			enable_irq_wake(ts_data->client->irq);
 		}
 		return 0;
 	}
 
-	disable_irq(gl_ts->client->irq);
+	disable_irq(ts_data->client->irq);
 
-	IT7260_ts_release_all();
+	it7260_ts_release_all(ts_data);
 
-	if (gl_ts->ts_pinctrl) {
-		retval = pinctrl_select_state(gl_ts->ts_pinctrl,
-				gl_ts->pinctrl_state_suspend);
+	if (ts_data->ts_pinctrl) {
+		retval = pinctrl_select_state(ts_data->ts_pinctrl,
+				ts_data->pinctrl_state_suspend);
 		if (retval < 0) {
-			dev_err(dev, "Cannot get idle pinctrl state %d\n",
-				retval);
+			dev_err(dev, "Failed to get idle pinctrl state %d\n",
+								retval);
 			goto err_pinctrl_select_suspend;
 		}
+	} else {
+		retval = it7260_gpio_configure(ts_data, false);
+		if (retval < 0) {
+			dev_err(dev, "Failed to configure gpios %d\n", retval);
+			goto err_gpio_config;
+		}
+	}
+
+	if (!regulator_is_enabled(ts_data->vdd) &&
+				!regulator_is_enabled(ts_data->vdd)) {
+		retval = it7260_power_on(ts_data, false);
+		if (retval < 0) {
+			dev_err(dev, "Failed to disable regulators, %d\n",
+								retval);
+			goto err_power_on;
+		}
 	}
 
-	gl_ts->suspended = true;
+	ts_data->suspended = true;
 
 	return 0;
 
+err_power_on:
+	if (ts_data->ts_pinctrl) {
+		if (pinctrl_select_state(ts_data->ts_pinctrl,
+				ts_data->pinctrl_state_active))
+			dev_err(dev, "Cannot get active pinctrl state\n");
+	} else {
+		if (it7260_gpio_configure(ts_data, true))
+			dev_err(dev, "Failed to configure gpios\n");
+	}
 err_pinctrl_select_suspend:
+err_gpio_config:
 	return retval;
 }
 
-static const struct dev_pm_ops IT7260_ts_dev_pm_ops = {
-	.suspend = IT7260_ts_suspend,
-	.resume  = IT7260_ts_resume,
+static const struct dev_pm_ops it7260_ts_dev_pm_ops = {
+	.suspend = it7260_ts_suspend,
+	.resume  = it7260_ts_resume,
 };
 #else
-static int IT7260_ts_resume(struct device *dev)
+static int it7260_ts_resume(struct device *dev)
 {
 	return 0;
 }
 
-static int IT7260_ts_suspend(struct device *dev)
+static int it7260_ts_suspend(struct device *dev)
 {
 	return 0;
 }
 #endif
 
-static const struct i2c_device_id IT7260_ts_id[] = {
+static const struct i2c_device_id it7260_ts_id[] = {
 	{ DEVICE_NAME, 0},
 	{}
 };
 
-MODULE_DEVICE_TABLE(i2c, IT7260_ts_id);
+MODULE_DEVICE_TABLE(i2c, it7260_ts_id);
 
-static const struct of_device_id IT7260_match_table[] = {
+static const struct of_device_id it7260_match_table[] = {
 	{ .compatible = "ite,it7260_ts",},
 	{},
 };
 
-static struct i2c_driver IT7260_ts_driver = {
+static struct i2c_driver it7260_ts_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
 		.name = DEVICE_NAME,
-		.of_match_table = IT7260_match_table,
+		.of_match_table = it7260_match_table,
 #ifdef CONFIG_PM
-		.pm = &IT7260_ts_dev_pm_ops,
+		.pm = &it7260_ts_dev_pm_ops,
 #endif
 	},
-	.probe = IT7260_ts_probe,
-	.remove = IT7260_ts_remove,
-	.id_table = IT7260_ts_id,
+	.probe = it7260_ts_probe,
+	.remove = it7260_ts_remove,
+	.id_table = it7260_ts_id,
 };
 
-module_i2c_driver(IT7260_ts_driver);
+module_i2c_driver(it7260_ts_driver);
 
-MODULE_DESCRIPTION("IT7260 Touchscreen Driver");
+MODULE_DESCRIPTION("it7260 Touchscreen Driver");
 MODULE_LICENSE("GPL v2");
diff --git a/kernel/drivers/input/touchscreen/it7259_ts_i2c.c b/kernel/drivers/input/touchscreen/it7259_ts_i2c.c
new file mode 100755
index 0000000..e77b65b
--- /dev/null
+++ b/kernel/drivers/input/touchscreen/it7259_ts_i2c.c
@@ -0,0 +1,2640 @@
+/* drivers/input/touchscreen/it7258_ts_i2c.c
+ *
+ * Copyright (C) 2014 ITE Tech. Inc.
+ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/fb.h>
+#include <linux/debugfs.h>
+#include <linux/input/mt.h>
+#include <linux/string.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+#define MAX_BUFFER_SIZE			144
+#define DEVICE_NAME			"it7259"
+#define SCREEN_X_RESOLUTION		320
+#define SCREEN_Y_RESOLUTION		320
+#define DEBUGFS_DIR_NAME		"ts_debug"
+#define FW_NAME				"it7259_fw.bin"
+#define CFG_NAME			"it7259_cfg.bin"
+#define IT7259_CFG_PATH                 "/persist/it7259.cfg"
+#define IT7259_FW_PATH                  "/persist/it7259.fw"
+#define VER_BUFFER_SIZE			4
+#define IT_FW_CHECK(x, y) \
+	(((x)[0] < (y)->data[8]) || ((x)[1] < (y)->data[9]) || \
+	((x)[2] < (y)->data[10]) || ((x)[3] < (y)->data[11]))
+#define IT_CFG_CHECK(x, y) \
+	(((x)[0] < (y)->data[(y)->size - 8]) || \
+	((x)[1] < (y)->data[(y)->size - 7]) || \
+	((x)[2] < (y)->data[(y)->size - 6]) || \
+	((x)[3] < (y)->data[(y)->size - 5]))
+#define it7259_COORDS_ARR_SIZE		4
+
+/* all commands writes go to this idx */
+#define BUF_COMMAND			0x20
+#define BUF_SYS_COMMAND			0x40
+/*
+ * "device ready?" and "wake up please" and "read touch data" reads
+ * go to this idx
+ */
+#define BUF_QUERY			0x80
+/* most command response reads go to this idx */
+#define BUF_RESPONSE			0xA0
+#define BUF_SYS_RESPONSE		0xC0
+/* reads of "point" go through here and produce 14 bytes of data */
+#define BUF_POINT_INFO			0xE0
+
+/*
+ * commands and their subcommands. when no subcommands exist, a zero
+ * is send as the second byte
+ */
+#define CMD_IDENT_CHIP			0x00
+/* VERSION_LENGTH bytes of data in response */
+#define CMD_READ_VERSIONS		0x01
+#define SUB_CMD_READ_FIRMWARE_VERSION	0x00
+#define SUB_CMD_READ_CONFIG_VERSION	0x06
+#define VERSION_LENGTH			10
+/* subcommand is zero, next byte is power mode */
+#define CMD_PWR_CTL			0x04
+/* active mode */
+#define PWR_CTL_ACTIVE_MODE		0x00
+/* idle mode */
+#define PWR_CTL_LOW_POWER_MODE		0x01
+/* sleep mode */
+#define PWR_CTL_SLEEP_MODE		0x02
+#define WAIT_CHANGE_MODE		20
+/* command is not documented in the datasheet v1.0.0.7 */
+#define CMD_UNKNOWN_7			0x07
+#define CMD_FIRMWARE_REINIT_C		0x0C
+/* needs to be followed by 4 bytes of zeroes */
+#define CMD_CALIBRATE			0x13
+#define CMD_FIRMWARE_UPGRADE		0x60
+#define SUB_CMD_ENTER_FW_UPGRADE_MODE	0x00
+#define SUB_CMD_EXIT_FW_UPGRADE_MODE	0x80
+/* address for FW read/write */
+#define CMD_SET_START_OFFSET		0x61
+/* subcommand is number of bytes to write */
+#define CMD_FW_WRITE			0x62
+/* subcommand is number of bytes to read */
+#define CMD_FW_READ			0x63
+#define CMD_FIRMWARE_REINIT_6F		0x6F
+
+#define FW_WRITE_CHUNK_SIZE		128
+#define FW_WRITE_RETRY_COUNT		4
+#define CHIP_FLASH_SIZE			0x8000
+#define DEVICE_READY_COUNT_MAX		500
+#define DEVICE_READY_COUNT_20		20
+#define IT_I2C_WAIT_10MS		10
+#define IT_I2C_READ_RET			2
+#define IT_I2C_WRITE_RET		1
+
+/* result of reading with BUF_QUERY bits */
+#define CMD_STATUS_BITS			0x07
+#define CMD_STATUS_DONE			0x00
+#define CMD_STATUS_BUSY			0x01
+#define CMD_STATUS_ERROR		0x02
+#define CMD_STATUS_NO_CONN		0x07
+#define PT_INFO_BITS			0xF8
+#define PT_INFO_YES			0x80
+
+#define PD_FLAGS_DATA_TYPE_BITS		0xF0
+/* other types (like chip-detected gestures) exist but we do not care */
+#define PD_FLAGS_DATA_TYPE_TOUCH	0x00
+#define PD_FLAGS_IDLE_TO_ACTIVE		0x10
+/* a bit for each finger data that is valid (from lsb to msb) */
+#define PD_FLAGS_HAVE_FINGERS		0x07
+#define PD_PALM_FLAG_BIT		0x01
+#define FD_PRESSURE_BITS		0x0F
+#define FD_PRESSURE_NONE		0x00
+#define FD_PRESSURE_LIGHT		0x02
+
+#define IT_VTG_MIN_UV		1800000
+#define IT_VTG_MAX_UV		1800000
+#define IT_ACTIVE_LOAD_UA	15000
+#define IT_I2C_VTG_MIN_UV	2600000
+#define IT_I2C_VTG_MAX_UV	3300000
+#define IT_I2C_ACTIVE_LOAD_UA	10000
+#define DELAY_VTG_REG_EN	170
+
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+
+int download;
+#define COMMAND_SUCCESS         0x0000
+#define COMMAND_ERROR     0x0200
+#define ERROR_QUERY_TIME_OUT    0x0800
+
+
+struct finger_data {
+	u8 xLo;
+	u8 hi;
+	u8 yLo;
+	u8 pressure;
+}  __packed;
+
+struct point_data {
+	u8 flags;
+	u8 gesture_id;
+	struct finger_data fd[3];
+}  __packed;
+
+struct it7259_ts_platform_data {
+	u32 irq_gpio;
+	u32 irq_gpio_flags;
+	u32 reset_gpio;
+	u32 reset_gpio_flags;
+	bool wakeup;
+	bool palm_detect_en;
+	u16 palm_detect_keycode;
+	const char *fw_name;
+	const char *cfg_name;
+	unsigned int panel_minx;
+	unsigned int panel_miny;
+	unsigned int panel_maxx;
+	unsigned int panel_maxy;
+	unsigned int disp_minx;
+	unsigned int disp_miny;
+	unsigned int disp_maxx;
+	unsigned int disp_maxy;
+	unsigned num_of_fingers;
+	unsigned int reset_delay;
+	unsigned int avdd_lpm_cur;
+	bool low_reset;
+};
+
+struct it7259_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	const struct it7259_ts_platform_data *pdata;
+	struct regulator *vdd;
+	struct regulator *avdd;
+	bool in_low_power_mode;
+	bool suspended;
+	bool fw_upgrade_result;
+	bool cfg_upgrade_result;
+	bool fw_cfg_uploading;
+	struct work_struct work_pm_relax;
+	bool calibration_success;
+	bool had_finger_down;
+	char fw_name[MAX_BUFFER_SIZE];
+	char cfg_name[MAX_BUFFER_SIZE];
+	struct mutex fw_cfg_mutex;
+	u8 fw_ver[VER_BUFFER_SIZE];
+	u8 cfg_ver[VER_BUFFER_SIZE];
+#ifdef CONFIG_FB
+	struct notifier_block fb_notif;
+#endif
+	struct dentry *dir;
+	struct pinctrl *ts_pinctrl;
+	struct pinctrl_state *pinctrl_state_active;
+	struct pinctrl_state *pinctrl_state_suspend;
+	struct pinctrl_state *pinctrl_state_release;
+};
+
+/* Function declarations */
+static int fb_notifier_callback(struct notifier_block *self,
+			unsigned long event, void *data);
+static int it7259_ts_resume(struct device *dev);
+static int it7259_ts_suspend(struct device *dev);
+
+static int it7259_debug_suspend_set(void *_data, u64 val)
+{
+	struct it7259_ts_data *ts_data = _data;
+
+	if (val)
+		it7259_ts_suspend(&ts_data->client->dev);
+	else
+		it7259_ts_resume(&ts_data->client->dev);
+
+	return 0;
+}
+
+static int it7259_debug_suspend_get(void *_data, u64 *val)
+{
+	struct it7259_ts_data *ts_data = _data;
+
+	mutex_lock(&ts_data->input_dev->mutex);
+	*val = ts_data->suspended;
+	mutex_lock(&ts_data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, it7259_debug_suspend_get,
+				it7259_debug_suspend_set, "%lld\n");
+
+/* internal use func - does not make sure chip is ready before read */
+static int it7259_i2c_read_no_ready_check(struct it7259_ts_data *ts_data,
+			uint8_t buf_index, uint8_t *buffer, uint16_t buf_len)
+{
+	int ret;
+	struct i2c_msg msgs[2] = {
+		{
+			.addr = ts_data->client->addr,
+			.flags = I2C_M_NOSTART,
+			.len = 1,
+			.buf = &buf_index
+		},
+		{
+			.addr = ts_data->client->addr,
+			.flags = I2C_M_RD,
+			.len = buf_len,
+			.buf = buffer
+		}
+	};
+
+	memset(buffer, 0xFF, buf_len);
+
+	ret = i2c_transfer(ts_data->client->adapter, msgs, 2);
+	if (ret < 0)
+		dev_err(&ts_data->client->dev, "i2c read failed %d\n", ret);
+
+	return ret;
+}
+
+static int it7259_i2c_write_no_ready_check(struct it7259_ts_data *ts_data,
+		uint8_t buf_index, const uint8_t *buffer, uint16_t buf_len)
+{
+	uint8_t txbuf[257];
+	int ret;
+	struct i2c_msg msg = {
+		.addr = ts_data->client->addr,
+		.flags = 0,
+		.len = buf_len + 1,
+		.buf = txbuf
+	};
+
+	/* just to be careful */
+	if (buf_len > sizeof(txbuf) - 1) {
+		dev_err(&ts_data->client->dev, "buf length is out of limit\n");
+		return false;
+	}
+
+	txbuf[0] = buf_index;
+	memcpy(txbuf + 1, buffer, buf_len);
+
+	ret = i2c_transfer(ts_data->client->adapter, &msg, 1);
+	if (ret < 0)
+		dev_err(&ts_data->client->dev, "i2c write failed %d\n", ret);
+
+	return ret;
+}
+
+
+/*
+ * Device is apparently always ready for I2C communication but not for
+ * actual register reads/writes. This function checks if it is ready
+ * for that too. The results of this call often were ignored.
+ * If forever is set to TRUE, then check the device's status until it
+ * becomes ready with 500 retries at max. Otherwise retry 25 times only.
+ * If slowly is set to TRUE, then add sleep of 50 ms in each retry,
+ * otherwise don't sleep.
+ */
+static int it7259_wait_device_ready(struct it7259_ts_data *ts_data,
+					bool forever, bool slowly)
+{
+	uint8_t query;
+	uint32_t count = DEVICE_READY_COUNT_20;
+	int ret;
+
+	if (ts_data->fw_cfg_uploading || forever)
+		count = DEVICE_READY_COUNT_MAX;
+
+	do {
+		ret = it7259_i2c_read_no_ready_check(ts_data, BUF_QUERY, &query,
+						sizeof(query));
+		if (ret < 0 && ((query & CMD_STATUS_BITS)
+						== CMD_STATUS_NO_CONN))
+			continue;
+
+		if ((query & CMD_STATUS_BITS) == CMD_STATUS_DONE)
+			break;
+
+		query = CMD_STATUS_BUSY;
+		if (slowly)
+			msleep(IT_I2C_WAIT_10MS);
+	} while (--count);
+
+	return ((!(query & CMD_STATUS_BITS)) ? 0 : -ENODEV);
+}
+
+static int it7259_i2c_write(struct it7259_ts_data *ts_data, uint8_t buf_index,
+                        const uint8_t *buffer, uint16_t buf_len)
+{
+        int ret;
+
+        ret = it7259_wait_device_ready(ts_data, false, false);
+        if (ret < 0)
+                return ret;
+
+        return it7259_i2c_write_no_ready_check(ts_data, buf_index,
+                                        buffer, buf_len);
+}
+
+
+static int it7259_ts_chip_low_power_mode(struct it7259_ts_data *ts_data,
+					const u8 sleep_type)
+{
+	const u8 cmd_sleep[] = {CMD_PWR_CTL, 0x00, sleep_type};
+	u8 dummy;
+	int ret;
+
+	if (sleep_type) {
+		ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND,
+					cmd_sleep, sizeof(cmd_sleep));
+		if (ret != IT_I2C_WRITE_RET)
+			dev_err(&ts_data->client->dev,
+				"Can't go to sleep or low power mode(%d) %d\n",
+				sleep_type, ret);
+		else
+			ret = 0;
+	} else {
+		ret = it7259_i2c_read_no_ready_check(ts_data, BUF_QUERY, &dummy,
+						sizeof(dummy));
+		if (ret != IT_I2C_READ_RET)
+			dev_err(&ts_data->client->dev,
+				"Can't go to active mode %d\n", ret);
+		else
+			ret = 0;
+	}
+
+	msleep(WAIT_CHANGE_MODE);
+	return ret;
+}
+
+
+
+
+
+static int i2cInternalWriteToIT7259(struct it7259_ts_data *ts_data, int wAddress,
+                unsigned char const dataBuffer[], unsigned short dataLength)
+{
+        unsigned char buffer4Write[1024];
+        struct i2c_msg msgs[1] = { { .addr = ts_data->client->addr, .flags = 0, .len =
+                        dataLength + 3, .buf = buffer4Write } };
+        //printk("====in internal write function===\n");
+
+        buffer4Write[0] = 0x70;
+        buffer4Write[1] = (unsigned char)(wAddress &0xFF);
+
+        memcpy(&(buffer4Write[2]), dataBuffer, dataLength);
+        return i2c_transfer(ts_data->client->adapter, msgs, 1);
+}
+
+static int i2cDirectReadFromIT7259(struct it7259_ts_data *ts_data, int wAddress,
+                unsigned char readDataBuffer[], unsigned short readDataLength)
+{
+	int ret;
+	unsigned char buffer4Write[1024];
+	struct i2c_msg msgs[2] = { { .addr = ts_data->client->addr, .flags = 0,
+		.len = 4, .buf = buffer4Write }, { .addr = ts_data->client->addr, .flags =
+			I2C_M_RD, .len = readDataLength, .buf = readDataBuffer } };
+	//printk("====in Direct read function===\n");
+
+	buffer4Write[0] = 0x90;
+	buffer4Write[1] = 0x00;
+	buffer4Write[2] = (unsigned char)((wAddress &0xFF00) >> 8);
+	buffer4Write[3] = (unsigned char)(wAddress &0xFF);
+
+	memset(readDataBuffer, 0xFF, readDataLength);
+	ret = i2c_transfer(ts_data->client->adapter, msgs, 2);
+	return ret;
+}
+
+static int i2cDirectWriteToIT7259(struct it7259_ts_data *ts_data, int wAddress,
+                unsigned char const dataBuffer[], unsigned short dataLength)
+{
+        unsigned char buffer4Write[1024];
+        int nRetryCount = 0;
+        int nRet = 0;
+        struct i2c_msg msgs[1] = { { .addr = ts_data->client->addr, .flags = 0, .len =
+                        dataLength + 4, .buf = buffer4Write } };
+        //printk("====in Direct write function===\n");
+
+        buffer4Write[0] = 0x10;
+        buffer4Write[1] = 0x00;
+        buffer4Write[2] = (unsigned char)((wAddress &0xFF00) >> 8);
+        buffer4Write[3] = (unsigned char)(wAddress &0xFF);
+        memcpy(&(buffer4Write[4]), dataBuffer, dataLength);
+
+        do
+        {
+                nRet = i2c_transfer(ts_data->client->adapter, msgs, 1);
+
+        } while((nRet <= 0) && (nRetryCount++ < 10));
+
+        return  nRet;
+}
+
+
+static bool gfnIT7259_SPIFCRReady(struct it7259_ts_data *ts_data)
+{
+        int nReadCount=0;
+        unsigned char ucBuffer[2];
+
+        do {
+                i2cDirectReadFromIT7259(ts_data, 0xF400, ucBuffer, 2);//gfnIT7259_DirectReadMemoryRegister
+        }while(((ucBuffer[1]& 0x01)!=0x00) && ++nReadCount<20 ); //nReadCount 3000
+
+        if(nReadCount >=20) //nReadCount 3000
+                return false;
+
+        return true;
+}
+
+
+
+static int gfnIT7259_DirectReadFlash(struct it7259_ts_data *ts_data, int wFlashAddress, unsigned int readLength, unsigned char* pData)
+{
+        int nSector = 0;
+        unsigned char pucCommandBuffer[1024];
+        int wTmp;
+        int wAddress;
+        unsigned int /*AddrOffset, */LenOffset;
+        unsigned char bufTemp[4];
+        int wOffset;
+        int i;
+
+        nSector = wFlashAddress/0x0400;
+        pucCommandBuffer[0] = nSector;
+
+        //Select Sector
+        wAddress = 0xF404;
+        wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,1);
+        if(wTmp <= 0)
+        {
+                return COMMAND_ERROR;
+        }
+
+        //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        //Read flash
+        wOffset = wFlashAddress - (nSector*0x0400);
+        wAddress = 0x3000 + wOffset;
+        //printk("======= gfnIT7259_DirectReadFlash 8 byte limit =======\n");
+        for(LenOffset=0; LenOffset < readLength; LenOffset+=4)  //for 8 byte limit
+        {
+                wTmp = i2cDirectReadFromIT7259(ts_data, wAddress, bufTemp, 4);
+                if(wTmp <= 0)
+                {
+                        return COMMAND_ERROR;
+                }
+
+                for(i = 0; i < 4; i++)
+                {
+                        pucCommandBuffer[LenOffset + i] = bufTemp[i] ;
+                }
+                wAddress = wAddress + 4;
+        }
+
+        //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        memcpy((unsigned char*)pData, pucCommandBuffer, readLength * sizeof(unsigned char));
+
+        return COMMAND_SUCCESS;
+}
+
+static int i2cInternalReadFromIT7259(struct it7259_ts_data *ts_data,
+				int wAddress, unsigned char readDataBuffer[],
+				unsigned short readDataLength)
+{
+	int ret;
+	unsigned char buffer4Write[1024];
+	struct i2c_msg msgs[2] = { { .addr = ts_data->client->addr, .flags = 0,
+		.len = 2, .buf = buffer4Write }, { .addr = ts_data->client->addr, .flags =
+			I2C_M_RD, .len = readDataLength, .buf = readDataBuffer } };
+	//printk("====in internal read function===\n");
+
+	buffer4Write[0] = 0x70;
+	buffer4Write[1] = (unsigned char)(wAddress &0xFF);
+
+	memset(readDataBuffer, 0xFF, readDataLength);
+	ret = i2c_transfer(ts_data->client->adapter, msgs, 2);
+	return ret;
+
+}
+
+
+
+static int gfnIT7259_DirectEraseFlash(struct it7259_ts_data *ts_data, unsigned char ucEraseType, int wFlashAddress)
+{
+        int nSector = 0;
+        unsigned char pucCommandBuffer[1024];
+        int wTmp;
+        int wAddress;
+        nSector = wFlashAddress/0x0400;
+        pucCommandBuffer[0] = nSector;
+
+        //Select Sector
+        wAddress = 0xF404;
+        wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,1);
+        if(wTmp <= 0)
+        {
+                return COMMAND_ERROR;
+        }
+
+        //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        //Read flash
+        wAddress = 0xF402;
+        pucCommandBuffer[0] = ucEraseType;
+        wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,1);
+
+       //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        return COMMAND_SUCCESS;
+}
+
+
+static int gfnIT7259_DMAModeWriteFlash(struct it7259_ts_data *ts_data, int wFlashAddress, int wSRAMAddress,
+                        unsigned int dataLength, unsigned char* pData,  bool bPollingWait)
+{
+	int nSector = 0;
+	int wAddress;
+	int wTmp;
+	int i;
+	unsigned char pucCommandBuffer[1024];
+	unsigned char pucReadData[2];
+	unsigned int LenOffset;
+	unsigned char bufTemp[4];
+	unsigned int wStartAddress;
+
+	//write  to address 0x0000 (SRAM only 6K)
+	memset(bufTemp, 0xFF, 4); //for 8 byte limit
+	wAddress = wSRAMAddress;
+	printk("###write  to address 0x0000 (wSRAMAddress = %04x, dataLength = %02x)\n",
+			wSRAMAddress,dataLength);
+	for(LenOffset=0; LenOffset < dataLength; LenOffset+=4) {
+		for(i = 0; i < 4; i++) {
+			bufTemp[i] = pData[LenOffset + i];
+		}
+		wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,bufTemp,4);
+		if(wTmp <= 0) {
+			//printk("###write  to address 0x0000 fail!\n");                
+			return COMMAND_ERROR;
+		}
+		wAddress = wAddress + 4;
+		//printk(" ======== wAddress = %04x , LenOffset = %02x ========\n",wAddress,LenOffset);
+	}
+
+	//Select Sector 
+	memset(pucCommandBuffer, 0xFF, 1024);
+	nSector = wFlashAddress/0x0400;
+	pucCommandBuffer[0] = (unsigned char)(nSector & 0xFF);
+
+	wAddress = 0xF404;
+	wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,1);//DirectWriteMemoryRegister
+	if(wTmp <= 0) {
+		printk("###Select Sector fail!");
+		return COMMAND_ERROR;
+	}
+	//Wait SPIFCR
+	//printk("###Wait SPIFCR\n");
+	if(!gfnIT7259_SPIFCRReady(ts_data)) {
+		return ERROR_QUERY_TIME_OUT;
+	}
+
+	//Write Flash strat address
+	//printk("###Write Flash strat address\n");
+	memset(pucCommandBuffer, 0xFF, 1024);
+	wAddress = 0xF41A;
+	wStartAddress = wFlashAddress - (nSector*0x0400);
+	pucCommandBuffer[0] =  wStartAddress & 0x00FF;
+	pucCommandBuffer[1] =  (wStartAddress & 0xFF00) >> 8 ;
+	wTmp = i2cDirectWriteToIT7259(ts_data, wAddress, pucCommandBuffer, 2);//DirectWriteMemoryRegister  
+	if(wTmp <= 0) {
+		printk("###Write Flash strat address fail!\n");
+		return COMMAND_ERROR;
+	}
+
+	//Write SARM strat address
+	wAddress = 0xF41C;
+	memset(pucCommandBuffer, 0xFF, 1024);
+	pucCommandBuffer[0] =  wSRAMAddress & 0xFF;
+	pucCommandBuffer[1] =  (wSRAMAddress & 0xFF00) >> 8 ;
+	wTmp = i2cDirectWriteToIT7259(ts_data, wAddress, pucCommandBuffer, 2);//DirectWriteMemoryRegister
+	if(wTmp <= 0)
+	{
+		printk("###Write SARM strat address fail!\n");
+		return COMMAND_ERROR;
+	}
+
+	//write DMA transfer length
+	wAddress = 0xF41E;
+	pucCommandBuffer[0] =  dataLength & 0xFF;
+	pucCommandBuffer[1] =  (dataLength & 0xFF00) >> 8 ;
+	wTmp = i2cDirectWriteToIT7259(ts_data, wAddress, pucCommandBuffer, 2);//DirectWriteMemoryRegister
+	if(wTmp <= 0)
+	{
+		printk("###write DMA transfer length fail!\n");
+		return COMMAND_ERROR;
+	}
+
+	//Write DMA_DIR and DMAEN
+	wAddress = 0xF418;
+	pucCommandBuffer[0] = 0x0B; //auto erase
+	pucCommandBuffer[1] = 0x00;
+	wTmp = i2cDirectWriteToIT7259(ts_data, wAddress, pucCommandBuffer, 2);//DirectWriteMemoryRegister
+	if(wTmp <= 0)
+	{
+		printk("###Write DMA_DIR and DMAEN fail!\n");
+		return COMMAND_ERROR;
+	}
+	if(bPollingWait) {
+		//polling bit 0, until value of bit 0 = 0
+		wAddress = 0xF418;
+		do {
+			wTmp = i2cDirectReadFromIT7259(ts_data, wAddress, pucReadData, 2);//gfnIT7259_DirectReadMemoryRegister
+			if(wTmp <= 0) {
+				break;
+				return COMMAND_ERROR;
+			}
+		}while((pucReadData[0] & 0x01)!= 0x00);
+
+		//Wait SPIFCR
+		if(!gfnIT7259_SPIFCRReady(ts_data)) {
+			return ERROR_QUERY_TIME_OUT;
+		}
+
+	}
+	return COMMAND_SUCCESS;
+}
+
+static unsigned int gfnIT7259_GetFWSize(struct it7259_ts_data *ts_data)
+{
+        int wAddress;
+        unsigned char arucBuffer[1024];
+        unsigned int unRet = 0;
+
+        printk("###Entry gfnIT7259_GetFWSize()\n");
+        wAddress = 0;
+        gfnIT7259_DirectReadFlash(ts_data, wAddress, 0x0400, arucBuffer);
+
+        unRet = arucBuffer[0x80+12] + (arucBuffer[0x80+13] << 8);
+
+        return unRet;
+}
+
+
+static bool gfnIT7259_SwitchCPUClock(struct it7259_ts_data *ts_data, unsigned char ucMode)
+{
+        unsigned char ucCommandBuffer[1];
+        unsigned char ucRetCommandBuffer[1];
+        int nErrCount = 0;
+        int dwAddress = 0x0023;
+
+        ucCommandBuffer[0] = ucMode;
+
+        do
+        {
+                i2cInternalWriteToIT7259(ts_data, dwAddress,
+						ucCommandBuffer, 1);
+
+                i2cInternalReadFromIT7259(ts_data, dwAddress,
+						ucRetCommandBuffer, 1);
+
+                nErrCount++;
+        } while(((ucRetCommandBuffer[0] & 0x0F )  != ucMode) && nErrCount <= 1000);
+
+        if(nErrCount>1000) {
+                return false;
+        }
+
+        return true;
+
+}
+
+
+static int gfnIT7259_DirectWriteFlash(struct it7259_ts_data *ts_data, int wFlashAddress, unsigned int wWriteLength, unsigned char* pData)
+{
+        //printk("###Entry gfnIT7259_DirectWriteFlash()\n");    
+        //struct IT7259_ts_data *ts = gl_ts;    
+        //struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+        int nSector = 0;
+        unsigned char pucCommandBuffer[1024];
+        int wTmp;
+        int wAddress;
+        int wOffset;
+        nSector = wFlashAddress/0x0400;
+        pucCommandBuffer[0] = nSector;
+
+        //Select Sector
+        wAddress = 0xF404;
+        wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,1);
+        if(wTmp <= 0)
+        {
+                return COMMAND_ERROR;
+        }
+
+        //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        //write flash
+        wOffset = wFlashAddress - (nSector*0x0400);
+        wAddress = 0x3000 + wOffset;
+        memcpy(pucCommandBuffer, (unsigned char*)pData, wWriteLength * sizeof(unsigned char));
+        //wTmp = gfnIT7259_DirectWriteMemoryRegister(0x01,wAddress,0x0000,wWriteLength, pucCommandBuffer);
+        wTmp = i2cDirectWriteToIT7259(ts_data,wAddress,pucCommandBuffer,wWriteLength);
+
+        if(wTmp <= 0)
+        {
+                return COMMAND_ERROR;
+        }
+
+        //Wait SPIFCR
+        if(!gfnIT7259_SPIFCRReady(ts_data))
+        {
+                return ERROR_QUERY_TIME_OUT;
+        }
+
+        return COMMAND_SUCCESS;
+}
+
+
+static bool gfnIT7259_FirmwareDownload(struct it7259_ts_data *ts_data, unsigned int unFirmwareLength,
+                        unsigned char arucFW[], unsigned int unConfigLength, unsigned char arucConfig[])
+{
+	int dwAddress;
+	unsigned char RetDATABuffer[10];
+	unsigned char DATABuffer[10];
+	int nSector = 0;
+	unsigned int nFillSize = 0;
+	int wTmp;
+	unsigned int unTmp;
+	unsigned int nConfigSize;
+	unsigned long 	dwFlashSize = 0x10000;
+	unsigned int nEndFwSector;
+	unsigned int nStartCFGSector;
+	unsigned char putFWBuffer[1024];
+	int wAddress;
+	int wRemainderFWAddress;
+	int wConfigAddress = 0;
+	unsigned int nRemainderFwSize = 0;
+	unsigned int i = 0;
+	int nConfigCount = 0;
+	int nSize = 0;
+	//int Tmp = 0;
+
+	if((unFirmwareLength == 0) && (unConfigLength == 0)) {
+		printk("XXX %s, %d\n", __FUNCTION__, __LINE__);
+		return false;
+	}
+
+
+	//trun off CPU data clock
+	if (!gfnIT7259_SwitchCPUClock(ts_data, 0x01))
+	{
+		printk("###002 gfnIT7259_SwitchCPUClock(0x01) fail!\n");
+		return false;
+	}
+
+
+	//Wait SPIFCR
+	//printk("###003 Wait SPIFCR\n");       
+	dwAddress = 0xF400;
+	do
+	{
+		i2cDirectReadFromIT7259(ts_data,dwAddress,RetDATABuffer,2);
+	}
+	while((RetDATABuffer[1] & 0x01 )  != 0x00);
+	//printk("###003 End SPIFCR\n");
+	//Erase signature
+	//printk("###004 Erase signature\n");
+	dwAddress = 0xF404;
+	DATABuffer[0] = 0x3F;
+	i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,1);
+
+	dwAddress = 0xF402;
+	DATABuffer[0] = 0xD7;
+	i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,1);
+
+	//Wait SPIFCR
+	//printk("###005 Wait SPIFCR\n");
+	dwAddress = 0xF400;
+	do
+	{
+		i2cDirectReadFromIT7259(ts_data,dwAddress,RetDATABuffer,2);
+	}
+	while((RetDATABuffer[1] & 0x01 )  != 0x00);
+	//printk("###005 End SPIFCR\n");
+	if((download == 2)||(download == 3)) {
+		//Download FW
+		printk("###006 Download FW\n");
+		for(i  = 0 ; i < unFirmwareLength ; i+=0x0400) {
+			if(( unFirmwareLength - i) >= 0x0400)//0x0400
+				nFillSize = 0x0400;//0x0400
+			else
+				nFillSize = unFirmwareLength - i ;
+
+			wTmp = gfnIT7259_DMAModeWriteFlash(ts_data, i, 0x0000,
+							nFillSize,arucFW+i, true);
+
+			mdelay(100);//for test
+			if(wTmp != COMMAND_SUCCESS) {
+				//Write Firmware Flash error
+				printk("###DMA ModeWrite Firmware Flash error(FlashAddress:%04x)\n", i);
+				return false;
+			}
+		}
+
+		//3. Fw CRC Check       
+		//check FW CRC
+		//printk("###007 check FW CRC\n");
+		//write start address
+
+		dwAddress = 0xF40A;
+		DATABuffer[0] = 0x00;
+		DATABuffer[1] = 0x00;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,2);
+
+		//write end address
+		dwAddress = 0xF40C;
+		DATABuffer[0] = (unFirmwareLength-3) & 0x00ff ;
+		DATABuffer[1] = ((unFirmwareLength-3) & 0xff00)>>8;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,2);
+
+		//write CRCCR
+		dwAddress = 0xF408;
+		DATABuffer[0] = 0x01 ;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,1);
+
+		//wait CRCCR
+		dwAddress = 0xF408;
+		do
+		{
+			i2cDirectReadFromIT7259(ts_data,dwAddress,RetDATABuffer,2);
+		}
+		while((RetDATABuffer[0] & 0x01 )  != 0x00);
+
+		//read CRC
+		dwAddress = 0xF40E;
+		i2cDirectReadFromIT7259(ts_data,dwAddress,RetDATABuffer,2);
+
+		//compare FW CRC
+		//printk("###008 compare FW CRC\n");
+
+		if (RetDATABuffer[0]!= arucFW[unFirmwareLength - 2] || RetDATABuffer[1]!= arucFW[unFirmwareLength - 1])
+		{
+			printk("###008 FW CRC check fail\n");
+			printk("RetDATABuffer[0]:%02x,RetDATABuffer[1]:%02x,FW[Length-2]:%02x,FW[Length-1]:%02x\n",
+				RetDATABuffer[0], RetDATABuffer[1],
+				arucFW[unFirmwareLength - 2],
+				arucFW[unFirmwareLength - 1]);
+			return false;//FW CRC check fail
+		}
+	}
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+	if((download == 1) || (download == 3)) {
+		//download config
+		printk("###009 start to download config\n");
+		unTmp = gfnIT7259_GetFWSize(ts_data);
+		nConfigSize = unConfigLength;
+
+		//3.7 get address for writing config (in flash)
+		//check whether fw and config are in the same sector or not
+		//set flash size
+	
+		nEndFwSector = (unTmp-1) / 1024;
+		nStartCFGSector = 62 - (unConfigLength-1)/1024;
+		nRemainderFwSize = 0;
+
+		if(nEndFwSector == nStartCFGSector) {
+			nRemainderFwSize = unTmp - nEndFwSector*1024;
+			wAddress = nEndFwSector*0x0400;
+			//printk(" =========== nRemainderFwSize = %4x ===========\n",nRemainderFwSize);
+			gfnIT7259_DirectReadFlash(ts_data, wAddress, nRemainderFwSize, putFWBuffer);
+		}
+
+		//get config start address      
+		wTmp = dwFlashSize -1024 - unConfigLength;
+		//printk("###010 get config start address(%04x)\n",wTmp);
+
+		for(i = wTmp ; i<(dwFlashSize -1024) ; i+=0x0400) {
+			nSector = i/0x0400;
+
+			if((nRemainderFwSize!=0) && (nSector == nStartCFGSector)) {
+				wRemainderFWAddress = nStartCFGSector*0x0400;
+				nFillSize = nRemainderFwSize;
+				gfnIT7259_DMAModeWriteFlash(ts_data, wRemainderFWAddress,0x0000,nFillSize,putFWBuffer,true);
+			}
+			//write config
+			nSize = (unConfigLength - (62-nSector)*1024);
+
+			if( nSize >=1024) {
+				wConfigAddress = nSector * 0x0400;
+				nFillSize = 1024;
+			} else {
+				wConfigAddress = i;
+				nFillSize = nSize;
+			}
+
+			wTmp = gfnIT7259_DMAModeWriteFlash(ts_data,
+					wConfigAddress, 0x0000, nFillSize,
+					arucConfig + nConfigCount , true);
+
+			if(wTmp != COMMAND_SUCCESS)
+				return false;
+
+			nConfigCount += nFillSize;
+		}
+
+		//Config CRC Check
+		//printk("###011 Config CRC Check\n");
+		//write start address
+		dwAddress = 0xF40A;
+		DATABuffer[0] = (0x10000 - unConfigLength -1024) & 0x00ff;
+		DATABuffer[1] = ((0x10000- unConfigLength -1024) & 0xff00)>>8;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,2);
+
+		//write end address
+		dwAddress = 0xF40C;
+		DATABuffer[0] = (0x10000 -1024 -3)& 0x00ff;
+		DATABuffer[1] = ((0x10000-1024 -3) & 0xff00)>>8;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,2);
+
+		//write CRCCR
+		dwAddress = 0xF408;
+		DATABuffer[0] = 0x01 ;
+		i2cDirectWriteToIT7259(ts_data,dwAddress,DATABuffer,1);
+
+		//wait CRCCR
+		dwAddress = 0xF408;
+		do
+		{
+			i2cDirectReadFromIT7259(ts_data, dwAddress,
+						RetDATABuffer, 2);
+		}
+		while((RetDATABuffer[0] & 0x01 )  != 0x00);
+
+		//read CRC
+		dwAddress = 0xF40E;
+		i2cDirectReadFromIT7259(ts_data, dwAddress,
+					RetDATABuffer, 2);
+
+		//compare Config CRC
+		if ((RetDATABuffer[0]!= arucConfig[unConfigLength - 2]) ||
+			(RetDATABuffer[1]!= arucConfig[unConfigLength - 1])) {
+			printk("###011 config CRC Check Error\n");
+			printk("RetDATABuffer[0]:%02x,RetDATABuffer[1]:%02x,CFG[Length-2]:%02x,CFG[Length-1]:%02x\n",
+				RetDATABuffer[0], RetDATABuffer[1],
+				arucConfig[unConfigLength - 2],
+				arucConfig[unConfigLength - 1]);
+			return false;//config CRC Check Error
+		}
+	}
+
+	//write signature
+	DATABuffer[0] = 0x59;
+	DATABuffer[1] = 0x72;
+
+	gfnIT7259_DirectEraseFlash(ts_data, 0xD7,(dwFlashSize -1024));
+	gfnIT7259_DirectWriteFlash(ts_data, (dwFlashSize -1024),2,DATABuffer);
+
+	DATABuffer[0] = 0x00;
+	DATABuffer[1] = 0x00;
+	i2cDirectReadFromIT7259(ts_data,dwAddress,DATABuffer,2);
+
+	//trun on CPU data clock
+	//printk("###012 trun on CPU data clock\n");    
+	if(!gfnIT7259_SwitchCPUClock(ts_data, 0x04))
+	{
+		printk("###012 trun on CPU data clock fail\n");
+		return false;
+	}
+
+	printk("###gfnIT7259_FirmwareDownload() end.\n");
+
+	return true;
+}
+
+
+static int Upgrade_FW_CFG(struct it7259_ts_data *ts_data)
+{
+	unsigned int fw_size = 0;
+	unsigned int config_size = 0;
+
+	struct file *fw_fd = NULL;
+	struct file *config_fd = NULL;
+	mm_segment_t fs;
+
+	unsigned char *fw_buf = kzalloc(0x10000, GFP_KERNEL);
+	unsigned char *config_buf = kzalloc(0x500, GFP_KERNEL);
+
+	printk("Execute Upgrade_FW_CFG()\n");
+	if ( fw_buf  == NULL || config_buf == NULL  ) {
+		printk("kzalloc failed\n");
+	}
+
+	fs = get_fs();
+	set_fs(get_ds());
+	//load fw file
+	fw_fd = filp_open(IT7259_FW_PATH, O_RDONLY, 0);
+
+	if (fw_fd < 0){
+		printk("open %s failed \n", IT7259_FW_PATH);
+		return 1;
+	}
+
+	fw_size = fw_fd->f_op->read(fw_fd, fw_buf, 0x10000, &fw_fd->f_pos);
+	printk("File Firmware version : %02x %02x %02x %02x\n",
+		fw_buf[136], fw_buf[137], fw_buf[138], fw_buf[139]);
+	//printk("--------------------- fw_size = %x\n", fw_size);
+
+	//load config file
+	config_fd = filp_open(IT7259_CFG_PATH, O_RDONLY, 0);
+
+	if(config_fd < 0){
+		printk("open %s failed \n", IT7259_CFG_PATH);
+		return 1;
+	}
+
+	config_size = config_fd->f_op->read(config_fd, config_buf, 0x500, &config_fd->f_pos);
+	printk("File Config version : %02x %02x %02x %02x\n",
+		config_buf[config_size-8], config_buf[config_size-7],
+		config_buf[config_size-6], config_buf[config_size-5]);
+
+	set_fs(fs);
+	filp_close(fw_fd,NULL);
+	filp_close(config_fd,NULL);
+
+	printk("Chip firmware version : %02x %02x %02x %02x\n",
+		ts_data->fw_ver[0], ts_data->fw_ver[1],
+		ts_data->fw_ver[2], ts_data->fw_ver[3]);
+	printk("Chip config version : %02x %02x %02x %02x\n",
+		ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+		ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
+	download = 0;
+	if ((ts_data->cfg_ver[0] != config_buf[config_size-8]) ||
+		(ts_data->cfg_ver[1] != config_buf[config_size-7]) ||
+		(ts_data->cfg_ver[2] != config_buf[config_size-6])
+			|| (ts_data->cfg_ver[3] != config_buf[config_size-5]))
+		download += 1;
+
+	if ((ts_data->fw_ver[0] != fw_buf[136]) ||
+		(ts_data->fw_ver[1] != fw_buf[137]) ||
+		(ts_data->fw_ver[2] != fw_buf[138]) ||
+		(ts_data->fw_ver[3] != fw_buf[139]))
+		download += 2;
+
+	printk("%s, print download = %d\n", __func__, download);
+
+	if(download == 0){
+		printk("Do not need to upgrade\n");
+		return 0;
+	} else {
+		if (gfnIT7259_FirmwareDownload(ts_data, fw_size, fw_buf, config_size, config_buf) == false) {
+			//fail          
+			return 1;
+		}else{
+			//success               
+			return 0;
+		}
+	}
+}
+
+
+static ssize_t sysfs_point_show(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+        struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+        uint8_t pt_data[sizeof(struct point_data)];
+        int readSuccess;
+        ssize_t ret;
+
+        readSuccess = it7259_i2c_read_no_ready_check(ts_data, BUF_POINT_INFO,
+                                        pt_data, sizeof(pt_data));
+
+        if (readSuccess == IT_I2C_READ_RET) {
+                ret = scnprintf(buf, MAX_BUFFER_SIZE,
+                        "point_show read ret[%d]--point[%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x][%x]\n",
+                        readSuccess, pt_data[0], pt_data[1],
+                        pt_data[2], pt_data[3], pt_data[4],
+                        pt_data[5], pt_data[6], pt_data[7],
+                        pt_data[8], pt_data[9], pt_data[10],
+                        pt_data[11], pt_data[12], pt_data[13]);
+        } else {
+                 ret = scnprintf(buf, MAX_BUFFER_SIZE,
+                        "failed to read point data\n");
+        }
+        dev_dbg(dev, "%s", buf);
+
+        return ret;
+}
+
+
+static ssize_t sysfs_upgrade_store(struct device *dev,
+                struct device_attribute *attr, const char *buf, size_t count)
+{
+        struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+
+        printk("%s():\n", __func__);
+        if (ts_data->suspended) {
+                dev_err(dev, "Device is suspended, can't upgrade FW/CFG !!!\n");
+                return -EBUSY;
+        }
+
+        mutex_lock(&ts_data->fw_cfg_mutex);
+        if(Upgrade_FW_CFG(ts_data)) {
+                printk("IT7259_upgrade_failed\n");
+                return -1;
+
+        } else {
+                printk("IT7259_upgrade_OK\n\n");
+                return 0;
+        }
+        mutex_unlock(&ts_data->fw_cfg_mutex);
+
+        return count;
+}
+
+static ssize_t sysfs_upgrade_show(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+        struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+
+        return scnprintf(buf, MAX_BUFFER_SIZE, "%d\n",
+                                ts_data->cfg_upgrade_result);
+}
+
+static ssize_t sysfs_GetCSEL_show(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	static const u8 Current_Mode[] = {0x1A, 0x05, 0x00};
+	static const u8 Ground_Mode[] = {0x1A, 0x05, 0x01};
+	static const u8 Shielding_Mode[] = {0x1A, 0x05, 0x02};
+	u8 Current_CSEL[56] = {0,};
+	u8 Ground_CSEL[56] = {0,};
+	u8 Shielding_CSEL[56] = {0,};
+	int ret;
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, Current_Mode,
+			sizeof(Current_Mode));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev, "failed to write CMD_IDENT_CHIP\n");
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to write CMD_IDENT_CHIP\n");
+	}
+
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, Current_CSEL,
+			sizeof(Current_CSEL));
+	if (ret != IT_I2C_READ_RET) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip-id\n");
+	}
+
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"it7259 Current_CSEL : 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n ===========================================================================\n",
+			Current_CSEL[0],Current_CSEL[1],Current_CSEL[2],Current_CSEL[3],Current_CSEL[4],Current_CSEL[5],Current_CSEL[6],Current_CSEL[7],
+			Current_CSEL[8],Current_CSEL[9],Current_CSEL[10],Current_CSEL[11],Current_CSEL[12],Current_CSEL[13],Current_CSEL[14],Current_CSEL[15],
+			Current_CSEL[16],Current_CSEL[17],Current_CSEL[18],Current_CSEL[19],Current_CSEL[20],Current_CSEL[21],Current_CSEL[22],Current_CSEL[23],
+			Current_CSEL[24],Current_CSEL[25],Current_CSEL[26],Current_CSEL[27],Current_CSEL[28],Current_CSEL[29],Current_CSEL[30],Current_CSEL[31],
+			Current_CSEL[32],Current_CSEL[33],Current_CSEL[34],Current_CSEL[35],Current_CSEL[36],Current_CSEL[37],Current_CSEL[38],Current_CSEL[39],
+			Current_CSEL[40],Current_CSEL[41],Current_CSEL[42],Current_CSEL[43],Current_CSEL[44],Current_CSEL[45],Current_CSEL[46],Current_CSEL[47],
+			Current_CSEL[48],Current_CSEL[49],Current_CSEL[50],Current_CSEL[51],Current_CSEL[52],Current_CSEL[53],Current_CSEL[54],Current_CSEL[55]);
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, Ground_Mode,
+			sizeof(Ground_Mode));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,"failed to write CMD_IDENT_CHIP\n");
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to write CMD_IDENT_CHIP\n");
+	}
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, Ground_CSEL,
+			sizeof(Ground_CSEL));
+	if (ret != IT_I2C_READ_RET) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip-id\n");
+	}
+
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"it7259 Ground_CSEL  : 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n  ===========================================================================\n",
+			Ground_CSEL[0],Ground_CSEL[1],Ground_CSEL[2],Ground_CSEL[3],Ground_CSEL[4],Ground_CSEL[5],Ground_CSEL[6],Ground_CSEL[7],
+			Ground_CSEL[8],Ground_CSEL[9],Ground_CSEL[10],Ground_CSEL[11],Ground_CSEL[12],Ground_CSEL[13],Ground_CSEL[14],Ground_CSEL[15],
+			Ground_CSEL[16],Ground_CSEL[17],Ground_CSEL[18],Ground_CSEL[19],Ground_CSEL[20],Ground_CSEL[21],Ground_CSEL[22],Ground_CSEL[23],
+			Ground_CSEL[24],Ground_CSEL[25],Ground_CSEL[26],Ground_CSEL[27],Ground_CSEL[28],Ground_CSEL[29],Ground_CSEL[30],Ground_CSEL[31],
+			Ground_CSEL[32],Ground_CSEL[33],Ground_CSEL[34],Ground_CSEL[35],Ground_CSEL[36],Ground_CSEL[37],Ground_CSEL[38],Ground_CSEL[39],
+			Ground_CSEL[40],Ground_CSEL[41],Ground_CSEL[42],Ground_CSEL[43],Ground_CSEL[44],Ground_CSEL[45],Ground_CSEL[46],Ground_CSEL[47],
+			Ground_CSEL[48],Ground_CSEL[49],Ground_CSEL[50],Ground_CSEL[51],Ground_CSEL[52],Ground_CSEL[53],Ground_CSEL[54],Ground_CSEL[55]);
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, Shielding_Mode,
+			sizeof(Shielding_Mode));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev, "failed to write CMD_IDENT_CHIP\n");
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to write CMD_IDENT_CHIP\n");
+	}
+
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, Shielding_CSEL,
+			sizeof(Shielding_CSEL));
+	if (ret != IT_I2C_READ_RET) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip-id\n");
+	}
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"it7259 Shielding_CSEL  : 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n ===========================================================================\n",
+			Shielding_CSEL[0],Shielding_CSEL[1],Shielding_CSEL[2],Shielding_CSEL[3],Shielding_CSEL[4],Shielding_CSEL[5],Shielding_CSEL[6],Shielding_CSEL[7],
+			Shielding_CSEL[8],Shielding_CSEL[9],Shielding_CSEL[10],Shielding_CSEL[11],Shielding_CSEL[12],Shielding_CSEL[13],Shielding_CSEL[14],Shielding_CSEL[15],
+			Shielding_CSEL[16],Shielding_CSEL[17],Shielding_CSEL[18],Shielding_CSEL[19],Shielding_CSEL[20],Shielding_CSEL[21],Shielding_CSEL[22],Shielding_CSEL[23],
+			Shielding_CSEL[24],Shielding_CSEL[25],Shielding_CSEL[26],Shielding_CSEL[27],Shielding_CSEL[28],Shielding_CSEL[29],Shielding_CSEL[30],Shielding_CSEL[31],
+			Shielding_CSEL[32],Shielding_CSEL[33],Shielding_CSEL[34],Shielding_CSEL[35],Shielding_CSEL[36],Shielding_CSEL[37],Shielding_CSEL[38],Shielding_CSEL[39],
+			Shielding_CSEL[40],Shielding_CSEL[41],Shielding_CSEL[42],Shielding_CSEL[43],Shielding_CSEL[44],Shielding_CSEL[45],Shielding_CSEL[46],Shielding_CSEL[47],
+			Shielding_CSEL[48],Shielding_CSEL[49],Shielding_CSEL[50],Shielding_CSEL[51],Shielding_CSEL[52],Shielding_CSEL[53],Shielding_CSEL[54],Shielding_CSEL[55]);
+
+}
+
+static ssize_t sysfs_readstage_show(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	static const u8 read_stage[] = {0x1A, 0x00, 0x01, 0x05};
+	u8 stage_CDC[10] = {0,};
+	int ret;
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, read_stage,
+			sizeof(read_stage));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev, "failed to write CMD_IDENT_CHIP\n");
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to write CMD_IDENT_CHIP\n");
+	}
+
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, stage_CDC,
+			sizeof(stage_CDC));
+	if (ret != IT_I2C_READ_RET) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip-id\n");
+	}
+
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"it7259 stage CDC : 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X, 0x%X\n",
+			stage_CDC[0], stage_CDC[1], stage_CDC[2], stage_CDC[3], stage_CDC[4],
+			stage_CDC[5], stage_CDC[6], stage_CDC[7], stage_CDC[8], stage_CDC[9]);
+
+}
+
+
+static ssize_t sysfs_chipID_show(struct device *dev,
+                                struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	static const uint8_t cmd_ident[] = {CMD_IDENT_CHIP};
+	uint8_t chip_id[10] = {0,};
+	int ret;
+
+	ret = it7259_wait_device_ready(ts_data, false, true);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, cmd_ident,
+			sizeof(cmd_ident));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev, "failed to write CMD_IDENT_CHIP\n");
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to write CMD_IDENT_CHIP\n");
+	}
+
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip status\n");
+	}
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, chip_id,
+			sizeof(chip_id));
+	if (ret != IT_I2C_READ_RET) {
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+				"failed to read chip-id\n");
+	}
+
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"it7259_ts_chip_identify read id: %02X %c%c%c%c%c%c%c %c%c\n",
+			chip_id[0], chip_id[1], chip_id[2], chip_id[3], chip_id[4],
+			chip_id[5], chip_id[6], chip_id[7], chip_id[8], chip_id[9]);
+}
+
+static ssize_t sysfs_version_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+
+	return scnprintf(buf, MAX_BUFFER_SIZE,
+			"fw{%X.%X.%X.%X} cfg{%X.%X.%X.%X}\n",
+			ts_data->fw_ver[0], ts_data->fw_ver[1],
+			ts_data->fw_ver[2], ts_data->fw_ver[3],
+			ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+			ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
+}
+
+static ssize_t sysfs_cfg_name_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	char *strptr;
+
+	if (count >= MAX_BUFFER_SIZE) {
+		dev_err(dev, "Input over %d chars long\n", MAX_BUFFER_SIZE);
+		return -EINVAL;
+	}
+
+	strptr = strnstr(buf, ".bin", count);
+	if (!strptr) {
+		dev_err(dev, "Input is invalid cfg file\n");
+		return -EINVAL;
+	}
+
+	strlcpy(ts_data->cfg_name, buf, count);
+
+	return count;
+}
+
+static ssize_t sysfs_cfg_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+
+	if (strnlen(ts_data->cfg_name, MAX_BUFFER_SIZE) > 0)
+		return scnprintf(buf, MAX_BUFFER_SIZE, "%s\n",
+				ts_data->cfg_name);
+	else
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+			"No config file name given\n");
+}
+
+static ssize_t sysfs_fw_name_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	char *strptr;
+
+	if (count >= MAX_BUFFER_SIZE) {
+		dev_err(dev, "Input over %d chars long\n", MAX_BUFFER_SIZE);
+		return -EINVAL;
+	}
+
+	strptr = strnstr(buf, ".bin", count);
+	if (!strptr) {
+		dev_err(dev, "Input is invalid fw file\n");
+		return -EINVAL;
+	}
+
+	strlcpy(ts_data->fw_name, buf, count);
+	return count;
+}
+
+static ssize_t sysfs_fw_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+
+	if (strnlen(ts_data->fw_name, MAX_BUFFER_SIZE) > 0)
+		return scnprintf(buf, MAX_BUFFER_SIZE, "%s\n",
+			ts_data->fw_name);
+	else
+		return scnprintf(buf, MAX_BUFFER_SIZE,
+			"No firmware file name given\n");
+}
+
+static DEVICE_ATTR(version, S_IRUGO | S_IWUSR,
+		sysfs_version_show, NULL);
+static DEVICE_ATTR(chipID, S_IRUGO | S_IWUSR,
+                        sysfs_chipID_show, NULL);
+static DEVICE_ATTR(readstage, S_IRUGO | S_IWUSR,
+                        sysfs_readstage_show, NULL);
+static DEVICE_ATTR(GetCSEL, S_IRUGO | S_IWUSR,
+                        sysfs_GetCSEL_show, NULL);
+static DEVICE_ATTR(upgrade, S_IRUGO | S_IWUSR,
+                        sysfs_upgrade_show, sysfs_upgrade_store);
+static DEVICE_ATTR(point, S_IRUGO | S_IWUSR,
+                        sysfs_point_show, NULL);
+static DEVICE_ATTR(fw_name, S_IRUGO | S_IWUSR,
+                        sysfs_fw_name_show, sysfs_fw_name_store);
+static DEVICE_ATTR(cfg_name, S_IRUGO | S_IWUSR,
+                        sysfs_cfg_name_show, sysfs_cfg_name_store);
+
+static struct attribute *it7259_attributes[] = {
+        &dev_attr_version.attr,
+        &dev_attr_upgrade.attr,
+        &dev_attr_point.attr,
+        &dev_attr_fw_name.attr,
+        &dev_attr_cfg_name.attr,
+        &dev_attr_chipID.attr,
+        &dev_attr_readstage.attr,
+        &dev_attr_GetCSEL.attr,
+                NULL
+};
+
+static const struct attribute_group it7259_attr_group = {
+	.attrs = it7259_attributes,
+};
+
+static void it7259_ts_release_all(struct it7259_ts_data *ts_data)
+{
+	int finger;
+
+	for (finger = 0; finger < ts_data->pdata->num_of_fingers; finger++) {
+		input_mt_slot(ts_data->input_dev, finger);
+		input_mt_report_slot_state(ts_data->input_dev,
+				MT_TOOL_FINGER, 0);
+	}
+
+	input_report_key(ts_data->input_dev, BTN_TOUCH, 0);
+	input_sync(ts_data->input_dev);
+}
+
+static irqreturn_t it7259_ts_threaded_handler(int irq, void *devid)
+{
+	struct point_data pt_data;
+	struct it7259_ts_data *ts_data = devid;
+	struct input_dev *input_dev = ts_data->input_dev;
+	u8 dev_status, finger, touch_count = 0, finger_status;
+	u8 pressure = FD_PRESSURE_NONE;
+	u16 x, y;
+	bool palm_detected;
+	int ret;
+
+	/* verify there is point data to read & it is readable and valid */
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_QUERY, &dev_status,
+						sizeof(dev_status));
+	if (ret == IT_I2C_READ_RET)
+		if (!((dev_status & PT_INFO_BITS) & PT_INFO_YES))
+			return IRQ_HANDLED;
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_POINT_INFO,
+				(void *)&pt_data, sizeof(pt_data));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read point data buffer\n");
+		return IRQ_HANDLED;
+	}
+
+	/* Check if controller moves from idle to active state */
+	if ((pt_data.flags & PD_FLAGS_DATA_TYPE_BITS) !=
+					PD_FLAGS_DATA_TYPE_TOUCH) {
+		/*
+		 * This code adds the touch-to-wake functionality to the ITE
+		 * tech driver. When user puts a finger on touch controller in
+		 * idle state, the controller moves to active state and driver
+		 * sends the KEY_WAKEUP event to wake the device. The
+		 * pm_stay_awake() call tells the pm core to stay awake until
+		 * the CPU cores are up already. The schedule_work() call
+		 * schedule a work that tells the pm core to relax once the CPU
+		 * cores are up.
+		 */
+		if ((pt_data.flags & PD_FLAGS_DATA_TYPE_BITS) ==
+				PD_FLAGS_IDLE_TO_ACTIVE &&
+				pt_data.gesture_id == 0) {
+			pm_stay_awake(&ts_data->client->dev);
+			input_report_key(input_dev, KEY_WAKEUP, 1);
+			input_sync(input_dev);
+			input_report_key(input_dev, KEY_WAKEUP, 0);
+			input_sync(input_dev);
+			schedule_work(&ts_data->work_pm_relax);
+		} else {
+			dev_dbg(&ts_data->client->dev,
+				"Ignore the touch data\n");
+		}
+		return IRQ_HANDLED;
+	}
+
+	/*
+	 * Check if touch data also includes any palm gesture or not.
+	 * If palm gesture is detected, then send the keycode parsed
+	 * from the DT.
+	 */
+	palm_detected = pt_data.gesture_id & PD_PALM_FLAG_BIT;
+	if (palm_detected && ts_data->pdata->palm_detect_en) {
+		input_report_key(input_dev,
+				ts_data->pdata->palm_detect_keycode, 1);
+		input_sync(input_dev);
+		input_report_key(input_dev,
+				ts_data->pdata->palm_detect_keycode, 0);
+		input_sync(input_dev);
+	}
+
+	for (finger = 0; finger < ts_data->pdata->num_of_fingers; finger++) {
+		finger_status = pt_data.flags & (0x01 << finger);
+
+		input_mt_slot(input_dev, finger);
+		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER,
+					finger_status != 0);
+
+		x = pt_data.fd[finger].xLo +
+			(((u16)(pt_data.fd[finger].hi & 0x0F)) << 8);
+		y = pt_data.fd[finger].yLo +
+			(((u16)(pt_data.fd[finger].hi & 0xF0)) << 4);
+
+		pressure = pt_data.fd[finger].pressure & FD_PRESSURE_BITS;
+
+		if (finger_status) {
+			if (pressure >= FD_PRESSURE_LIGHT) {
+				input_report_key(input_dev, BTN_TOUCH, 1);
+				input_report_abs(input_dev,
+							ABS_MT_POSITION_X, x);
+				input_report_abs(input_dev,
+							ABS_MT_POSITION_Y, y);
+				touch_count++;
+			}
+		}
+	}
+
+	input_report_key(input_dev, BTN_TOUCH, touch_count > 0);
+	input_sync(input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static void it7259_ts_work_func(struct work_struct *work)
+{
+	struct it7259_ts_data *ts_data = container_of(work,
+				struct it7259_ts_data, work_pm_relax);
+
+	pm_relax(&ts_data->client->dev);
+}
+
+static int it7259_ts_chip_identify(struct it7259_ts_data *ts_data)
+{
+	static const uint8_t cmd_ident[] = {CMD_IDENT_CHIP};
+	static const uint8_t expected_id[] = {0x0A, 'I', 'T', 'E', '7',
+							'2', '5', '7', '0', '0'};
+	uint8_t chip_id[10] = {0,};
+	int ret;
+
+	/*
+	 * Sometimes, the controller may not respond immediately after
+	 * writing the command, so wait for device to get ready.
+	 * FALSE means to retry 20 times at max to read the chip status.
+	 * TRUE means to add delay in each retry.
+	 */
+	ret = it7259_wait_device_ready(ts_data, false, true);
+	if (ret < 0) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip status %d\n", ret);
+		return ret;
+	}
+
+	ret = it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, cmd_ident,
+							sizeof(cmd_ident));
+	if (ret != IT_I2C_WRITE_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to write CMD_IDENT_CHIP %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Sometimes, the controller may not respond immediately after
+	 * writing the command, so wait for device to get ready.
+	 * TRUE means to retry 500 times at max to read the chip status.
+	 * FALSE means to avoid unnecessary delays in each retry.
+	 */
+	ret = it7259_wait_device_ready(ts_data, true, false);
+	if (ret < 0) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip status %d\n", ret);
+		return ret;
+	}
+
+
+	ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, chip_id,
+							sizeof(chip_id));
+	if (ret != IT_I2C_READ_RET) {
+		dev_err(&ts_data->client->dev,
+			"failed to read chip-id %d\n", ret);
+		return ret;
+	}
+	dev_info(&ts_data->client->dev,
+		"it7259_ts_chip_identify read id: %02X %c%c%c%c%c%c%c %c%c\n",
+		chip_id[0], chip_id[1], chip_id[2], chip_id[3], chip_id[4],
+		chip_id[5], chip_id[6], chip_id[7], chip_id[8], chip_id[9]);
+
+	if (memcmp(chip_id, expected_id, sizeof(expected_id)))
+		return -EINVAL;
+
+/*	if (chip_id[8] == '5' && chip_id[9] == '6')
+		dev_info(&ts_data->client->dev, "rev BX3 found\n");
+	else if (chip_id[8] == '6' && chip_id[9] == '6')
+		dev_info(&ts_data->client->dev, "rev BX4 found\n");
+	else
+		dev_info(&ts_data->client->dev, "unknown revision (0x%02X 0x%02X) found\n",
+						chip_id[8], chip_id[9]);
+*/
+	return 0;
+}
+
+static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
+{
+	return (regulator_count_voltages(reg) > 0) ?
+		regulator_set_optimum_mode(reg, load_uA) : 0;
+}
+
+static int it7259_regulator_configure(struct it7259_ts_data *ts_data, bool on)
+{
+	int retval;
+
+	if (on == false)
+		goto hw_shutdown;
+
+	ts_data->vdd = devm_regulator_get(&ts_data->client->dev, "vdd");
+	if (IS_ERR(ts_data->vdd)) {
+		dev_err(&ts_data->client->dev,
+				"%s: Failed to get vdd regulator\n", __func__);
+		return PTR_ERR(ts_data->vdd);
+	}
+
+	if (regulator_count_voltages(ts_data->vdd) > 0) {
+		retval = regulator_set_voltage(ts_data->vdd,
+			IT_VTG_MIN_UV, IT_VTG_MAX_UV);
+		if (retval) {
+			dev_err(&ts_data->client->dev,
+				"regulator set_vtg failed retval =%d\n",
+				retval);
+			goto err_set_vtg_vdd;
+		}
+	}
+
+	ts_data->avdd = devm_regulator_get(&ts_data->client->dev, "avdd");
+	if (IS_ERR(ts_data->avdd)) {
+		dev_err(&ts_data->client->dev,
+				"%s: Failed to get i2c regulator\n", __func__);
+		retval = PTR_ERR(ts_data->avdd);
+		goto err_get_vtg_i2c;
+	}
+
+	if (regulator_count_voltages(ts_data->avdd) > 0) {
+		retval = regulator_set_voltage(ts_data->avdd,
+			IT_I2C_VTG_MIN_UV, IT_I2C_VTG_MAX_UV);
+		if (retval) {
+			dev_err(&ts_data->client->dev,
+				"reg set i2c vtg failed retval =%d\n",
+				retval);
+		goto err_set_vtg_i2c;
+		}
+	}
+
+	return 0;
+
+err_set_vtg_i2c:
+err_get_vtg_i2c:
+	if (regulator_count_voltages(ts_data->vdd) > 0)
+		regulator_set_voltage(ts_data->vdd, 0, IT_VTG_MAX_UV);
+err_set_vtg_vdd:
+	return retval;
+
+hw_shutdown:
+	if (regulator_count_voltages(ts_data->vdd) > 0)
+		regulator_set_voltage(ts_data->vdd, 0, IT_VTG_MAX_UV);
+	if (regulator_count_voltages(ts_data->avdd) > 0)
+		regulator_set_voltage(ts_data->avdd, 0, IT_I2C_VTG_MAX_UV);
+	return 0;
+};
+
+static int it7259_power_on(struct it7259_ts_data *ts_data, bool on)
+{
+	int retval;
+
+	if (on == false)
+		goto power_off;
+
+	retval = reg_set_optimum_mode_check(ts_data->vdd,
+		IT_ACTIVE_LOAD_UA);
+	if (retval < 0) {
+		dev_err(&ts_data->client->dev,
+			"Regulator vdd set_opt failed rc=%d\n",
+			retval);
+		return retval;
+	}
+
+	retval = regulator_enable(ts_data->vdd);
+	if (retval) {
+		dev_err(&ts_data->client->dev,
+			"Regulator vdd enable failed rc=%d\n",
+			retval);
+		goto error_reg_en_vdd;
+	}
+
+	retval = reg_set_optimum_mode_check(ts_data->avdd,
+		IT_I2C_ACTIVE_LOAD_UA);
+	if (retval < 0) {
+		dev_err(&ts_data->client->dev,
+			"Regulator avdd set_opt failed rc=%d\n",
+			retval);
+		goto error_reg_opt_i2c;
+	}
+
+	retval = regulator_enable(ts_data->avdd);
+	if (retval) {
+		dev_err(&ts_data->client->dev,
+			"Regulator avdd enable failed rc=%d\n",
+			retval);
+		goto error_reg_en_avdd;
+	}
+
+	return 0;
+
+error_reg_en_avdd:
+	reg_set_optimum_mode_check(ts_data->avdd, 0);
+error_reg_opt_i2c:
+	regulator_disable(ts_data->vdd);
+error_reg_en_vdd:
+	reg_set_optimum_mode_check(ts_data->vdd, 0);
+	return retval;
+
+power_off:
+	reg_set_optimum_mode_check(ts_data->vdd, 0);
+	regulator_disable(ts_data->vdd);
+	reg_set_optimum_mode_check(ts_data->avdd, 0);
+	regulator_disable(ts_data->avdd);
+
+	return 0;
+}
+
+static int it7259_gpio_configure(struct it7259_ts_data *ts_data, bool on)
+{
+	int retval = 0;
+
+	if (on) {
+		if (gpio_is_valid(ts_data->pdata->irq_gpio)) {
+			/* configure touchscreen irq gpio */
+			retval = gpio_request(ts_data->pdata->irq_gpio,
+					"ite_irq_gpio");
+			if (retval) {
+				dev_err(&ts_data->client->dev,
+					"unable to request irq gpio [%d]\n",
+					retval);
+				goto err_irq_gpio_req;
+			}
+
+			retval = gpio_direction_input(ts_data->pdata->irq_gpio);
+			if (retval) {
+				dev_err(&ts_data->client->dev,
+					"unable to set direction for irq gpio [%d]\n",
+					retval);
+				goto err_irq_gpio_dir;
+			}
+		} else {
+			dev_err(&ts_data->client->dev,
+				"irq gpio not provided\n");
+				goto err_irq_gpio_req;
+		}
+
+		if (gpio_is_valid(ts_data->pdata->reset_gpio)) {
+			/* configure touchscreen reset out gpio */
+			retval = gpio_request(ts_data->pdata->reset_gpio,
+					"ite_reset_gpio");
+			if (retval) {
+				dev_err(&ts_data->client->dev,
+					"unable to request reset gpio [%d]\n",
+					retval);
+					goto err_reset_gpio_req;
+			}
+
+			retval = gpio_direction_output(
+					ts_data->pdata->reset_gpio, 1);
+			if (retval) {
+				dev_err(&ts_data->client->dev,
+					"unable to set direction for reset gpio [%d]\n",
+					retval);
+				goto err_reset_gpio_dir;
+			}
+
+			if (ts_data->pdata->low_reset)
+				gpio_set_value(ts_data->pdata->reset_gpio, 0);
+			else
+				gpio_set_value(ts_data->pdata->reset_gpio, 1);
+
+			msleep(ts_data->pdata->reset_delay);
+		} else {
+			dev_err(&ts_data->client->dev,
+				"reset gpio not provided\n");
+				goto err_reset_gpio_req;
+		}
+	} else {
+		if (gpio_is_valid(ts_data->pdata->irq_gpio))
+			gpio_free(ts_data->pdata->irq_gpio);
+		if (gpio_is_valid(ts_data->pdata->reset_gpio)) {
+			/*
+			 * This is intended to save leakage current
+			 * only. Even if the call(gpio_direction_input)
+			 * fails, only leakage current will be more but
+			 * functionality will not be affected.
+			 */
+			retval = gpio_direction_input(
+					ts_data->pdata->reset_gpio);
+			if (retval) {
+				dev_err(&ts_data->client->dev,
+					"unable to set direction for gpio reset [%d]\n",
+					retval);
+			}
+			gpio_free(ts_data->pdata->reset_gpio);
+		}
+	}
+
+	return 0;
+
+err_reset_gpio_dir:
+	if (gpio_is_valid(ts_data->pdata->reset_gpio))
+		gpio_free(ts_data->pdata->reset_gpio);
+err_reset_gpio_req:
+err_irq_gpio_dir:
+	if (gpio_is_valid(ts_data->pdata->irq_gpio))
+		gpio_free(ts_data->pdata->irq_gpio);
+err_irq_gpio_req:
+	return retval;
+}
+
+#if CONFIG_OF
+static int it7259_get_dt_coords(struct device *dev, char *name,
+				struct it7259_ts_platform_data *pdata)
+{
+	u32 coords[it7259_COORDS_ARR_SIZE];
+	struct property *prop;
+	struct device_node *np = dev->of_node;
+	int coords_size, rc;
+
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	coords_size = prop->length / sizeof(u32);
+	if (coords_size != it7259_COORDS_ARR_SIZE) {
+		dev_err(dev, "invalid %s\n", name);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32_array(np, name, coords, coords_size);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
+	}
+
+	if (strcmp(name, "ite,panel-coords") == 0) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+
+		if (pdata->panel_maxx == 0 || pdata->panel_minx > 0)
+			rc = -EINVAL;
+		else if (pdata->panel_maxy == 0 || pdata->panel_miny > 0)
+			rc = -EINVAL;
+
+		if (rc) {
+			dev_err(dev, "Invalid panel resolution %d\n", rc);
+			return rc;
+		}
+	} else if (strcmp(name, "ite,display-coords") == 0) {
+		pdata->disp_minx = coords[0];
+		pdata->disp_miny = coords[1];
+		pdata->disp_maxx = coords[2];
+		pdata->disp_maxy = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int it7259_parse_dt(struct device *dev,
+				struct it7259_ts_platform_data *pdata)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+
+	/* reset, irq gpio info */
+	pdata->reset_gpio = of_get_named_gpio_flags(np,
+			"ite,reset-gpio", 0, &pdata->reset_gpio_flags);
+	pdata->irq_gpio = of_get_named_gpio_flags(np,
+			"ite,irq-gpio", 0, &pdata->irq_gpio_flags);
+
+	rc = of_property_read_u32(np, "ite,num-fingers", &temp_val);
+	if (!rc)
+		pdata->num_of_fingers = temp_val;
+	else if (rc != -EINVAL) {
+		dev_err(dev, "Unable to read reset delay\n");
+		return rc;
+	}
+
+	pdata->wakeup = of_property_read_bool(np, "ite,wakeup");
+	pdata->palm_detect_en = of_property_read_bool(np, "ite,palm-detect-en");
+	if (pdata->palm_detect_en) {
+		rc = of_property_read_u32(np, "ite,palm-detect-keycode",
+							&temp_val);
+		if (!rc) {
+			pdata->palm_detect_keycode = temp_val;
+		} else {
+			dev_err(dev, "Unable to read palm-detect-keycode\n");
+			return rc;
+		}
+	}
+
+	rc = of_property_read_string(np, "ite,fw-name", &pdata->fw_name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw image name %d\n", rc);
+		//return rc;
+	}
+
+	rc = of_property_read_string(np, "ite,cfg-name", &pdata->cfg_name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read cfg image name %d\n", rc);
+		//return rc;
+	}
+
+	snprintf(ts_data->fw_name, MAX_BUFFER_SIZE, "%s",
+		(pdata->fw_name != NULL) ? pdata->fw_name : FW_NAME);
+	snprintf(ts_data->cfg_name, MAX_BUFFER_SIZE, "%s",
+		(pdata->cfg_name != NULL) ? pdata->cfg_name : CFG_NAME);
+
+	rc = of_property_read_u32(np, "ite,reset-delay", &temp_val);
+	if (!rc)
+		pdata->reset_delay = temp_val;
+	else if (rc != -EINVAL) {
+		dev_err(dev, "Unable to read reset delay\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "ite,avdd-lpm-cur", &temp_val);
+	if (!rc) {
+		pdata->avdd_lpm_cur = temp_val;
+	} else if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read avdd lpm current value %d\n", rc);
+		return rc;
+	}
+
+	pdata->low_reset = of_property_read_bool(np, "ite,low-reset");
+
+	rc = it7259_get_dt_coords(dev, "ite,display-coords", pdata);
+	if (rc && (rc != -EINVAL))
+		return rc;
+
+	rc = it7259_get_dt_coords(dev, "ite,panel-coords", pdata);
+	if (rc && (rc != -EINVAL))
+		return rc;
+
+	return 0;
+}
+#else
+static inline int it7259_ts_parse_dt(struct device *dev,
+				struct it7259_ts_platform_data *pdata)
+{
+	return 0;
+}
+#endif
+
+static int it7259_ts_pinctrl_init(struct it7259_ts_data *ts_data)
+{
+	int retval;
+
+	/* Get pinctrl if target uses pinctrl */
+	ts_data->ts_pinctrl = devm_pinctrl_get(&(ts_data->client->dev));
+	if (IS_ERR_OR_NULL(ts_data->ts_pinctrl)) {
+		retval = PTR_ERR(ts_data->ts_pinctrl);
+		dev_dbg(&ts_data->client->dev,
+			"Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
+	}
+
+	ts_data->pinctrl_state_active
+		= pinctrl_lookup_state(ts_data->ts_pinctrl,
+				PINCTRL_STATE_ACTIVE);
+	if (IS_ERR_OR_NULL(ts_data->pinctrl_state_active)) {
+		retval = PTR_ERR(ts_data->pinctrl_state_active);
+		dev_err(&ts_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	ts_data->pinctrl_state_suspend
+		= pinctrl_lookup_state(ts_data->ts_pinctrl,
+			PINCTRL_STATE_SUSPEND);
+	if (IS_ERR_OR_NULL(ts_data->pinctrl_state_suspend)) {
+		retval = PTR_ERR(ts_data->pinctrl_state_suspend);
+		dev_err(&ts_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	ts_data->pinctrl_state_release
+		= pinctrl_lookup_state(ts_data->ts_pinctrl,
+			PINCTRL_STATE_RELEASE);
+	if (IS_ERR_OR_NULL(ts_data->pinctrl_state_release)) {
+		retval = PTR_ERR(ts_data->pinctrl_state_release);
+		dev_dbg(&ts_data->client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_RELEASE, retval);
+	}
+
+	return 0;
+
+err_pinctrl_lookup:
+	devm_pinctrl_put(ts_data->ts_pinctrl);
+err_pinctrl_get:
+	ts_data->ts_pinctrl = NULL;
+	return retval;
+}
+
+
+
+/*
+ * this code to get versions from the chip via i2c transactions, and save
+ * them in driver data structure.
+ */
+static void it7259_get_chip_versions(struct it7259_ts_data *ts_data)
+{
+        static const u8 cmd_read_fw_ver[] = {CMD_READ_VERSIONS,
+                                                SUB_CMD_READ_FIRMWARE_VERSION};
+        static const u8 cmd_read_cfg_ver[] = {CMD_READ_VERSIONS,
+                                                SUB_CMD_READ_CONFIG_VERSION};
+        u8 ver_fw[VERSION_LENGTH], ver_cfg[VERSION_LENGTH];
+        int ret;
+
+        ret = it7259_i2c_write(ts_data, BUF_COMMAND, cmd_read_fw_ver,
+                                        sizeof(cmd_read_fw_ver));
+        if (ret == IT_I2C_WRITE_RET) {
+                /*
+                 * Sometimes, the controller may not respond immediately after
+                 * writing the command, so wait for device to get ready.
+                 */
+                ret = it7259_wait_device_ready(ts_data, true, false);
+                if (ret < 0)
+                        dev_err(&ts_data->client->dev,
+                                "failed to read chip status %d\n", ret);
+
+                ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE,
+                                        ver_fw, VERSION_LENGTH);
+                if (ret == IT_I2C_READ_RET)
+                        memcpy(ts_data->fw_ver, ver_fw + (5 * sizeof(u8)),
+                                        VER_BUFFER_SIZE * sizeof(u8));
+                else
+                        dev_err(&ts_data->client->dev,
+                                "failed to read fw-ver from chip %d\n", ret);
+        } else {
+                dev_err(&ts_data->client->dev,
+                                "failed to write fw-read command %d\n", ret);
+        }
+
+        ret = it7259_i2c_write(ts_data, BUF_COMMAND, cmd_read_cfg_ver,
+                                        sizeof(cmd_read_cfg_ver));
+        if (ret == IT_I2C_WRITE_RET) {
+                /*
+                 * Sometimes, the controller may not respond immediately after
+                 * writing the command, so wait for device to get ready.
+                 */
+                ret = it7259_wait_device_ready(ts_data, true, false);
+                if (ret < 0)
+                        dev_err(&ts_data->client->dev,
+                                "failed to read chip status %d\n", ret);
+
+                ret = it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE,
+                                        ver_cfg, VERSION_LENGTH);
+                if (ret == IT_I2C_READ_RET)
+                        memcpy(ts_data->cfg_ver, ver_cfg + (1 * sizeof(u8)),
+                                        VER_BUFFER_SIZE * sizeof(u8));
+                else
+                        dev_err(&ts_data->client->dev,
+                                "failed to read cfg-ver from chip %d\n", ret);
+        } else {
+                dev_err(&ts_data->client->dev,
+                                "failed to write cfg-read command %d\n", ret);
+        }
+
+        dev_info(&ts_data->client->dev, "Current fw{%X.%X.%X.%X} cfg{%X.%X.%X.%X}\n",
+                ts_data->fw_ver[0], ts_data->fw_ver[1], ts_data->fw_ver[2],
+                ts_data->fw_ver[3], ts_data->cfg_ver[0], ts_data->cfg_ver[1],
+                ts_data->cfg_ver[2], ts_data->cfg_ver[3]);
+}
+
+
+static int it7259_ts_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	static const uint8_t cmd_start[] = {CMD_UNKNOWN_7};
+	struct it7259_ts_data *ts_data;
+	struct it7259_ts_platform_data *pdata;
+	uint8_t rsp[2];
+	int ret = -1, err;
+	struct dentry *temp;
+
+	pr_err("%s: it725x entered\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "need I2C_FUNC_I2C\n");
+		return -ENODEV;
+	}
+
+	ts_data = devm_kzalloc(&client->dev, sizeof(*ts_data), GFP_KERNEL);
+	if (!ts_data)
+		return -ENOMEM;
+
+	ts_data->client = client;
+	i2c_set_clientdata(client, ts_data);
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		ret = it7259_parse_dt(&client->dev, pdata);
+		if (ret)
+			return ret;
+	} else {
+		pdata = client->dev.platform_data;
+	}
+
+	if (!pdata) {
+		dev_err(&client->dev, "No platform data found\n");
+		return -ENOMEM;
+	}
+
+	ts_data->pdata = pdata;
+
+	ret = it7259_regulator_configure(ts_data, true);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to configure regulators\n");
+		goto err_reg_configure;
+	}
+
+	ret = it7259_power_on(ts_data, true);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to power on\n");
+		goto err_power_device;
+	}
+
+	/*
+	 * After enabling regulators, controller needs a delay to come to
+	 * an active state.
+	 */
+	msleep(DELAY_VTG_REG_EN);
+
+	ret = it7259_ts_pinctrl_init(ts_data);
+	if (!ret && ts_data->ts_pinctrl) {
+		/*
+		 * Pinctrl handle is optional. If pinctrl handle is found
+		 * let pins to be configured in active state. If not
+		 * found continue further without error.
+		 */
+		ret = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_active);
+		if (ret < 0) {
+			dev_err(&ts_data->client->dev,
+				"failed to select pin to active state %d",
+				ret);
+		}
+	} else {
+		ret = it7259_gpio_configure(ts_data, true);
+		if (ret < 0) {
+			dev_err(&client->dev, "Failed to configure gpios\n");
+			goto err_gpio_config;
+		}
+	}
+
+	ret = it7259_ts_chip_identify(ts_data);
+	if (ret) {
+		dev_err(&client->dev, "Failed to identify chip %d!!!", ret);
+		goto err_identification_fail;
+	}
+
+	it7259_get_chip_versions(ts_data);
+
+	ts_data->input_dev = input_allocate_device();
+	if (!ts_data->input_dev) {
+		dev_err(&client->dev, "failed to allocate input device\n");
+		ret = -ENOMEM;
+		goto err_input_alloc;
+	}
+
+	/* Initialize mutex for fw and cfg upgrade */
+	mutex_init(&ts_data->fw_cfg_mutex);
+
+	ts_data->input_dev->name = DEVICE_NAME;
+	ts_data->input_dev->phys = "I2C";
+	ts_data->input_dev->id.bustype = BUS_I2C;
+	ts_data->input_dev->id.vendor = 0x0001;
+	ts_data->input_dev->id.product = 0x7259;
+	set_bit(EV_SYN, ts_data->input_dev->evbit);
+	set_bit(EV_KEY, ts_data->input_dev->evbit);
+	set_bit(EV_ABS, ts_data->input_dev->evbit);
+	set_bit(INPUT_PROP_DIRECT, ts_data->input_dev->propbit);
+	set_bit(BTN_TOUCH, ts_data->input_dev->keybit);
+	input_set_abs_params(ts_data->input_dev, ABS_MT_POSITION_X,
+		ts_data->pdata->disp_minx, ts_data->pdata->disp_maxx, 0, 0);
+	input_set_abs_params(ts_data->input_dev, ABS_MT_POSITION_Y,
+		ts_data->pdata->disp_miny, ts_data->pdata->disp_maxy, 0, 0);
+	input_mt_init_slots(ts_data->input_dev,
+					ts_data->pdata->num_of_fingers, 0);
+
+	input_set_drvdata(ts_data->input_dev, ts_data);
+
+	if (pdata->wakeup) {
+		set_bit(KEY_WAKEUP, ts_data->input_dev->keybit);
+		INIT_WORK(&ts_data->work_pm_relax, it7259_ts_work_func);
+		device_init_wakeup(&client->dev, pdata->wakeup);
+	}
+
+	if (pdata->palm_detect_en)
+		set_bit(ts_data->pdata->palm_detect_keycode,
+					ts_data->input_dev->keybit);
+
+	if (input_register_device(ts_data->input_dev)) {
+		dev_err(&client->dev, "failed to register input device\n");
+		goto err_input_register;
+	}
+
+	if (request_threaded_irq(client->irq, NULL, it7259_ts_threaded_handler,
+		IRQF_TRIGGER_LOW | IRQF_ONESHOT, client->name, ts_data)) {
+		dev_err(&client->dev, "request_irq failed\n");
+		goto err_irq_reg;
+	}
+
+	if (sysfs_create_group(&(client->dev.kobj), &it7259_attr_group)) {
+		dev_err(&client->dev, "failed to register sysfs #2\n");
+		goto err_sysfs_grp_create;
+	}
+
+#if defined(CONFIG_FB)
+	ts_data->fb_notif.notifier_call = fb_notifier_callback;
+
+	ret = fb_register_client(&ts_data->fb_notif);
+	if (ret)
+		dev_err(&client->dev, "Unable to register fb_notifier %d\n",
+					ret);
+#endif
+	
+	it7259_i2c_write_no_ready_check(ts_data, BUF_COMMAND, cmd_start,
+							sizeof(cmd_start));
+	msleep(pdata->reset_delay);
+	it7259_i2c_read_no_ready_check(ts_data, BUF_RESPONSE, rsp, sizeof(rsp));
+	msleep(pdata->reset_delay);
+
+	ts_data->dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);
+	if (ts_data->dir == NULL || IS_ERR(ts_data->dir)) {
+		dev_err(&client->dev,
+			"%s: Failed to create debugfs directory, ret = %ld\n",
+			__func__, PTR_ERR(ts_data->dir));
+		ret = PTR_ERR(ts_data->dir);
+		goto err_create_debugfs_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, ts_data->dir,
+					ts_data, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		dev_err(&client->dev,
+			"%s: Failed to create suspend debugfs file, ret = %ld\n",
+			__func__, PTR_ERR(temp));
+		ret = PTR_ERR(temp);
+		goto err_create_debugfs_file;
+	}
+
+	pr_err("%s: it725x success\n", __func__);
+
+	return 0;
+
+err_create_debugfs_file:
+	debugfs_remove_recursive(ts_data->dir);
+err_create_debugfs_dir:
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&ts_data->fb_notif))
+		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
+#endif
+	sysfs_remove_group(&(client->dev.kobj), &it7259_attr_group);
+
+err_sysfs_grp_create:
+	free_irq(client->irq, ts_data);
+
+err_irq_reg:
+	input_unregister_device(ts_data->input_dev);
+
+err_input_register:
+	if (pdata->wakeup) {
+		cancel_work_sync(&ts_data->work_pm_relax);
+		device_init_wakeup(&client->dev, false);
+	}
+	if (ts_data->input_dev)
+		input_free_device(ts_data->input_dev);
+	ts_data->input_dev = NULL;
+
+err_input_alloc:
+err_identification_fail:
+	if (ts_data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(ts_data->pinctrl_state_release)) {
+			devm_pinctrl_put(ts_data->ts_pinctrl);
+			ts_data->ts_pinctrl = NULL;
+		} else {
+			err = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_release);
+			if (err)
+				dev_err(&ts_data->client->dev,
+					"failed to select relase pinctrl state %d\n",
+					err);
+		}
+	} else {
+		if (gpio_is_valid(pdata->reset_gpio))
+			gpio_free(pdata->reset_gpio);
+		if (gpio_is_valid(pdata->irq_gpio))
+			gpio_free(pdata->irq_gpio);
+	}
+
+err_gpio_config:
+	it7259_power_on(ts_data, false);
+
+err_power_device:
+	it7259_regulator_configure(ts_data, false);
+
+err_reg_configure:
+	return ret;
+}
+
+static int it7259_ts_remove(struct i2c_client *client)
+{
+	struct it7259_ts_data *ts_data = i2c_get_clientdata(client);
+	int ret;
+
+	debugfs_remove_recursive(ts_data->dir);
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&ts_data->fb_notif))
+		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
+#endif
+	sysfs_remove_group(&(client->dev.kobj), &it7259_attr_group);
+	free_irq(client->irq, ts_data);
+	input_unregister_device(ts_data->input_dev);
+	if (ts_data->input_dev)
+		input_free_device(ts_data->input_dev);
+	ts_data->input_dev = NULL;
+	if (ts_data->pdata->wakeup) {
+		cancel_work_sync(&ts_data->work_pm_relax);
+		device_init_wakeup(&client->dev, false);
+	}
+	if (ts_data->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(ts_data->pinctrl_state_release)) {
+			devm_pinctrl_put(ts_data->ts_pinctrl);
+			ts_data->ts_pinctrl = NULL;
+		} else {
+			ret = pinctrl_select_state(ts_data->ts_pinctrl,
+					ts_data->pinctrl_state_release);
+			if (ret)
+				dev_err(&ts_data->client->dev,
+					"failed to select relase pinctrl state %d\n",
+					ret);
+		}
+	} else {
+		if (gpio_is_valid(ts_data->pdata->reset_gpio))
+			gpio_free(ts_data->pdata->reset_gpio);
+		if (gpio_is_valid(ts_data->pdata->irq_gpio))
+			gpio_free(ts_data->pdata->irq_gpio);
+	}
+	it7259_power_on(ts_data, false);
+	it7259_regulator_configure(ts_data, false);
+
+	return 0;
+}
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+			unsigned long event, void *data)
+{
+	struct it7259_ts_data *ts_data = container_of(self,
+					struct it7259_ts_data, fb_notif);
+	struct fb_event *evdata = data;
+	int *blank;
+
+	if (evdata && evdata->data && ts_data && ts_data->client) {
+		if (event == FB_EVENT_BLANK) {
+			blank = evdata->data;
+			if (*blank == FB_BLANK_UNBLANK)
+				it7259_ts_resume(&(ts_data->client->dev));
+			else if (*blank == FB_BLANK_POWERDOWN ||
+					*blank == FB_BLANK_VSYNC_SUSPEND)
+				it7259_ts_suspend(&(ts_data->client->dev));
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int it7259_ts_resume(struct device *dev)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	int retval;
+
+	if (device_may_wakeup(dev)) {
+		if (ts_data->in_low_power_mode) {
+			/* Set active current for the avdd regulator */
+			if (ts_data->pdata->avdd_lpm_cur) {
+				retval = reg_set_optimum_mode_check(
+						ts_data->avdd,
+						IT_I2C_ACTIVE_LOAD_UA);
+				if (retval < 0)
+					dev_err(dev, "Regulator avdd set_opt failed at resume rc=%d\n",
+					retval);
+			}
+
+			ts_data->in_low_power_mode = false;
+			disable_irq_wake(ts_data->client->irq);
+		}
+		return 0;
+	}
+
+	if (ts_data->ts_pinctrl) {
+		retval = pinctrl_select_state(ts_data->ts_pinctrl,
+				ts_data->pinctrl_state_active);
+		if (retval < 0) {
+			dev_err(dev, "Cannot get default pinctrl state %d\n",
+				retval);
+			goto err_pinctrl_select_suspend;
+		}
+	}
+
+	enable_irq(ts_data->client->irq);
+	ts_data->suspended = false;
+	return 0;
+
+err_pinctrl_select_suspend:
+	return retval;
+}
+
+static int it7259_ts_suspend(struct device *dev)
+{
+	struct it7259_ts_data *ts_data = dev_get_drvdata(dev);
+	int retval;
+
+	if (ts_data->fw_cfg_uploading) {
+		dev_dbg(dev, "Fw/cfg uploading. Can't go to suspend.\n");
+		return -EBUSY;
+	}
+
+	if (device_may_wakeup(dev)) {
+		if (!ts_data->in_low_power_mode) {
+			/* put the device in low power idle mode */
+			retval = it7259_ts_chip_low_power_mode(ts_data,
+						PWR_CTL_LOW_POWER_MODE);
+			if (retval)
+				dev_err(dev, "Can't go to low power mode %d\n",
+						retval);
+
+			/* Set lpm current for avdd regulator */
+			if (ts_data->pdata->avdd_lpm_cur) {
+				retval = reg_set_optimum_mode_check(
+						ts_data->avdd,
+						ts_data->pdata->avdd_lpm_cur);
+				if (retval < 0)
+					dev_err(dev, "Regulator avdd set_opt failed at suspend rc=%d\n",
+						retval);
+			}
+
+			ts_data->in_low_power_mode = true;
+			enable_irq_wake(ts_data->client->irq);
+		}
+		return 0;
+	}
+
+	disable_irq(ts_data->client->irq);
+
+	it7259_ts_release_all(ts_data);
+
+	if (ts_data->ts_pinctrl) {
+		retval = pinctrl_select_state(ts_data->ts_pinctrl,
+				ts_data->pinctrl_state_suspend);
+		if (retval < 0) {
+			dev_err(dev, "Cannot get idle pinctrl state %d\n",
+				retval);
+			goto err_pinctrl_select_suspend;
+		}
+	}
+
+	ts_data->suspended = true;
+
+	return 0;
+
+err_pinctrl_select_suspend:
+	return retval;
+}
+
+static const struct dev_pm_ops it7259_ts_dev_pm_ops = {
+	.suspend = it7259_ts_suspend,
+	.resume  = it7259_ts_resume,
+};
+#else
+static int it7259_ts_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int it7259_ts_suspend(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static const struct i2c_device_id it7259_ts_id[] = {
+	{ DEVICE_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, it7259_ts_id);
+
+static const struct of_device_id it7259_match_table[] = {
+	{ .compatible = "ite,it7259_ts",},
+	{},
+};
+
+static struct i2c_driver it7259_ts_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+		.of_match_table = it7259_match_table,
+#ifdef CONFIG_PM
+		.pm = &it7259_ts_dev_pm_ops,
+#endif
+	},
+	.probe = it7259_ts_probe,
+	.remove = it7259_ts_remove,
+	.id_table = it7259_ts_id,
+};
+
+static int __init  it7259_ts_driver_init(void)
+{    
+	pr_err("%s", __func__);
+	return i2c_add_driver(&it7259_ts_driver);
+}
+module_init(it7259_ts_driver_init);
+
+static void __exit it7259_ts_driver_exit(void)
+{    
+	return i2c_del_driver(&it7259_ts_driver);
+}
+module_exit(it7259_ts_driver_exit);
+
+MODULE_DESCRIPTION("it7259 Touchscreen Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/drivers/video/msm/mdss/Kconfig b/kernel/drivers/video/msm/mdss/Kconfig
index b75f362..c4b3fef 100644
--- a/kernel/drivers/video/msm/mdss/Kconfig
+++ b/kernel/drivers/video/msm/mdss/Kconfig
@@ -11,6 +11,16 @@ config FB_MSM_MDSS_HDMI_PANEL
 	---help---
 	The MDSS HDMI Panel provides support for transmitting TMDS signals of
 	MDSS frame buffer data to connected hdmi compliant TVs, monitors etc.
+	
+config FB_MSM_MDSS_SPI_PANEL
+	depends on FB_MSM_MDSS
+	bool "Support SPI panel feature"
+	default n
+	---help---
+	The MDSS SPI Panel provides support for transmitting SPI signals of
+	MDSS frame buffer data to connected panel. Limited by SPI rate, the
+	current max fps only reach to 27fps, and limited by MDP hardware
+	architecture only supply on MDP3.
 
 config FB_MSM_MDSS_HDMI_MHL_SII8334
 	depends on FB_MSM_MDSS_HDMI_PANEL
diff --git a/kernel/drivers/video/msm/mdss/Makefile b/kernel/drivers/video/msm/mdss/Makefile
index a5f4473..25f8525 100644
--- a/kernel/drivers/video/msm/mdss/Makefile
+++ b/kernel/drivers/video/msm/mdss/Makefile
@@ -34,6 +34,12 @@ obj-$(CONFIG_FB_MSM_MDSS) += adv7533_dsi2hdmi.o
 obj-$(CONFIG_FB_MSM_MDSS_EDP_PANEL) += mdss_edp.o
 obj-$(CONFIG_FB_MSM_MDSS_EDP_PANEL) += mdss_edp_aux.o
 
+ifeq ($(CONFIG_SPI_QUP),y)
+obj-$(CONFIG_FB_MSM_MDSS_SPI_PANEL) += mdss_spi_client.o
+obj-$(CONFIG_FB_MSM_MDSS_SPI_PANEL) += mdss_spi_panel.o
+endif
+
+
 obj-$(CONFIG_FB_MSM_MDSS) += mdss_io_util.o
 obj-$(CONFIG_FB_MSM_MDSS_HDMI_PANEL) += mdss_hdmi_tx.o
 obj-$(CONFIG_FB_MSM_MDSS_HDMI_PANEL) += mdss_hdmi_util.o
diff --git a/kernel/drivers/video/msm/mdss/mdp3.c b/kernel/drivers/video/msm/mdss/mdp3.c
old mode 100644
new mode 100755
index f122857..dc89e4d
--- a/kernel/drivers/video/msm/mdss/mdp3.c
+++ b/kernel/drivers/video/msm/mdss/mdp3.c
@@ -56,6 +56,7 @@
 #include "mdp3_ctrl.h"
 #include "mdp3_ppp.h"
 #include "mdss_debug.h"
+#include "mdss_spi_panel.h"
 
 #define AUTOSUSPEND_TIMEOUT_MS	100
 #define MISR_POLL_SLEEP                 2000
@@ -98,6 +99,7 @@ struct mdp3_bus_handle_map mdp3_bus_handle[MDP3_BUS_HANDLE_MAX] = {
 
 static struct mdss_panel_intf pan_types[] = {
 	{"dsi", MDSS_PANEL_INTF_DSI},
+	{"spi", MDSS_PANEL_INTF_SPI},
 };
 static char mdss_mdp3_panel[MDSS_MAX_PANEL_LEN];
 
@@ -180,7 +182,8 @@ void mdp3_irq_enable(int type)
 
 	pr_debug("mdp3_irq_enable type=%d\n", type);
 	spin_lock_irqsave(&mdp3_res->irq_lock, flag);
-	if (mdp3_res->irq_ref_count[type] > 0) {
+	mdp3_res->irq_ref_count[type] += 1;
+	if (mdp3_res->irq_ref_count[type] > 1) {
 		pr_debug("interrupt %d already enabled\n", type);
 		spin_unlock_irqrestore(&mdp3_res->irq_lock, flag);
 		return;
@@ -1787,6 +1790,8 @@ int mdp3_put_img(struct mdp3_img_data *data, int client)
 			pr_debug("%s DMA_P unmap Addr Start %llx End %llx\n",
 				__func__, (u64)data->addr,
 				(u64)(data->addr + data->len));
+		} else if (client == MDP3_CLINET_SPI ) {
+			ion_unmap_kernel(iclient, data->srcp_ihdl);
 		} else {
 			mdp3_unmap_iommu(iclient, data->srcp_ihdl);
 		}
@@ -1847,7 +1852,7 @@ int mdp3_get_img(struct msmfb_data *img, struct mdp3_img_data *data, int client)
 				ret = PTR_ERR(data->srcp_ihdl);
 			data->srcp_ihdl = NULL;
 			return ret;
-		}
+		} 
 		if (client == MDP3_CLIENT_DMA_P) {
 			dom = (mdp3_res->domains + MDP3_IOMMU_DOMAIN_UNSECURE)->domain_idx;
 			ret = ion_map_iommu(iclient, data->srcp_ihdl, dom,
@@ -1855,7 +1860,23 @@ int mdp3_get_img(struct msmfb_data *img, struct mdp3_img_data *data, int client)
 			pr_debug("%s DMA_P map Addr Start %llx End %llx\n",
 				__func__, (u64)data->addr,
 				(u64)(data->addr + data->len));
-		} else {
+		} else if (client == MDP3_CLINET_SPI) {
+			void *vaddr;
+			if (ion_handle_get_size(iclient, data->srcp_ihdl, len) < 0) {
+				pr_err("%s: get ion size failed\n", __func__);		
+				return -EINVAL;			
+			}			
+			vaddr = ion_map_kernel(iclient, data->srcp_ihdl);	
+			if (IS_ERR_OR_NULL(vaddr)) {				
+				pr_err("%s: ION memory mapping failed\n",__func__);
+				mdp3_put_img(data, client);	
+				return -EINVAL;			
+			}			
+			data->addr = (dma_addr_t) vaddr;			
+			data->len -= img->offset;			
+			return 0;
+		}
+		else {
 			ret = mdp3_self_map_iommu(iclient, data->srcp_ihdl,
 				SZ_4K, data->padding, start, len, 0, 0);
 		}
@@ -2200,7 +2221,10 @@ static int mdp3_is_display_on(struct mdss_panel_data *pdata)
 	if (pdata->panel_info.type == MIPI_VIDEO_PANEL) {
 		status = MDP3_REG_READ(MDP3_REG_DSI_VIDEO_EN);
 		rc = status & 0x1;
-	} else {
+	} else if (pdata->panel_info.type == SPI_PANEL) {
+		rc = is_spi_panel_continuous_splash_on(pdata);
+	}
+	else {
 		status = MDP3_REG_READ(MDP3_REG_DMA_P_CONFIG);
 		status &= 0x180000;
 		rc = (status == 0x080000);
@@ -2218,12 +2242,15 @@ static int mdp3_continuous_splash_on(struct mdss_panel_data *pdata)
 {
 	struct mdss_panel_info *panel_info = &pdata->panel_info;
 	struct mdp3_bus_handle_map *bus_handle;
+	int frame_rate = DEFAULT_FRAME_RATE;
 	u64 ab, ib;
 	u32 vtotal;
 	int rc;
 
 	pr_debug("mdp3__continuous_splash_on\n");
 
+	frame_rate = mdss_panel_get_framerate(panel_info);
+
 	mdp3_clk_set_rate(MDP3_CLK_VSYNC, MDP_VSYNC_CLK_RATE,
 			MDP3_CLIENT_DMA_P);
 
@@ -2240,9 +2267,14 @@ static int mdp3_continuous_splash_on(struct mdss_panel_data *pdata)
 		panel_info->lcdc.v_pulse_width;
 
 	ab = panel_info->xres * vtotal * 4;
-	ab *= panel_info->mipi.frame_rate;
+	ab *= frame_rate;
 	ib = ab;
-	rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, ab, ib);
+	
+	/* DMA not used on SPI interface, remove DMA bus voting  */
+	if (panel_info->type == SPI_PANEL)
+		rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, 0, 0);
+	else
+		rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, ab, ib);
 	bus_handle->restore_ab[MDP3_CLIENT_DMA_P] = ab;
 	bus_handle->restore_ib[MDP3_CLIENT_DMA_P] = ib;
 
@@ -2260,6 +2292,8 @@ static int mdp3_continuous_splash_on(struct mdss_panel_data *pdata)
 
 	if (panel_info->type == MIPI_VIDEO_PANEL)
 		mdp3_res->intf[MDP3_DMA_OUTPUT_SEL_DSI_VIDEO].active = 1;
+	else if (panel_info->type == SPI_PANEL)
+			mdp3_res->intf[MDP3_DMA_OUTPUT_SEL_SPI_CMD].active = 1;
 	else
 		mdp3_res->intf[MDP3_DMA_OUTPUT_SEL_DSI_CMD].active = 1;
 
@@ -2655,11 +2689,13 @@ static int mdp3_probe(struct platform_device *pdev)
 	.check_dsi_status = mdp3_check_dsi_ctrl_status,
 	};
 
+	
 	struct mdp3_intr_cb underrun_cb = {
 		.cb = mdp3_dma_underrun_intr_handler,
 		.data = NULL,
 	};
 
+	pr_err("%s entered\n", __func__);
 	if (!pdev->dev.of_node) {
 		pr_err("MDP driver only supports device tree probe\n");
 		return -ENOTSUPP;
diff --git a/kernel/drivers/video/msm/mdss/mdp3.h b/kernel/drivers/video/msm/mdss/mdp3.h
old mode 100644
new mode 100755
index 801f20d..493785b
--- a/kernel/drivers/video/msm/mdss/mdp3.h
+++ b/kernel/drivers/video/msm/mdss/mdp3.h
@@ -70,6 +70,7 @@ enum {
 	MDP3_CLIENT_DSI = 1,
 	MDP3_CLIENT_PPP,
 	MDP3_CLIENT_IOMMU,
+	MDP3_CLINET_SPI,
 	MDP3_CLIENT_MAX,
 };
 
diff --git a/kernel/drivers/video/msm/mdss/mdp3_ctrl.c b/kernel/drivers/video/msm/mdss/mdp3_ctrl.c
index 92fb0e3..35d19be 100755
--- a/kernel/drivers/video/msm/mdss/mdp3_ctrl.c
+++ b/kernel/drivers/video/msm/mdss/mdp3_ctrl.c
@@ -26,6 +26,8 @@
 #include "mdp3_ctrl.h"
 #include "mdp3.h"
 #include "mdp3_ppp.h"
+#include "mdss_spi_panel.h"
+
 
 #define VSYNC_EXPIRE_TICK	4
 
@@ -71,7 +73,7 @@ static void mdp3_bufq_init(struct mdp3_buffer_queue *bufq)
 	bufq->pop_idx = 0;
 }
 
-static void mdp3_bufq_deinit(struct mdp3_buffer_queue *bufq)
+static void mdp3_bufq_deinit(struct mdp3_buffer_queue *bufq, int client)
 {
 	int count = bufq->count;
 
@@ -81,7 +83,7 @@ static void mdp3_bufq_deinit(struct mdp3_buffer_queue *bufq)
 	while (count-- && (bufq->pop_idx >= 0)) {
 		struct mdp3_img_data *data = &bufq->img_data[bufq->pop_idx];
 		bufq->pop_idx = (bufq->pop_idx + 1) % MDP3_MAX_BUF_QUEUE;
-		mdp3_put_img(data, MDP3_CLIENT_DMA_P);
+		mdp3_put_img(data, client);
 	}
 	bufq->count = 0;
 	bufq->push_idx = 0;
@@ -119,6 +121,17 @@ static int mdp3_bufq_count(struct mdp3_buffer_queue *bufq)
 	return bufq->count;
 }
 
+static int mdp3_get_ion_clinet(struct msm_fb_data_type *mfd)
+{	
+	int intf_type;	
+	intf_type = mdp3_ctrl_get_intf_type(mfd);	
+	if (intf_type == MDP3_DMA_OUTPUT_SEL_SPI_CMD)		
+		return MDP3_CLINET_SPI;	
+	else		
+		return MDP3_CLIENT_DMA_P;
+}
+
+
 void mdp3_ctrl_notifier_register(struct mdp3_session_data *ses,
 	struct notifier_block *notifier)
 {
@@ -475,18 +488,31 @@ static int mdp3_ctrl_res_req_bus(struct msm_fb_data_type *mfd, int status)
 {
 	int rc = 0;
 	u32 vtotal = 0;
+	int frame_rate = DEFAULT_FRAME_RATE;
+	
 	if (status) {
 		struct mdss_panel_info *panel_info = mfd->panel_info;
 		u64 ab = 0;
 		u64 ib = 0;
+
+		frame_rate = mdss_panel_get_framerate(mfd->panel_info);
 		vtotal = panel_info->yres + panel_info->lcdc.v_back_porch +
 			panel_info->lcdc.v_front_porch +
 			panel_info->lcdc.v_pulse_width;
 		ab = panel_info->xres * vtotal * ppp_bpp(mfd->fb_imgType);
-		ab *= panel_info->mipi.frame_rate;
+		ab *= frame_rate;
 		/* ab and ib vote should be same for honest voting */
 		ib = ab;
-		rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, ab, ib);
+//		rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, ab, ib);
+		/* DMA not used on SPI interface, remove DMA bus voting  */
+		if (mdp3_ctrl_get_intf_type(mfd) ==
+						MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
+			rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P,
+							0, 0);
+		} else{
+			rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P,
+							ab, ib);
+		}
 	} else {
 		rc = mdp3_bus_scale_set_quota(MDP3_CLIENT_DMA_P, 0, 0);
 	}
@@ -529,6 +555,9 @@ static int mdp3_ctrl_get_intf_type(struct msm_fb_data_type *mfd)
 	case LCDC_PANEL:
 		type = MDP3_DMA_OUTPUT_SEL_LCDC;
 		break;
+	case SPI_PANEL:		
+		type = MDP3_DMA_OUTPUT_SEL_SPI_CMD;		
+		break;
 	default:
 		type = MDP3_DMA_OUTPUT_SEL_MAX;
 	}
@@ -588,7 +617,8 @@ static int mdp3_ctrl_intf_init(struct msm_fb_data_type *mfd,
 
 	cfg.type = mdp3_ctrl_get_intf_type(mfd);
 	if (cfg.type == MDP3_DMA_OUTPUT_SEL_DSI_VIDEO ||
-		cfg.type == MDP3_DMA_OUTPUT_SEL_LCDC) {
+		cfg.type == MDP3_DMA_OUTPUT_SEL_LCDC || 
+		cfg.type == MDP3_DMA_OUTPUT_SEL_SPI_CMD ) {
 		video->hsync_period = hsync_period;
 		video->hsync_pulse_width = h_pulse_width;
 		video->vsync_period = vsync_period;
@@ -636,7 +666,7 @@ static int mdp3_ctrl_dma_init(struct msm_fb_data_type *mfd,
 	struct fb_var_screeninfo *var;
 	struct mdp3_dma_output_config outputConfig;
 	struct mdp3_dma_source sourceConfig;
-	int frame_rate = mfd->panel_info->mipi.frame_rate;
+	int frame_rate = DEFAULT_FRAME_RATE;
 	int vbp, vfp, vspw;
 	int vtotal, vporch;
 	struct mdp3_notification dma_done_callback;
@@ -645,6 +675,8 @@ static int mdp3_ctrl_dma_init(struct msm_fb_data_type *mfd,
 
 	mdp3_session = (struct mdp3_session_data *)mfd->mdp.private1;
 
+	frame_rate = mdss_panel_get_framerate(panel_info);
+
 	vbp = panel_info->lcdc.v_back_porch;
 	vfp = panel_info->lcdc.v_front_porch;
 	vspw = panel_info->lcdc.v_pulse_width;
@@ -685,7 +717,7 @@ static int mdp3_ctrl_dma_init(struct msm_fb_data_type *mfd,
 		sourceConfig.stride = fix->line_length;
 	}
 
-	te.frame_rate = panel_info->mipi.frame_rate;
+	te.frame_rate = frame_rate;
 	te.hw_vsync_mode = panel_info->mipi.hw_vsync_mode;
 	te.tear_check_en = panel_info->te.tear_check_en;
 	te.sync_cfg_height = panel_info->te.sync_cfg_height;
@@ -858,6 +890,7 @@ end:
 static int mdp3_ctrl_off(struct msm_fb_data_type *mfd)
 {
 	int rc = 0;
+	int clinet;
 	bool intf_stopped = true;
 	struct mdp3_session_data *mdp3_session;
 	struct mdss_panel_data *panel;
@@ -981,10 +1014,11 @@ static int mdp3_ctrl_off(struct msm_fb_data_type *mfd)
 				pr_err("unable to suspend w/pm_runtime_put (%d)\n",
 					rc);
 		}
-		mdp3_bufq_deinit(&mdp3_session->bufq_out);
+		clinet = mdp3_get_ion_clinet(mfd);
+		mdp3_bufq_deinit(&mdp3_session->bufq_out, clinet);
 		if (mdp3_session->overlay.id != MSMFB_NEW_REQUEST) {
 			mdp3_session->overlay.id = MSMFB_NEW_REQUEST;
-			mdp3_bufq_deinit(&mdp3_session->bufq_in);
+			mdp3_bufq_deinit(&mdp3_session->bufq_in, clinet);
 		}
 	}
 off_error:
@@ -1121,14 +1155,16 @@ static int mdp3_overlay_unset(struct msm_fb_data_type *mfd, int ndx)
 	struct fb_info *fbi = mfd->fbi;
 	struct fb_fix_screeninfo *fix;
 	int format;
+	int clinet;
 
 	fix = &fbi->fix;
 	format = mdp3_ctrl_get_source_format(mfd->fb_imgType);
 	mutex_lock(&mdp3_session->lock);
+	clinet = mdp3_get_ion_clinet(mfd);
 
 	if (mdp3_session->overlay.id == ndx && ndx == 1) {
 		mdp3_session->overlay.id = MSMFB_NEW_REQUEST;
-		mdp3_bufq_deinit(&mdp3_session->bufq_in);
+		mdp3_bufq_deinit(&mdp3_session->bufq_in, clinet);
 	} else {
 		rc = -EINVAL;
 	}
@@ -1146,8 +1182,12 @@ static int mdp3_overlay_queue_buffer(struct msm_fb_data_type *mfd,
 	struct msmfb_data *img = &req->data;
 	struct mdp3_img_data data;
 	struct mdp3_dma *dma = mdp3_session->dma;
+	int clinet;
+	
+	clinet = mdp3_get_ion_clinet(mfd);
+	
+	rc = mdp3_get_img(img, &data, clinet);
 
-	rc = mdp3_get_img(img, &data, MDP3_CLIENT_DMA_P);
 	if (rc) {
 		pr_err("fail to get overlay buffer\n");
 		return rc;
@@ -1155,14 +1195,14 @@ static int mdp3_overlay_queue_buffer(struct msm_fb_data_type *mfd,
 
 	if (data.len < dma->source_config.stride * dma->source_config.height) {
 		pr_err("buf length is smaller than required by dma configuration\n");
-		mdp3_put_img(&data, MDP3_CLIENT_DMA_P);
+		mdp3_put_img(&data, clinet);
 		return -EINVAL;
 	}
 
 	rc = mdp3_bufq_push(&mdp3_session->bufq_in, &data);
 	if (rc) {
 		pr_err("fail to queue the overlay buffer, buffer drop\n");
-		mdp3_put_img(&data, MDP3_CLIENT_DMA_P);
+		mdp3_put_img(&data, clinet);
 		return rc;
 	}
 	return 0;
@@ -1217,8 +1257,11 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 	struct mdp3_img_data *data;
 	struct mdss_panel_info *panel_info;
 	int rc = 0;
+	int clinet;
 	static bool splash_done;
 	struct mdss_panel_data *panel;
+	int frame_rate = DEFAULT_FRAME_RATE;
+	int stride;
 
 	if (!mfd || !mfd->mdp.private1)
 		return -EINVAL;
@@ -1227,6 +1270,9 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 	mdp3_session = mfd->mdp.private1;
 	if (!mdp3_session || !mdp3_session->dma)
 		return -EINVAL;
+	
+	frame_rate = mdss_panel_get_framerate(panel_info);
+	clinet = mdp3_get_ion_clinet(mfd);
 
 	if (mdp3_bufq_count(&mdp3_session->bufq_in) == 0) {
 		pr_debug("no buffer in queue yet\n");
@@ -1273,27 +1319,39 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 	if (data) {
 		mdp3_ctrl_reset_countdown(mdp3_session, mfd);
 		mdp3_ctrl_clk_enable(mfd, 1);
-		if (mdp3_session->dma->update_src_cfg &&
-				panel_info->partial_update_enabled) {
-			panel->panel_info.roi.x = mdp3_session->dma->roi.x;
-			panel->panel_info.roi.y = mdp3_session->dma->roi.y;
-			panel->panel_info.roi.w = mdp3_session->dma->roi.w;
-			panel->panel_info.roi.h = mdp3_session->dma->roi.h;
-			rc = mdp3_session->dma->update(mdp3_session->dma,
-					(void *)(int)data->addr,
-					mdp3_session->intf, (void *)panel);
+		
+		stride = mdp3_session->dma->source_config.stride;
+		if (mdp3_ctrl_get_intf_type(mfd) ==
+				MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
+			rc = mdss_spi_panel_kickoff(mdp3_session->panel,
+						(void *)(int)data->addr,
+						(int)data->len,
+						stride);
 		} else {
-			rc = mdp3_session->dma->update(mdp3_session->dma,
-					(void *)(int)data->addr,
-					mdp3_session->intf, NULL);
-		}
+			if (mdp3_session->dma->update_src_cfg &&
+					panel_info->partial_update_enabled) {
+					panel->panel_info.roi.x = mdp3_session->dma->roi.x;
+					panel->panel_info.roi.y = mdp3_session->dma->roi.y;
+					panel->panel_info.roi.w = mdp3_session->dma->roi.w;
+					panel->panel_info.roi.h = mdp3_session->dma->roi.h;
+					rc = mdp3_session->dma->update(mdp3_session->dma,
+							(void *)(int)data->addr,
+							mdp3_session->intf, (void *)panel);
+			} else {
+					rc = mdp3_session->dma->update(mdp3_session->dma,
+						(void *)(int)data->addr,
+						mdp3_session->intf, NULL);
+			}
+	
 		/* This is for the previous frame */
 		if (rc < 0) {
 			mdp3_ctrl_notify(mdp3_session,
 				MDP_NOTIFY_FRAME_TIMEOUT);
 		} else {
 			if (mdp3_ctrl_get_intf_type(mfd) ==
-						MDP3_DMA_OUTPUT_SEL_DSI_VIDEO) {
+						MDP3_DMA_OUTPUT_SEL_DSI_VIDEO || 
+						mdp3_ctrl_get_intf_type(mfd) == 
+						MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
 				mdp3_ctrl_notify(mdp3_session,
 					MDP_NOTIFY_FRAME_DONE);
 			}
@@ -1303,21 +1361,21 @@ static int mdp3_ctrl_display_commit_kickoff(struct msm_fb_data_type *mfd,
 		mdp3_ctrl_notify(mdp3_session, MDP_NOTIFY_FRAME_FLUSHED);
 		mdp3_bufq_push(&mdp3_session->bufq_out, data);
 	}
-
+	}	
 	if (mdp3_bufq_count(&mdp3_session->bufq_out) > 1) {
 		mdp3_release_splash_memory(mfd);
 		data = mdp3_bufq_pop(&mdp3_session->bufq_out);
 		if (data)
-			mdp3_put_img(data, MDP3_CLIENT_DMA_P);
+			mdp3_put_img(data, clinet);
 	}
 
 	if (mdp3_session->first_commit) {
 		/*wait to ensure frame is sent to panel*/
 		if (panel_info->mipi.post_init_delay)
-			msleep(((1000 / panel_info->mipi.frame_rate) + 1) *
+			msleep(((1000 / frame_rate) + 1) *
 					panel_info->mipi.post_init_delay);
 		else
-			msleep(1000 / panel_info->mipi.frame_rate);
+			msleep(1000 / frame_rate);
 		mdp3_session->first_commit = false;
 		rc |= panel->event_handler(panel,
 					MDSS_EVENT_POST_PANEL_ON, NULL);
@@ -1351,6 +1409,7 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 	struct mdss_panel_info *panel_info;
 	static bool splash_done;
 	struct mdss_panel_data *panel;
+	int frame_rate = DEFAULT_FRAME_RATE;
 
 	int rc;
 
@@ -1362,6 +1421,8 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 	mdp3_session = (struct mdp3_session_data *)mfd->mdp.private1;
 	if (!mdp3_session || !mdp3_session->dma)
 		return;
+	
+	frame_rate = mdss_panel_get_framerate(panel_info);
 
 	if (mdp3_session->in_splash_screen ||
 		mdp3_res->idle_pc) {
@@ -1420,22 +1481,24 @@ static void mdp3_ctrl_pan_display(struct msm_fb_data_type *mfd)
 		mdp3_session->dma->stop(mdp3_session->dma, mdp3_session->intf);
 		mdp3_clk_enable(0, 0);
 	}
-
+	if (mdp3_ctrl_get_intf_type(mfd) != MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
 	panel = mdp3_session->panel;
 	if (mdp3_session->first_commit) {
 		/*wait to ensure frame is sent to panel*/
 		if (panel_info->mipi.post_init_delay)
-			msleep(((1000 / panel_info->mipi.frame_rate) + 1) *
+				msleep(((1000 / frame_rate) + 1) *
 					panel_info->mipi.post_init_delay);
 		else
-			msleep(1000 / panel_info->mipi.frame_rate);
+				msleep(1000 / frame_rate);
 		mdp3_session->first_commit = false;
+		
 		if (panel)
 			panel->event_handler(panel, MDSS_EVENT_POST_PANEL_ON,
 					NULL);
 	}
-
+	}
 	mdp3_session->vsync_before_commit = 0;
+	panel = mdp3_session->panel;
 	if (!splash_done || mdp3_session->esd_recovery == true) {
 		if(panel && panel->set_backlight)
 			panel->set_backlight(panel, panel->panel_info.bl_max);
@@ -1481,7 +1544,7 @@ static int mdp3_get_metadata(struct msm_fb_data_type *mfd,
 	switch (metadata->op) {
 	case metadata_op_frame_rate:
 		metadata->data.panel_frame_rate =
-			mfd->panel_info->mipi.frame_rate;
+			mdss_panel_get_framerate(mfd->panel_info);
 		break;
 	case metadata_op_get_caps:
 		metadata->data.caps.mdp_rev = 305;
@@ -2571,6 +2634,7 @@ int mdp3_ctrl_init(struct msm_fb_data_type *mfd)
 	struct msm_mdp_interface *mdp3_interface = &mfd->mdp;
 	struct mdp3_session_data *mdp3_session = NULL;
 	u32 intf_type = MDP3_DMA_OUTPUT_SEL_DSI_VIDEO;
+	int frame_rate = DEFAULT_FRAME_RATE;
 	int rc;
 	int splash_mismatch = 0;
 
@@ -2579,6 +2643,8 @@ int mdp3_ctrl_init(struct msm_fb_data_type *mfd)
 	if (rc)
 		splash_mismatch = 1;
 
+	frame_rate = mdss_panel_get_framerate(mfd->panel_info);
+
 	mdp3_interface->on_fnc = mdp3_ctrl_on;
 	mdp3_interface->off_fnc = mdp3_ctrl_off;
 	mdp3_interface->do_histogram = NULL;
@@ -2637,12 +2703,13 @@ int mdp3_ctrl_init(struct msm_fb_data_type *mfd)
 	init_timer(&mdp3_session->vsync_timer);
 	mdp3_session->vsync_timer.function = mdp3_vsync_timer_func;
 	mdp3_session->vsync_timer.data = (u32)mdp3_session;
-	mdp3_session->vsync_period = 1000 / mfd->panel_info->mipi.frame_rate;
+	mdp3_session->vsync_period = 1000 / frame_rate;
 	mfd->mdp.private1 = mdp3_session;
 	INIT_COMPLETION(mdp3_session->dma_completion);
-	if (intf_type != MDP3_DMA_OUTPUT_SEL_DSI_VIDEO)
+	if (intf_type != MDP3_DMA_OUTPUT_SEL_DSI_VIDEO ||
+		intf_type != MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
 		mdp3_session->wait_for_dma_done = mdp3_wait_for_dma_done;
-
+	}
 	rc = sysfs_create_group(&dev->kobj, &vsync_fs_attr_group);
 	if (rc) {
 		pr_err("vsync sysfs group creation failed, ret=%d\n", rc);
diff --git a/kernel/drivers/video/msm/mdss/mdp3_dma.c b/kernel/drivers/video/msm/mdss/mdp3_dma.c
old mode 100644
new mode 100755
index b8c2a63..c05a10c
--- a/kernel/drivers/video/msm/mdss/mdp3_dma.c
+++ b/kernel/drivers/video/msm/mdss/mdp3_dma.c
@@ -109,7 +109,8 @@ void mdp3_dma_callback_enable(struct mdp3_dma *dma, int type)
 	}
 
 	if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_VIDEO ||
-		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_LCDC) {
+		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_LCDC || 
+		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_SPI_CMD) {
 		if (type & MDP3_DMA_CALLBACK_TYPE_VSYNC)
 			mdp3_irq_enable(MDP3_INTR_LCDC_START_OF_FRAME);
 	} else if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD) {
@@ -187,10 +188,11 @@ static int mdp3_dma_callback_setup(struct mdp3_dma *dma)
 		rc = mdp3_set_intr_callback(MDP3_INTR_DMA_P_HISTO, &hist_cb);
 
 	if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_VIDEO ||
-		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_LCDC)
+		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_LCDC || 
+		dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_SPI_CMD ) {
 		rc |= mdp3_set_intr_callback(MDP3_INTR_LCDC_START_OF_FRAME,
 					&vsync_cb);
-	else if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD) {
+	} else if (dma->output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD) {
 		int irq_bit = MDP3_INTR_SYNC_PRIMARY_LINE;
 		irq_bit += dma->dma_sel;
 		rc |= mdp3_set_intr_callback(irq_bit, &vsync_cb);
@@ -1249,6 +1251,25 @@ int dsi_cmd_stop(struct mdp3_intf *intf)
 	return 0;
 }
 
+int spi_cmd_config(struct mdp3_intf *intf, struct mdp3_intf_cfg *cfg)
+{
+	return 0;
+}
+
+int spi_cmd_start(struct mdp3_intf *intf)
+{
+	intf->active = true;
+	return 0;
+}
+
+int spi_cmd_stop(struct mdp3_intf *intf)
+{
+	intf->active = false;
+	return 0;
+}
+
+
+
 int mdp3_intf_init(struct mdp3_intf *intf)
 {
 	switch (intf->cfg.type) {
@@ -1267,6 +1288,12 @@ int mdp3_intf_init(struct mdp3_intf *intf)
 		intf->start = dsi_cmd_start;
 		intf->stop = dsi_cmd_stop;
 		break;
+	
+	case MDP3_DMA_OUTPUT_SEL_SPI_CMD:
+		intf->config = spi_cmd_config;
+		intf->start = spi_cmd_start;
+		intf->stop = spi_cmd_stop;
+		break;
 
 	default:
 		return -EINVAL;
diff --git a/kernel/drivers/video/msm/mdss/mdp3_dma.h b/kernel/drivers/video/msm/mdss/mdp3_dma.h
old mode 100644
new mode 100755
index 302344f..7968b6d
--- a/kernel/drivers/video/msm/mdss/mdp3_dma.h
+++ b/kernel/drivers/video/msm/mdss/mdp3_dma.h
@@ -48,6 +48,7 @@ enum {
 	MDP3_DMA_OUTPUT_SEL_DSI_CMD,
 	MDP3_DMA_OUTPUT_SEL_LCDC,
 	MDP3_DMA_OUTPUT_SEL_DSI_VIDEO,
+	MDP3_DMA_OUTPUT_SEL_SPI_CMD,
 	MDP3_DMA_OUTPUT_SEL_MAX
 };
 
diff --git a/kernel/drivers/video/msm/mdss/mdp3_ppp.c b/kernel/drivers/video/msm/mdss/mdp3_ppp.c
old mode 100644
new mode 100755
index 0f940d6..c477f2f
--- a/kernel/drivers/video/msm/mdss/mdp3_ppp.c
+++ b/kernel/drivers/video/msm/mdss/mdp3_ppp.c
@@ -536,6 +536,7 @@ u64 mdp3_adjust_scale_factor(struct mdp_blit_req *req, u32 bw_req, int bpp)
 int mdp3_calc_ppp_res(struct msm_fb_data_type *mfd,  struct blit_req_list *lreq)
 {
 	struct mdss_panel_info *panel_info = mfd->panel_info;
+	int frame_rate = DEFAULT_FRAME_RATE;
 	int i, lcount = 0;
 	struct mdp_blit_req *req;
 	struct bpp_info bpp;
@@ -551,6 +552,7 @@ int mdp3_calc_ppp_res(struct msm_fb_data_type *mfd,  struct blit_req_list *lreq)
 
 	ATRACE_BEGIN(__func__);
 	lcount = lreq->count;
+	frame_rate = mdss_panel_get_framerate(panel_info);
 	if (lcount == 0) {
 		pr_err("Blit with request count 0, continue to recover!!!\n");
 		ATRACE_END(__func__);
@@ -578,17 +580,17 @@ int mdp3_calc_ppp_res(struct msm_fb_data_type *mfd,  struct blit_req_list *lreq)
 		is_blit_optimization_possible(lreq, i);
 		req = &(lreq->req_list[i]);
 
-		if (req->fps > 0 && req->fps <= panel_info->mipi.frame_rate) {
+		if (req->fps > 0 && req->fps <= frame_rate) {
 			if (fps == 0)
 				fps = req->fps;
 			else
-				fps = panel_info->mipi.frame_rate;
+				fps = frame_rate;
 		}
 		if (!(check_if_rgb(req->src.format))) {
 			/* Set max fps if video is not full screen */
 			if((req->dst_rect.w < panel_info->xres) ||
 				( req->dst_rect.h < panel_info->yres))
-				fps = panel_info->mipi.frame_rate;
+				fps = frame_rate;
 		}
 		mdp3_get_bpp_info(req->src.format, &bpp);
 		if (lreq->req_list[i].flags & MDP_SMART_BLIT) {
@@ -642,7 +644,7 @@ int mdp3_calc_ppp_res(struct msm_fb_data_type *mfd,  struct blit_req_list *lreq)
 	}
 
 	if (fps == 0)
-		fps = panel_info->mipi.frame_rate;
+		fps = frame_rate;
 
 	if (lreq->req_list[0].flags & MDP_SOLID_FILL) {
 		honest_ppp_ab = ppp_res.solid_fill_byte * 4;
diff --git a/kernel/drivers/video/msm/mdss/mdp3_ppp_data.c b/kernel/drivers/video/msm/mdss/mdp3_ppp_data.c
old mode 100644
new mode 100755
index 88b186a..d343e44
--- a/kernel/drivers/video/msm/mdss/mdp3_ppp_data.c
+++ b/kernel/drivers/video/msm/mdss/mdp3_ppp_data.c
@@ -89,8 +89,13 @@ const uint32_t pack_patt_lut[MDP_IMGTYPE_LIMIT] = {
 };
 
 const uint32_t swapped_pack_patt_lut[MDP_IMGTYPE_LIMIT] = {
+#if 0
 	[MDP_RGB_565] = PPP_GET_PACK_PATTERN(0, CLR_B, CLR_G, CLR_R, 8),
 	[MDP_BGR_565] = PPP_GET_PACK_PATTERN(0, CLR_R, CLR_G, CLR_B, 8),
+#else
+	[MDP_RGB_565] = PPP_GET_PACK_PATTERN(0, CLR_R, CLR_G, CLR_B, 8),
+	[MDP_BGR_565] = PPP_GET_PACK_PATTERN(0, CLR_B, CLR_G, CLR_R, 8),
+#endif
 	[MDP_RGB_888] = PPP_GET_PACK_PATTERN(0, CLR_B, CLR_G, CLR_R, 8),
 	[MDP_BGR_888] = PPP_GET_PACK_PATTERN(0, CLR_R, CLR_G, CLR_B, 8),
 	[MDP_BGRA_8888] = PPP_GET_PACK_PATTERN(CLR_ALPHA, CLR_R,
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi.c b/kernel/drivers/video/msm/mdss/mdss_dsi.c
old mode 100644
new mode 100755
diff --git a/kernel/drivers/video/msm/mdss/mdss_fb.c b/kernel/drivers/video/msm/mdss/mdss_fb.c
old mode 100644
new mode 100755
index 2e8092d..c093e51
--- a/kernel/drivers/video/msm/mdss/mdss_fb.c
+++ b/kernel/drivers/video/msm/mdss/mdss_fb.c
@@ -794,9 +794,12 @@ static int mdss_fb_probe(struct platform_device *pdev)
 	mfd->ad_bl_level = 0;
 	mfd->fb_imgType = MDP_RGBA_8888;
 	mfd->calib_mode_bl = 0;
+	if (mfd->panel.type == SPI_PANEL)
+		mfd->fb_imgType = MDP_RGB_565;
 
-	if (mfd->panel.type == MIPI_VIDEO_PANEL ||
-				mfd->panel.type == MIPI_CMD_PANEL) {
+	if (mfd->panel.type == MIPI_VIDEO_PANEL   ||
+		mfd->panel.type == MIPI_CMD_PANEL ||
+		mfd->panel.type == SPI_PANEL) {
 		rc = of_property_read_string(pdev->dev.of_node,
 				"qcom,mdss-fb-format", &data);
 		if (!rc) {
@@ -2171,8 +2174,8 @@ static int mdss_fb_register(struct msm_fb_data_type *mfd)
 	}
 
 	mdss_panel_debugfs_init(panel_info);
-	pr_info("FrameBuffer[%d] %dx%d registered successfully!\n", mfd->index,
-					fbi->var.xres, fbi->var.yres);
+	pr_info("FrameBuffer[%d] %dx%d registered successfully!bpp = %d, fb_imgType = %u, \n", mfd->index,
+					fbi->var.xres, fbi->var.yres, bpp, mfd->fb_imgType);
 
 	return 0;
 }
diff --git a/kernel/drivers/video/msm/mdss/mdss_mdp.c b/kernel/drivers/video/msm/mdss/mdss_mdp.c
old mode 100644
new mode 100755
index 7086498..f689c6f
--- a/kernel/drivers/video/msm/mdss/mdss_mdp.c
+++ b/kernel/drivers/video/msm/mdss/mdss_mdp.c
@@ -1476,6 +1476,8 @@ static int mdss_mdp_probe(struct platform_device *pdev)
 	int rc;
 	struct mdss_data_type *mdata;
 
+	
+	pr_err("%s entered\n", __func__);
 	if (!pdev->dev.of_node) {
 		pr_err("MDP driver only supports device tree probe\n");
 		return -ENOTSUPP;
@@ -1606,6 +1608,8 @@ static int mdss_mdp_probe(struct platform_device *pdev)
 	if (rc)
 		pr_err("mdss_register_irq failed.\n");
 	mdss_res->mdss_util->mdp_probe_done = true;
+
+	pr_err("%s probe successfully\n", __func__);
 probe_done:
 	if (IS_ERR_VALUE(rc)) {
 		mdss_mdp_hw.ptr = NULL;
diff --git a/kernel/drivers/video/msm/mdss/mdss_panel.h b/kernel/drivers/video/msm/mdss/mdss_panel.h
old mode 100644
new mode 100755
index 61452f6..cdbc64f
--- a/kernel/drivers/video/msm/mdss/mdss_panel.h
+++ b/kernel/drivers/video/msm/mdss/mdss_panel.h
@@ -44,6 +44,8 @@ struct panel_id {
 #define WRITEBACK_PANEL		10	/* Wifi display */
 #define LVDS_PANEL		11	/* LVDS */
 #define EDP_PANEL		12	/* LVDS */
+#define SPI_PANEL		13	/* SPI */
+
 
 static inline const char *mdss_panel2str(u32 panel)
 {
@@ -85,6 +87,7 @@ enum {
 	MDSS_PANEL_INTF_DSI,
 	MDSS_PANEL_INTF_EDP,
 	MDSS_PANEL_INTF_HDMI,
+	MDSS_PANEL_INTF_SPI,
 };
 
 enum {
@@ -310,6 +313,12 @@ struct edp_panel_info {
 	char frame_rate;	/* fps */
 };
 
+struct spi_panel_info {	
+	char frame_rate;	/* fps */
+};
+
+
+
 enum dynamic_fps_update {
 	DFPS_SUSPEND_RESUME_MODE,
 	DFPS_IMMEDIATE_CLK_UPDATE_MODE,
@@ -432,6 +441,7 @@ struct mdss_panel_info {
 	struct lcd_panel_info lcdc;
 	struct fbc_panel_info fbc;
 	struct mipi_panel_info mipi;
+	struct spi_panel_info spi;
 	struct lvds_panel_info lvds;
 	struct edp_panel_info edp;
 
@@ -494,6 +504,9 @@ static inline u32 mdss_panel_get_framerate(struct mdss_panel_info *panel_info)
 	case WRITEBACK_PANEL:
 		frame_rate = DEFAULT_FRAME_RATE;
 		break;
+	case SPI_PANEL:
+		frame_rate = panel_info->spi.frame_rate;
+		break;
 	default:
 		pixel_total = (panel_info->lcdc.h_back_porch +
 			  panel_info->lcdc.h_front_porch +
diff --git a/kernel/drivers/video/msm/mdss/mdss_spi_client.c b/kernel/drivers/video/msm/mdss/mdss_spi_client.c
new file mode 100755
index 0000000..4b8220d
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_spi_client.c
@@ -0,0 +1,165 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/qpnp/pin.h>
+#include <linux/delay.h>
+
+#define SPI_PANEL_COMMAND_LEN 1
+static struct spi_device *mdss_spi_client;
+static int dc_gpio;
+
+int mdss_spi_tx_command(const void *buf)
+{
+	int rc = 0;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len    = SPI_PANEL_COMMAND_LEN,
+	};
+	struct spi_message m;
+
+	if (!mdss_spi_client) {
+		pr_err("%s: spi client not available\n", __func__);
+		return -EINVAL;
+	}
+
+	mdss_spi_client->bits_per_word = 8;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	/*pull down dc gpio indicate this is command*/
+	gpio_set_value(dc_gpio, 0);
+	rc = spi_sync(mdss_spi_client, &m);
+	gpio_set_value(dc_gpio, 1);
+
+	return rc;
+}
+
+int mdss_spi_tx_parameter(const void *buf, size_t len)
+{
+	int rc = 0;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len    = len,
+	};
+	struct spi_message m;
+
+	if (!mdss_spi_client) {
+		pr_err("%s: spi client not available\n", __func__);
+		return -EINVAL;
+	}
+
+	mdss_spi_client->bits_per_word = 8;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	rc = spi_sync(mdss_spi_client, &m);
+
+	return rc;
+}
+
+int mdss_spi_tx_pixel(const void *buf, size_t len)
+{
+	int rc = 0;
+	struct spi_transfer t = {
+		.tx_buf = buf,
+		.len    = len,
+		};
+	struct spi_message m;
+
+	if (!mdss_spi_client) {
+		pr_err("%s: spi client not available\n", __func__);
+		return -EINVAL;
+	}
+
+	mdss_spi_client->bits_per_word = 16;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	rc = spi_sync(mdss_spi_client, &m);
+
+	return rc;
+}
+
+static int mdss_spi_client_probe(struct spi_device *spidev)
+{
+	int irq;
+	int cs;
+	int cpha, cpol, cs_high;
+	u32 max_speed;
+	struct device_node *np;
+
+	irq = spidev->irq;
+	cs = spidev->chip_select;
+	cpha = (spidev->mode & SPI_CPHA) ? 1:0;
+	cpol = (spidev->mode & SPI_CPOL) ? 1:0;
+	cs_high = (spidev->mode & SPI_CS_HIGH) ? 1:0;
+	max_speed = spidev->max_speed_hz;
+	np = spidev->dev.of_node;
+	pr_debug("cs[%x] CPHA[%x] CPOL[%x] CS_HIGH[%x] Max_speed[%d]\n",
+		cs, cpha, cpol, cs_high, max_speed);
+
+	dc_gpio = of_get_named_gpio(np, "dc-gpio", 0);
+	if (!gpio_is_valid(dc_gpio))
+		pr_err("%s %d,spi panel dc gpio is not valid\n",
+						__func__, __LINE__);
+
+
+	if (gpio_request(dc_gpio, "dc-gpios"))
+		pr_err("%s %d spi panel dc gpio_request failed\n",
+						__func__, __LINE__);
+
+
+	if (gpio_direction_output(dc_gpio, 1))
+		pr_err("%s %d set spi panel dc gpio direction failed\n",
+						__func__, __LINE__);
+
+	mdss_spi_client = spidev;
+	return 0;
+}
+
+
+static const struct of_device_id mdss_spi_dt_match[] = {
+	{ .compatible = "qcom,mdss-spi-client" },
+	{},
+};
+
+static struct spi_driver mdss_spi_client_driver = {
+	.probe = mdss_spi_client_probe,
+	.driver = {
+	.name = "mdss-spi-client",
+	.owner  = THIS_MODULE,
+	.of_match_table = mdss_spi_dt_match,
+	},
+};
+
+static int __init mdss_spi_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&mdss_spi_client_driver);
+
+	return 0;
+}
+module_init(mdss_spi_init);
+
+static void __exit mdss_spi_exit(void)
+{
+	spi_register_driver(&mdss_spi_client_driver);
+}
+module_exit(mdss_spi_exit);
+
diff --git a/kernel/drivers/video/msm/mdss/mdss_spi_client.h b/kernel/drivers/video/msm/mdss/mdss_spi_client.h
new file mode 100755
index 0000000..6042d35
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_spi_client.h
@@ -0,0 +1,20 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MDSS_SPI_CLINET_H__
+#define __MDSS_SPI_CLINET_H__
+
+int mdss_spi_tx_command(const void *buf);
+int mdss_spi_tx_parameter(const void *buf, size_t len);
+int mdss_spi_tx_pixel(const void *buf, size_t len);
+
+#endif /* End of __MDSS_SPI_CLINET_H__ */
diff --git a/kernel/drivers/video/msm/mdss/mdss_spi_panel.c b/kernel/drivers/video/msm/mdss/mdss_spi_panel.c
new file mode 100755
index 0000000..f2bbf7d
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_spi_panel.c
@@ -0,0 +1,1439 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/qpnp/pin.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/leds.h>
+#include <linux/qpnp/pwm.h>
+#include <linux/of_device.h>
+
+#include "mdss.h"
+#include "mdss_panel.h"
+#include "mdss_spi_panel.h"
+#include "mdss_spi_client.h"
+
+DEFINE_LED_TRIGGER(bl_led_trigger);
+int mdss_spi_panel_reset(struct mdss_panel_data *pdata, int enable)
+{
+	struct spi_panel_data *ctrl_pdata = NULL;
+	struct mdss_panel_info *pinfo = NULL;
+	int i, rc = 0;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	if (!gpio_is_valid(ctrl_pdata->rst_gpio)) {
+		pr_debug("%s:%d, reset line not configured\n",
+			   __func__, __LINE__);
+		return rc;
+	}
+
+	pr_debug("%s: enable = %d\n", __func__, enable);
+	pinfo = &(ctrl_pdata->panel_data.panel_info);
+
+	if (enable) {
+		rc = gpio_request(ctrl_pdata->rst_gpio, "disp_rst_n");
+		if (rc) {
+			pr_err("gpio request failed\n");
+			return rc;
+		}
+		if (!pinfo->cont_splash_enabled) {
+			for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
+				gpio_set_value((ctrl_pdata->rst_gpio),
+					pdata->panel_info.rst_seq[i]);
+				if (pdata->panel_info.rst_seq[++i])
+					usleep(pinfo->rst_seq[i] * 1000);
+			}
+		}
+
+		if (ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT) {
+			pr_debug("%s: Panel Not properly turned OFF\n",
+						__func__);
+			ctrl_pdata->ctrl_state &= ~CTRL_STATE_PANEL_INIT;
+			pr_err("%s: Reset panel done\n", __func__);
+		}
+	} else {
+		gpio_set_value((ctrl_pdata->rst_gpio), 0);
+		gpio_free(ctrl_pdata->rst_gpio);
+	}
+	return rc;
+}
+
+
+static int mdss_spi_panel_pinctrl_set_state(
+	struct spi_panel_data *ctrl_pdata,
+	bool active)
+{
+	struct pinctrl_state *pin_state;
+	int rc = -EFAULT;
+
+	if (IS_ERR_OR_NULL(ctrl_pdata->pin_res.pinctrl))
+		return PTR_ERR(ctrl_pdata->pin_res.pinctrl);
+
+	pin_state = active ? ctrl_pdata->pin_res.gpio_state_active
+				: ctrl_pdata->pin_res.gpio_state_suspend;
+	if (!IS_ERR_OR_NULL(pin_state)) {
+		rc = pinctrl_select_state(ctrl_pdata->pin_res.pinctrl,
+				pin_state);
+		if (rc)
+			pr_err("%s: can not set %s pins\n", __func__,
+			       active ? MDSS_PINCTRL_STATE_DEFAULT
+			       : MDSS_PINCTRL_STATE_SLEEP);
+	} else {
+		pr_err("%s: invalid '%s' pinstate\n", __func__,
+		       active ? MDSS_PINCTRL_STATE_DEFAULT
+		       : MDSS_PINCTRL_STATE_SLEEP);
+	}
+	return rc;
+}
+
+
+static int mdss_spi_panel_pinctrl_init(struct platform_device *pdev)
+{
+	struct spi_panel_data *ctrl_pdata;
+
+	ctrl_pdata = platform_get_drvdata(pdev);
+	ctrl_pdata->pin_res.pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(ctrl_pdata->pin_res.pinctrl)) {
+		pr_err("%s: failed to get pinctrl\n", __func__);
+		return PTR_ERR(ctrl_pdata->pin_res.pinctrl);
+	}
+
+	ctrl_pdata->pin_res.gpio_state_active
+		= pinctrl_lookup_state(ctrl_pdata->pin_res.pinctrl,
+				MDSS_PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(ctrl_pdata->pin_res.gpio_state_active))
+		pr_warn("%s: can not get default pinstate\n", __func__);
+
+	ctrl_pdata->pin_res.gpio_state_suspend
+		= pinctrl_lookup_state(ctrl_pdata->pin_res.pinctrl,
+				MDSS_PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(ctrl_pdata->pin_res.gpio_state_suspend))
+		pr_warn("%s: can not get sleep pinstate\n", __func__);
+
+	return 0;
+}
+
+
+static int mdss_spi_panel_power_on(struct mdss_panel_data *pdata)
+{
+	int ret = 0;
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+	ret = msm_dss_enable_vreg(
+		ctrl_pdata->panel_power_data.vreg_config,
+		ctrl_pdata->panel_power_data.num_vreg, 1);
+	if (ret) {
+		pr_err("%s: failed to enable vregs for %s\n",
+			__func__, "PANEL_PM");
+	}
+
+	/*
+	 * If continuous splash screen feature is enabled, then we need to
+	 * request all the GPIOs that have already been configured in the
+	 * bootloader. This needs to be done irresepective of whether
+	 * the lp11_init flag is set or not.
+	 */
+	if (pdata->panel_info.cont_splash_enabled) {
+		if (mdss_spi_panel_pinctrl_set_state(ctrl_pdata, true))
+			pr_debug("reset enable: pinctrl not enabled\n");
+
+		ret = mdss_spi_panel_reset(pdata, 1);
+		if (ret)
+			pr_err("%s: Panel reset failed. rc=%d\n",
+					__func__, ret);
+	}
+
+	return ret;
+}
+
+
+static int mdss_spi_panel_power_off(struct mdss_panel_data *pdata)
+{
+	int ret = 0;
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		ret = -EINVAL;
+		goto end;
+	}
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	ret = mdss_spi_panel_reset(pdata, 0);
+	if (ret) {
+		pr_warn("%s: Panel reset failed. rc=%d\n", __func__, ret);
+		ret = 0;
+	}
+
+	if (mdss_spi_panel_pinctrl_set_state(ctrl_pdata, false))
+		pr_warn("reset disable: pinctrl not enabled\n");
+
+	ret = msm_dss_enable_vreg(
+		ctrl_pdata->panel_power_data.vreg_config,
+		ctrl_pdata->panel_power_data.num_vreg, 0);
+	if (ret)
+		pr_err("%s: failed to disable vregs for %s\n",
+			__func__, "PANEL_PM");
+
+end:
+	return ret;
+}
+
+
+static int mdss_spi_panel_power_ctrl(struct mdss_panel_data *pdata,
+	int power_state)
+{
+	int ret;
+	struct mdss_panel_info *pinfo;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	pinfo = &pdata->panel_info;
+	pr_debug("%s: cur_power_state=%d req_power_state=%d\n", __func__,
+		pinfo->panel_power_state, power_state);
+
+	if (pinfo->panel_power_state == power_state) {
+		pr_debug("%s: no change needed\n", __func__);
+		return 0;
+	}
+
+	switch (power_state) {
+	case MDSS_PANEL_POWER_OFF:
+		ret = mdss_spi_panel_power_off(pdata);
+		break;
+	case MDSS_PANEL_POWER_ON:
+		ret = mdss_spi_panel_power_on(pdata);
+		break;
+	default:
+		pr_err("%s: unknown panel power state requested (%d)\n",
+			__func__, power_state);
+		ret = -EINVAL;
+	}
+
+	if (!ret)
+		pinfo->panel_power_state = power_state;
+
+	return ret;
+}
+
+static int mdss_spi_panel_unblank(struct mdss_panel_data *pdata)
+{
+	int ret = 0;
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	if (!(ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT)) {
+			ret = ctrl_pdata->on(pdata);
+			if (ret) {
+				pr_err("%s: unable to initialize the panel\n",
+							__func__);
+				return ret;
+		}
+		ctrl_pdata->ctrl_state |= CTRL_STATE_PANEL_INIT;
+	}
+
+	return ret;
+}
+
+static int mdss_spi_panel_blank(struct mdss_panel_data *pdata, int power_state)
+{
+	int ret = 0;
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	if (ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT) {
+			ret = ctrl_pdata->off(pdata);
+			if (ret) {
+				pr_err("%s: Panel OFF failed\n", __func__);
+				return ret;
+			}
+		ctrl_pdata->ctrl_state &= ~CTRL_STATE_PANEL_INIT;
+	}
+
+	return ret;
+}
+
+
+static int mdss_spi_panel_event_handler(struct mdss_panel_data *pdata,
+				  int event, void *arg)
+{
+	int rc = 0;
+	struct spi_panel_data *ctrl_pdata = NULL;
+	int power_state;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	switch (event) {
+	case MDSS_EVENT_LINK_READY:
+		rc = mdss_spi_panel_power_ctrl(pdata, MDSS_PANEL_POWER_ON);
+		if (rc) {
+			pr_err("%s:Panel power on failed. rc=%d\n",
+							__func__, rc);
+			return rc;
+		}
+		mdss_spi_panel_pinctrl_set_state(ctrl_pdata, true);
+		mdss_spi_panel_reset(pdata, 1);
+		break;
+	case MDSS_EVENT_UNBLANK:
+		rc = mdss_spi_panel_unblank(pdata);
+		break;
+	case MDSS_EVENT_PANEL_ON:
+		ctrl_pdata->ctrl_state |= CTRL_STATE_MDP_ACTIVE;
+		break;
+	case MDSS_EVENT_BLANK:
+		power_state = (int) (unsigned long) arg;
+		break;
+	case MDSS_EVENT_PANEL_OFF:
+		power_state = (int) (unsigned long) arg;
+		ctrl_pdata->ctrl_state &= ~CTRL_STATE_MDP_ACTIVE;
+		rc = mdss_spi_panel_blank(pdata, power_state);
+		rc = mdss_spi_panel_power_ctrl(pdata, power_state);
+		break;
+	default:
+		pr_debug("%s: unhandled event=%d\n", __func__, event);
+		break;
+	}
+	pr_debug("%s-:event=%d, rc=%d\n", __func__, event, rc);
+	return rc;
+}
+
+int is_spi_panel_continuous_splash_on(struct mdss_panel_data *pdata)
+{
+	int i = 0, voltage = 0;
+	struct dss_vreg *vreg;
+	int num_vreg;
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+			panel_data);
+	vreg = ctrl_pdata->panel_power_data.vreg_config;
+	num_vreg = ctrl_pdata->panel_power_data.num_vreg;
+
+	for (i = 0; i < num_vreg; i++) {
+		if (regulator_is_enabled(vreg[i].vreg) <= 0)
+			return false;
+		voltage = regulator_get_voltage(vreg[i].vreg);
+		if (!(voltage >= vreg[i].min_voltage &&
+			 voltage <= vreg[i].max_voltage))
+			return false;
+	}
+
+	return true;
+}
+
+int mdss_spi_panel_kickoff(struct mdss_panel_data *pdata,
+			char *buf, int len, int dma_stride)
+{
+	struct spi_panel_data *ctrl_pdata = NULL;
+	char *tx_buf;
+	int rc = 0;
+	int panel_yres;
+	int panel_xres;
+	int padding_length = 0;
+	int actual_stride = 0;
+	int byte_per_pixel = 0;
+	int scan_count = 0;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	tx_buf = ctrl_pdata->tx_buf;
+	panel_xres = ctrl_pdata->panel_data.panel_info.xres;
+	panel_yres = ctrl_pdata->panel_data.panel_info.yres;
+
+	byte_per_pixel = ctrl_pdata->panel_data.panel_info.bpp / 8;
+	actual_stride = panel_xres * byte_per_pixel;
+	padding_length = dma_stride - actual_stride;
+
+	/* remove the padding and copy to continuous buffer */
+	while (scan_count < panel_yres) {
+		memcpy((tx_buf + scan_count * actual_stride),
+			(buf + scan_count * (actual_stride + padding_length)),
+				actual_stride);
+		scan_count++;
+	}
+
+	INIT_COMPLETION(ctrl_pdata->spi_panel_te);
+
+	rc = wait_for_completion_timeout(&ctrl_pdata->spi_panel_te,
+				   msecs_to_jiffies(SPI_PANEL_TE_TIMEOUT));
+
+	if (rc == 0)
+		pr_err("wait panel TE time out\n");
+
+	rc = mdss_spi_tx_pixel(tx_buf, ctrl_pdata->byte_pre_frame);
+
+	return rc;
+}
+
+int mdss_spi_panel_on(struct mdss_panel_data *pdata)
+{
+	struct spi_panel_data *ctrl = NULL;
+	struct mdss_panel_info *pinfo;
+	int i;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+	pinfo = &pdata->panel_info;
+	ctrl = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	for (i = 0; i < ctrl->on_cmds.cmd_cnt; i++) {
+		mdss_spi_tx_command(ctrl->on_cmds.cmds[i].command);
+
+		if (ctrl->on_cmds.cmds[i].dchdr.dlen > 1) {
+			mdss_spi_tx_parameter(ctrl->on_cmds.cmds[i].parameter,
+					ctrl->on_cmds.cmds[i].dchdr.dlen-1);
+		}
+		if (ctrl->on_cmds.cmds[i].dchdr.wait != 0)
+			msleep(ctrl->on_cmds.cmds[i].dchdr.wait);
+	}
+
+	pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
+	pr_debug("%s:-\n", __func__);
+
+	return 0;
+}
+
+
+static int mdss_spi_panel_off(struct mdss_panel_data *pdata)
+{
+	struct spi_panel_data *ctrl = NULL;
+	struct mdss_panel_info *pinfo;
+	int i;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return -EINVAL;
+	}
+
+	pinfo = &pdata->panel_info;
+	ctrl = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	for (i = 0; i < ctrl->off_cmds.cmd_cnt; i++) {
+		mdss_spi_tx_command(ctrl->off_cmds.cmds[i].command);
+
+		if (ctrl->off_cmds.cmds[i].dchdr.dlen > 1) {
+			mdss_spi_tx_parameter(ctrl->off_cmds.cmds[i].parameter,
+					ctrl->off_cmds.cmds[i].dchdr.dlen-1);
+		}
+
+		if (ctrl->off_cmds.cmds[i].dchdr.wait != 0)
+			msleep(ctrl->off_cmds.cmds[i].dchdr.wait);
+	}
+
+	pinfo->blank_state = MDSS_PANEL_BLANK_BLANK;
+	pr_debug("%s:-\n", __func__);
+	return 0;
+}
+
+static void mdss_spi_put_dt_vreg_data(struct device *dev,
+	struct dss_module_power *module_power)
+{
+	if (!module_power) {
+		pr_err("%s: invalid input\n", __func__);
+		return;
+	}
+
+	if (module_power->vreg_config) {
+		devm_kfree(dev, module_power->vreg_config);
+		module_power->vreg_config = NULL;
+	}
+	module_power->num_vreg = 0;
+}
+
+
+static int mdss_spi_get_panel_vreg_data(struct device *dev,
+			struct dss_module_power *mp)
+{
+	int i = 0, rc = 0;
+	u32 tmp = 0;
+	struct device_node *of_node = NULL, *supply_node = NULL;
+	struct device_node *supply_root_node = NULL;
+
+	if (!dev || !mp) {
+		pr_err("%s: invalid input\n", __func__);
+		rc = -EINVAL;
+		return rc;
+	}
+
+	of_node = dev->of_node;
+
+	mp->num_vreg = 0;
+
+	supply_root_node = of_get_child_by_name(of_node,
+				"qcom,panel-supply-entries");
+
+	for_each_child_of_node(supply_root_node, supply_node) {
+		mp->num_vreg++;
+	}
+	if (mp->num_vreg == 0) {
+		pr_debug("%s: no vreg\n", __func__);
+		goto novreg;
+	} else {
+		pr_debug("%s: vreg found. count=%d\n", __func__, mp->num_vreg);
+	}
+
+	mp->vreg_config = kzalloc(sizeof(struct dss_vreg) *
+		mp->num_vreg, GFP_KERNEL);
+
+
+	for_each_child_of_node(supply_root_node, supply_node) {
+		const char *st = NULL;
+		/* vreg-name */
+		rc = of_property_read_string(supply_node,
+			"qcom,supply-name", &st);
+		if (rc) {
+			pr_err("%s: error reading name. rc=%d\n",
+				__func__, rc);
+			goto error;
+		}
+		snprintf(mp->vreg_config[i].vreg_name,
+			ARRAY_SIZE((mp->vreg_config[i].vreg_name)), "%s", st);
+		/* vreg-min-voltage */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-min-voltage", &tmp);
+		if (rc) {
+			pr_err("%s: error reading min volt. rc=%d\n",
+				__func__, rc);
+			goto error;
+		}
+		mp->vreg_config[i].min_voltage = tmp;
+
+		/* vreg-max-voltage */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-max-voltage", &tmp);
+		if (rc) {
+			pr_err("%s: error reading max volt. rc=%d\n",
+				__func__, rc);
+			goto error;
+		}
+		mp->vreg_config[i].max_voltage = tmp;
+
+		/* enable-load */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-enable-load", &tmp);
+		if (rc) {
+			pr_err("%s: error reading enable load. rc=%d\n",
+				__func__, rc);
+			goto error;
+		}
+		mp->vreg_config[i].enable_load = tmp;
+
+		/* disable-load */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-disable-load", &tmp);
+		if (rc) {
+			pr_err("%s: error reading disable load. rc=%d\n",
+				__func__, rc);
+			goto error;
+		}
+		mp->vreg_config[i].disable_load = tmp;
+
+		/* pre-sleep */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-pre-on-sleep", &tmp);
+		if (rc) {
+			pr_debug("%s: error reading supply pre sleep value\n",
+						__func__);
+			rc = 0;
+		} else {
+			mp->vreg_config[i].pre_on_sleep = tmp;
+		}
+
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-pre-off-sleep", &tmp);
+		if (rc) {
+			pr_debug("%s: error reading supply pre sleep value\n",
+						__func__);
+			rc = 0;
+		} else {
+			mp->vreg_config[i].pre_off_sleep = tmp;
+		}
+
+		/* post-sleep */
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-post-on-sleep", &tmp);
+		if (rc) {
+			pr_debug("%s: error reading supply post sleep value\n",
+						__func__);
+			rc = 0;
+		} else {
+			mp->vreg_config[i].post_on_sleep = tmp;
+		}
+
+		rc = of_property_read_u32(supply_node,
+			"qcom,supply-post-off-sleep", &tmp);
+		if (rc) {
+			pr_debug("%s: error reading supply post sleep value\n",
+						__func__);
+			rc = 0;
+		} else {
+			mp->vreg_config[i].post_off_sleep = tmp;
+		}
+
+		++i;
+	}
+	return rc;
+error:
+	kfree(mp->vreg_config);
+	mp->vreg_config = NULL;
+
+novreg:
+	mp->num_vreg = 0;
+
+	return rc;
+
+}
+
+static int mdss_spi_panel_parse_cmds(struct device_node *np,
+		struct spi_panel_cmds *pcmds, char *cmd_key)
+{
+	const char *data;
+	int blen = 0, len;
+	char *buf, *bp;
+	struct spi_ctrl_hdr *dchdr;
+	int i, cnt;
+
+	data = of_get_property(np, cmd_key, &blen);
+	if (!data) {
+		pr_err("%s: failed, key=%s\n", __func__, cmd_key);
+		return -ENOMEM;
+	}
+
+	buf = kzalloc(sizeof(char) * blen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, data, blen);
+
+	/* scan dcs commands */
+	bp = buf;
+	len = blen;
+	cnt = 0;
+	while (len >= sizeof(*dchdr)) {
+		dchdr = (struct spi_ctrl_hdr *)bp;
+		if (dchdr->dlen > len) {
+			pr_err("%s: dtsi parse error, len=%d",
+				__func__, dchdr->dlen);
+			goto exit_free;
+		}
+		bp += sizeof(*dchdr);
+		len -= sizeof(*dchdr);
+		bp += dchdr->dlen;
+		len -= dchdr->dlen;
+		cnt++;
+	}
+
+	if (len != 0) {
+		pr_err("%s: dcs_cmd=%x len=%d error!",
+				__func__, buf[0], len);
+		goto exit_free;
+	}
+
+	pcmds->cmds = kzalloc(cnt * sizeof(struct spi_cmd_desc),
+						GFP_KERNEL);
+	if (!pcmds->cmds)
+		goto exit_free;
+
+	pcmds->cmd_cnt = cnt;
+	pcmds->buf = buf;
+	pcmds->blen = blen;
+
+	bp = buf;
+	len = blen;
+	for (i = 0; i < cnt; i++) {
+		dchdr = (struct spi_ctrl_hdr *)bp;
+		len -= sizeof(*dchdr);
+		bp += sizeof(*dchdr);
+		pcmds->cmds[i].dchdr = *dchdr;
+		pcmds->cmds[i].command = bp;
+		pcmds->cmds[i].parameter = bp + sizeof(char);
+		bp += dchdr->dlen;
+		len -= dchdr->dlen;
+	}
+
+	pr_debug("%s: dcs_cmd=%x, len=%d, cmd_cnt=%d\n", __func__,
+		pcmds->buf[0], pcmds->blen, pcmds->cmd_cnt);
+
+	return 0;
+
+exit_free:
+	kfree(buf);
+	return -ENOMEM;
+}
+static int mdss_spi_panel_parse_reset_seq(struct device_node *np,
+		u32 rst_seq[MDSS_SPI_RST_SEQ_LEN], u32 *rst_len,
+		const char *name)
+{
+	int num = 0, i;
+	int rc;
+	struct property *data;
+	u32 tmp[MDSS_SPI_RST_SEQ_LEN];
+
+	*rst_len = 0;
+	data = of_find_property(np, name, &num);
+	num /= sizeof(u32);
+	if (!data || !num || num > MDSS_SPI_RST_SEQ_LEN || num % 2) {
+		pr_err("%s:%d, error reading %s, length found = %d\n",
+			__func__, __LINE__, name, num);
+	} else {
+		rc = of_property_read_u32_array(np, name, tmp, num);
+		if (rc)
+			pr_err("%s:%d, error reading %s, rc = %d\n",
+				__func__, __LINE__, name, rc);
+		else {
+			for (i = 0; i < num; ++i)
+				rst_seq[i] = tmp[i];
+			*rst_len = num;
+		}
+	}
+	return 0;
+}
+
+
+static int mdss_spi_panel_parse_dt(struct device_node *np,
+		struct spi_panel_data	*ctrl_pdata)
+{
+	u32 tmp;
+	int rc;
+	const char *data;
+	struct mdss_panel_info *pinfo = &(ctrl_pdata->panel_data.panel_info);
+
+	pinfo->cont_splash_enabled = of_property_read_bool(np,
+					"qcom,cont-splash-enabled");
+
+	rc = of_property_read_u32(np, "qcom,mdss-spi-panel-width", &tmp);
+	if (rc) {
+		pr_err("%s:%d, panel width not specified\n",
+						__func__, __LINE__);
+		return -EINVAL;
+	}
+	pinfo->xres = (!rc ? tmp : 240);
+
+	rc = of_property_read_u32(np, "qcom,mdss-spi-panel-height", &tmp);
+	if (rc) {
+		pr_err("%s:%d, panel height not specified\n",
+						__func__, __LINE__);
+		return -EINVAL;
+	}
+	pinfo->yres = (!rc ? tmp : 320);
+
+	rc = of_property_read_u32(np,
+		"qcom,mdss-pan-physical-width-dimension", &tmp);
+	pinfo->physical_width = (!rc ? tmp : 0);
+	rc = of_property_read_u32(np,
+		"qcom,mdss-pan-physical-height-dimension", &tmp);
+	pinfo->physical_height = (!rc ? tmp : 0);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-panel-framerate", &tmp);
+	pinfo->spi.frame_rate = (!rc ? tmp : 30);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-h-front-porch", &tmp);
+	pinfo->lcdc.h_front_porch = (!rc ? tmp : 6);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-h-back-porch", &tmp);
+	pinfo->lcdc.h_back_porch = (!rc ? tmp : 6);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-h-pulse-width", &tmp);
+	pinfo->lcdc.h_pulse_width = (!rc ? tmp : 2);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-h-sync-skew", &tmp);
+	pinfo->lcdc.hsync_skew = (!rc ? tmp : 0);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-v-back-porch", &tmp);
+	pinfo->lcdc.v_back_porch = (!rc ? tmp : 6);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-v-front-porch", &tmp);
+	pinfo->lcdc.v_front_porch = (!rc ? tmp : 6);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-v-pulse-width", &tmp);
+	pinfo->lcdc.v_pulse_width = (!rc ? tmp : 2);
+
+
+	rc = of_property_read_u32(np, "qcom,mdss-spi-bpp", &tmp);
+	if (rc) {
+		pr_err("%s:%d, bpp not specified\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+	pinfo->bpp = (!rc ? tmp : 16);
+
+	pinfo->pdest = DISPLAY_1;
+
+	ctrl_pdata->bklt_ctrl = UNKNOWN_CTRL;
+	data = of_get_property(np, "qcom,mdss-spi-bl-pmic-control-type", NULL);
+	if (data) {
+		if (!strcmp(data, "bl_ctrl_wled")) {
+			led_trigger_register_simple("bkl-trigger",
+				&bl_led_trigger);
+			pr_debug("%s: SUCCESS-> WLED TRIGGER register\n",
+				__func__);
+			ctrl_pdata->bklt_ctrl = BL_WLED;
+		} else if (!strcmp(data, "bl_ctrl_pwm")) {
+			ctrl_pdata->bklt_ctrl = BL_PWM;
+			ctrl_pdata->pwm_pmi = of_property_read_bool(np,
+					"qcom,mdss-spi-bl-pwm-pmi");
+			rc = of_property_read_u32(np,
+				"qcom,mdss-spi-bl-pmic-pwm-frequency", &tmp);
+			if (rc) {
+				pr_err("%s:%d, Error, panel pwm_period\n",
+						__func__, __LINE__);
+				return -EINVAL;
+			}
+			ctrl_pdata->pwm_period = tmp;
+			if (ctrl_pdata->pwm_pmi) {
+				ctrl_pdata->pwm_bl = of_pwm_get(np, NULL);
+				if (IS_ERR(ctrl_pdata->pwm_bl)) {
+					pr_err("%s: Error, pwm device\n",
+								__func__);
+					ctrl_pdata->pwm_bl = NULL;
+					return -EINVAL;
+				}
+			} else {
+				rc = of_property_read_u32(np,
+					"qcom,mdss-spi-bl-pmic-bank-select",
+								 &tmp);
+				if (rc) {
+					pr_err("%s:%d, Error, lpg channel\n",
+							__func__, __LINE__);
+					return -EINVAL;
+				}
+				ctrl_pdata->pwm_lpg_chan = tmp;
+				tmp = of_get_named_gpio(np,
+					"qcom,mdss-spi-pwm-gpio", 0);
+				ctrl_pdata->pwm_pmic_gpio = tmp;
+				pr_debug("%s: Configured PWM bklt ctrl\n",
+								 __func__);
+			}
+		}
+	}
+	rc = of_property_read_u32(np, "qcom,mdss-brightness-max-level", &tmp);
+	pinfo->brightness_max = (!rc ? tmp : MDSS_MAX_BL_BRIGHTNESS);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-bl-min-level", &tmp);
+	pinfo->bl_min = (!rc ? tmp : 0);
+	rc = of_property_read_u32(np, "qcom,mdss-spi-bl-max-level", &tmp);
+	pinfo->bl_max = (!rc ? tmp : 255);
+	ctrl_pdata->bklt_max = pinfo->bl_max;
+
+
+	mdss_spi_panel_parse_reset_seq(np, pinfo->rst_seq,
+					&(pinfo->rst_seq_len),
+					"qcom,mdss-spi-reset-sequence");
+
+	mdss_spi_panel_parse_cmds(np, &ctrl_pdata->on_cmds,
+		"qcom,mdss-spi-on-command");
+
+	mdss_spi_panel_parse_cmds(np, &ctrl_pdata->off_cmds,
+		"qcom,mdss-spi-off-command");
+
+	return 0;
+}
+
+void mdss_spi_panel_pwm_cfg(struct spi_panel_data *ctrl)
+{
+	if (ctrl->pwm_pmi)
+		return;
+
+	ctrl->pwm_bl = pwm_request(ctrl->pwm_lpg_chan, "lcd-bklt");
+	if (ctrl->pwm_bl == NULL || IS_ERR(ctrl->pwm_bl)) {
+		pr_err("%s: Error: lpg_chan=%d pwm request failed",
+				__func__, ctrl->pwm_lpg_chan);
+	}
+	ctrl->pwm_enabled = 0;
+}
+
+static void mdss_spi_panel_bklt_pwm(struct spi_panel_data *ctrl, int level)
+{
+	int ret;
+	u32 duty;
+	u32 period_ns;
+
+	if (ctrl->pwm_bl == NULL) {
+		pr_err("%s: no PWM\n", __func__);
+		return;
+	}
+
+	if (level == 0) {
+		if (ctrl->pwm_enabled) {
+			ret = pwm_config_us(ctrl->pwm_bl, level,
+					ctrl->pwm_period);
+			if (ret)
+				pr_err("%s: pwm_config_us() failed err=%d.\n",
+						__func__, ret);
+			pwm_disable(ctrl->pwm_bl);
+		}
+		ctrl->pwm_enabled = 0;
+		return;
+	}
+
+	duty = level * ctrl->pwm_period;
+	duty /= ctrl->bklt_max;
+
+	pr_debug("%s: bklt_ctrl=%d pwm_period=%d pwm_gpio=%d pwm_lpg_chan=%d\n",
+			__func__, ctrl->bklt_ctrl, ctrl->pwm_period,
+				ctrl->pwm_pmic_gpio, ctrl->pwm_lpg_chan);
+
+	if (ctrl->pwm_period >= USEC_PER_SEC) {
+		ret = pwm_config_us(ctrl->pwm_bl, duty, ctrl->pwm_period);
+		if (ret) {
+			pr_err("%s: pwm_config_us() failed err=%d.\n",
+					__func__, ret);
+			return;
+		}
+	} else {
+		period_ns = ctrl->pwm_period * NSEC_PER_USEC;
+		ret = pwm_config(ctrl->pwm_bl,
+				level * period_ns / ctrl->bklt_max,
+				period_ns);
+		if (ret) {
+			pr_err("%s: pwm_config() failed err=%d.\n",
+					__func__, ret);
+			return;
+		}
+	}
+
+	if (!ctrl->pwm_enabled) {
+		ret = pwm_enable(ctrl->pwm_bl);
+		if (ret)
+			pr_err("%s: pwm_enable() failed err=%d\n", __func__,
+				ret);
+		ctrl->pwm_enabled = 1;
+	}
+}
+
+
+static void mdss_spi_panel_bl_ctrl(struct mdss_panel_data *pdata,
+							u32 bl_level)
+{
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (pdata == NULL) {
+		pr_err("%s: Invalid input data\n", __func__);
+		return;
+	}
+
+	ctrl_pdata = container_of(pdata, struct spi_panel_data,
+				panel_data);
+
+	if ((bl_level < pdata->panel_info.bl_min) && (bl_level != 0))
+		bl_level = pdata->panel_info.bl_min;
+
+	switch (ctrl_pdata->bklt_ctrl) {
+	case BL_WLED:
+		led_trigger_event(bl_led_trigger, bl_level);
+		break;
+	case BL_PWM:
+		mdss_spi_panel_bklt_pwm(ctrl_pdata, bl_level);
+		break;
+	default:
+		pr_err("%s: Unknown bl_ctrl configuration %d\n",
+			__func__, ctrl_pdata->bklt_ctrl);
+		break;
+	}
+}
+
+int mdss_spi_panel_init(struct device_node *node,
+	struct spi_panel_data	*ctrl_pdata,
+	bool cmd_cfg_cont_splash)
+{
+	int rc = 0;
+	static const char *panel_name;
+	struct mdss_panel_info *pinfo;
+
+	if (!node || !ctrl_pdata) {
+		pr_err("%s: Invalid arguments\n", __func__);
+		return -ENODEV;
+	}
+
+	pinfo = &ctrl_pdata->panel_data.panel_info;
+
+	pr_debug("%s:%d\n", __func__, __LINE__);
+	pinfo->panel_name[0] = '\0';
+	panel_name = of_get_property(node, "qcom,mdss-spi-panel-name", NULL);
+	if (!panel_name) {
+		pr_info("%s:%d, Panel name not specified\n",
+						__func__, __LINE__);
+	} else {
+		pr_info("%s: Panel Name = %s\n", __func__, panel_name);
+		strlcpy(&pinfo->panel_name[0], panel_name, MDSS_MAX_PANEL_LEN);
+	}
+	rc = mdss_spi_panel_parse_dt(node, ctrl_pdata);
+	if (rc) {
+		pr_err("%s:%d panel dt parse failed\n", __func__, __LINE__);
+		return rc;
+	}
+
+	ctrl_pdata->byte_pre_frame = pinfo->xres * pinfo->yres * pinfo->bpp/8;
+
+	ctrl_pdata->tx_buf = kmalloc(ctrl_pdata->byte_pre_frame, GFP_KERNEL);
+	if (!ctrl_pdata->tx_buf) {
+		pr_err("%s: FAILED: cannot alloc tx buf for spi panel\n",
+				__func__);
+		kfree(ctrl_pdata->tx_buf);
+		return -ENOMEM;
+	}
+
+	if (!cmd_cfg_cont_splash)
+		pinfo->cont_splash_enabled = false;
+
+	pr_info("%s: Continuous splash %s\n", __func__,
+		pinfo->cont_splash_enabled ? "enabled" : "disabled");
+
+	pinfo->dynamic_switch_pending = false;
+	pinfo->is_lpm_mode = false;
+	pinfo->esd_rdy = false;
+
+	ctrl_pdata->on = mdss_spi_panel_on;
+	ctrl_pdata->off = mdss_spi_panel_off;
+	ctrl_pdata->panel_data.set_backlight = mdss_spi_panel_bl_ctrl;
+
+	return 0;
+}
+
+static int mdss_spi_get_panel_cfg(char *panel_cfg,
+				struct spi_panel_data	*ctrl_pdata)
+{
+	int rc;
+	struct mdss_panel_cfg *pan_cfg = NULL;
+
+	if (!ctrl_pdata)
+		return MDSS_PANEL_INTF_INVALID;
+
+	pan_cfg = ctrl_pdata->mdss_util->panel_intf_type(MDSS_PANEL_INTF_SPI);
+	if (IS_ERR(pan_cfg)) {
+		return PTR_ERR(pan_cfg);
+	} else if (!pan_cfg) {
+		panel_cfg[0] = 0;
+		return 0;
+	}
+
+	pr_debug("%s:%d: cfg:[%s]\n", __func__, __LINE__,
+		 pan_cfg->arg_cfg);
+	ctrl_pdata->panel_data.panel_info.is_prim_panel = true;
+	rc = strlcpy(panel_cfg, pan_cfg->arg_cfg,
+		     sizeof(pan_cfg->arg_cfg));
+	return rc;
+}
+
+static int mdss_spi_panel_regulator_init(struct platform_device *pdev)
+{
+	int rc = 0;
+
+	struct spi_panel_data *ctrl_pdata = NULL;
+
+	if (!pdev) {
+		pr_err("%s: invalid input\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl_pdata = platform_get_drvdata(pdev);
+	if (!ctrl_pdata) {
+		pr_err("%s: invalid driver data\n", __func__);
+		return -EINVAL;
+	}
+
+	rc = msm_dss_config_vreg(&pdev->dev,
+		ctrl_pdata->panel_power_data.vreg_config,
+		ctrl_pdata->panel_power_data.num_vreg, 1);
+	if (rc)
+		pr_err("%s: failed to init vregs for %s\n",
+			__func__, "PANEL_PM");
+
+	return rc;
+
+}
+irqreturn_t spi_panel_te_handler(int irq, void *data)
+{
+	struct spi_panel_data *ctrl_pdata =
+		(struct spi_panel_data *)data;
+
+	if (!ctrl_pdata) {
+		pr_err("%s: SPI display not available\n", __func__);
+		return IRQ_HANDLED;
+	}
+	complete(&ctrl_pdata->spi_panel_te);
+	return IRQ_HANDLED;
+}
+
+
+static struct device_node *mdss_spi_pref_prim_panel(
+		struct platform_device *pdev)
+{
+	struct device_node *spi_pan_node = NULL;
+
+	pr_debug("%s:%d: Select primary panel from dt\n",
+					__func__, __LINE__);
+	spi_pan_node = of_parse_phandle(pdev->dev.of_node,
+					"qcom,spi-pref-prim-pan", 0);
+	if (!spi_pan_node)
+		pr_err("%s:can't find panel phandle\n", __func__);
+
+	return spi_pan_node;
+}
+
+int spi_panel_device_register(struct device_node *pan_node,
+				struct spi_panel_data *ctrl_pdata)
+{
+	int rc;
+	struct mdss_panel_info *pinfo = &(ctrl_pdata->panel_data.panel_info);
+	struct device_node *spi_ctrl_np = NULL;
+	struct platform_device *ctrl_pdev = NULL;
+
+	pinfo->type = SPI_PANEL;
+
+	spi_ctrl_np = of_parse_phandle(pan_node,
+				"qcom,mdss-spi-panel-controller", 0);
+	if (!spi_ctrl_np) {
+		pr_err("%s: SPI controller node not initialized\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	ctrl_pdev = of_find_device_by_node(spi_ctrl_np);
+
+	rc = mdss_spi_panel_regulator_init(ctrl_pdev);
+	if (rc) {
+		pr_err("%s: failed to init regulator, rc=%d\n",
+						__func__, rc);
+		return rc;
+	}
+
+	pinfo->panel_max_fps = mdss_panel_get_framerate(pinfo);
+	pinfo->panel_max_vtotal = mdss_panel_get_vtotal(pinfo);
+
+	ctrl_pdata->disp_te_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
+		"qcom,platform-te-gpio", 0);
+
+	if (!gpio_is_valid(ctrl_pdata->disp_te_gpio))
+		pr_err("%s:%d, TE gpio not specified\n",
+						__func__, __LINE__);
+
+	ctrl_pdata->rst_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
+			 "qcom,platform-reset-gpio", 0);
+	if (!gpio_is_valid(ctrl_pdata->rst_gpio))
+		pr_err("%s:%d, reset gpio not specified\n",
+						__func__, __LINE__);
+
+	ctrl_pdata->panel_data.event_handler = mdss_spi_panel_event_handler;
+
+	if (ctrl_pdata->bklt_ctrl == BL_PWM)
+		mdss_spi_panel_pwm_cfg(ctrl_pdata);
+
+	ctrl_pdata->ctrl_state = CTRL_STATE_UNKNOWN;
+
+	if (pinfo->cont_splash_enabled) {
+		rc = mdss_spi_panel_power_ctrl(&(ctrl_pdata->panel_data),
+			MDSS_PANEL_POWER_ON);
+		if (rc) {
+			pr_err("%s: Panel power on failed\n", __func__);
+			return rc;
+		}
+		if (ctrl_pdata->bklt_ctrl == BL_PWM)
+			ctrl_pdata->pwm_enabled = 1;
+		pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
+		ctrl_pdata->ctrl_state |=
+			(CTRL_STATE_PANEL_INIT | CTRL_STATE_MDP_ACTIVE);
+	} else {
+		pinfo->panel_power_state = MDSS_PANEL_POWER_OFF;
+	}
+
+	rc = mdss_register_panel(ctrl_pdev, &(ctrl_pdata->panel_data));
+	if (rc) {
+		pr_err("%s: unable to register SPI panel\n", __func__);
+		return rc;
+	}
+
+	pr_debug("%s: Panel data initialized\n", __func__);
+	return 0;
+}
+
+
+/**
+ * mdss_spi_find_panel_of_node(): find device node of spi panel
+ * @pdev: platform_device of the spi ctrl node
+ * @panel_cfg: string containing intf specific config data
+ *
+ * Function finds the panel device node using the interface
+ * specific configuration data. This configuration data is
+ * could be derived from the result of bootloader's GCDB
+ * panel detection mechanism. If such config data doesn't
+ * exist then this panel returns the default panel configured
+ * in the device tree.
+ *
+ * returns pointer to panel node on success, NULL on error.
+ */
+static struct device_node *mdss_spi_find_panel_of_node(
+		struct platform_device *pdev, char *panel_cfg)
+{
+	int len, i;
+	int ctrl_id = pdev->id - 1;
+	char panel_name[MDSS_MAX_PANEL_LEN] = "";
+	char ctrl_id_stream[3] =  "0:";
+	char *stream = NULL, *pan = NULL;
+	struct device_node *spi_pan_node = NULL, *mdss_node = NULL;
+
+	len = strlen(panel_cfg);
+	if (!len) {
+		/* no panel cfg chg, parse dt */
+		pr_err("%s:%d: no cmd line cfg present\n",
+			 __func__, __LINE__);
+		goto end;
+	} else {
+		if (ctrl_id == 1)
+			strlcpy(ctrl_id_stream, "1:", 3);
+
+		stream = strnstr(panel_cfg, ctrl_id_stream, len);
+		if (!stream) {
+			pr_err("controller config is not present\n");
+			goto end;
+		}
+		stream += 2;
+
+		pan = strnchr(stream, strlen(stream), ':');
+		if (!pan) {
+			strlcpy(panel_name, stream, MDSS_MAX_PANEL_LEN);
+		} else {
+			for (i = 0; (stream + i) < pan; i++)
+				panel_name[i] = *(stream + i);
+			panel_name[i] = 0;
+		}
+
+		pr_debug("%s:%d:%s:%s\n", __func__, __LINE__,
+			 panel_cfg, panel_name);
+
+		mdss_node = of_parse_phandle(pdev->dev.of_node,
+					     "qcom,mdss-mdp", 0);
+
+		if (!mdss_node) {
+			pr_err("%s: %d: mdss_node null\n",
+			       __func__, __LINE__);
+			return NULL;
+		}
+		spi_pan_node = of_find_node_by_name(mdss_node,
+						    panel_name);
+		if (!spi_pan_node) {
+			pr_err("%s: invalid pan node, selecting prim panel\n",
+			       __func__);
+			goto end;
+		}
+		return spi_pan_node;
+	}
+end:
+	if (strcmp(panel_name, NONE_PANEL))
+		spi_pan_node = mdss_spi_pref_prim_panel(pdev);
+
+	return spi_pan_node;
+}
+
+
+static int mdss_spi_panel_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	struct spi_panel_data	*ctrl_pdata;
+	struct mdss_panel_cfg *pan_cfg = NULL;
+	struct device_node *spi_pan_node = NULL;
+	bool cmd_cfg_cont_splash = true;
+	char panel_cfg[MDSS_MAX_PANEL_LEN];
+	struct mdss_util_intf *util;
+	const char *ctrl_name;
+
+	util = mdss_get_util_intf();
+	if (util == NULL) {
+		pr_err("Failed to get mdss utility functions\n");
+		return -ENODEV;
+	}
+
+	if (!util->mdp_probe_done) {
+		pr_err("%s: MDP not probed yet!\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	if (!pdev->dev.of_node) {
+		pr_err("SPI driver only supports device tree probe\n");
+		return -ENOTSUPP;
+	}
+
+	pan_cfg = util->panel_intf_type(MDSS_PANEL_INTF_DSI);
+	if (IS_ERR(pan_cfg)) {
+		pr_err("%s: return MDSS_PANEL_INTF_DSI\n", __func__);
+		return PTR_ERR(pan_cfg);
+	} else if (pan_cfg) {
+		pr_err("%s: DSI is primary\n", __func__);
+		return -ENODEV;
+	}
+
+	ctrl_pdata = platform_get_drvdata(pdev);
+	if (!ctrl_pdata) {
+		ctrl_pdata = devm_kzalloc(&pdev->dev,
+					  sizeof(struct spi_panel_data),
+					  GFP_KERNEL);
+		if (!ctrl_pdata) {
+			pr_err("%s: FAILED: cannot alloc spi panel\n",
+			       __func__);
+			rc = -ENOMEM;
+			goto error_no_mem;
+		}
+		platform_set_drvdata(pdev, ctrl_pdata);
+	}
+
+	ctrl_pdata->mdss_util = util;
+
+	ctrl_name = of_get_property(pdev->dev.of_node, "label", NULL);
+	if (!ctrl_name)
+		pr_info("%s:%d, Ctrl name not specified\n",
+			__func__, __LINE__);
+	else
+		pr_info("%s: Ctrl name = %s\n",
+			__func__, ctrl_name);
+
+
+	rc = of_platform_populate(pdev->dev.of_node,
+				  NULL, NULL, &pdev->dev);
+	if (rc) {
+		dev_err(&pdev->dev,
+			"%s: failed to add child nodes, rc=%d\n",
+			__func__, rc);
+		goto error_no_mem;
+	}
+
+	rc = mdss_spi_panel_pinctrl_init(pdev);
+	if (rc)
+		pr_warn("%s: failed to get pin resources\n", __func__);
+
+	rc = mdss_spi_get_panel_vreg_data(&pdev->dev,
+					&ctrl_pdata->panel_power_data);
+	if (rc) {
+		dev_err(&pdev->dev,
+			"%s: failed to get panel vreg data, rc=%d\n",
+			__func__, rc);
+		goto error_vreg;
+	}
+
+	/* SPI panels can be different between controllers */
+	rc = mdss_spi_get_panel_cfg(panel_cfg, ctrl_pdata);
+	if (!rc)
+		/* spi panel cfg not present */
+		pr_warn("%s:%d:spi specific cfg not present\n",
+			__func__, __LINE__);
+
+	/* find panel device node */
+	spi_pan_node = mdss_spi_find_panel_of_node(pdev, panel_cfg);
+	if (!spi_pan_node) {
+		pr_err("%s: can't find panel node %s\n", __func__, panel_cfg);
+		goto error_pan_node;
+	}
+
+	cmd_cfg_cont_splash = true;
+
+	rc = mdss_spi_panel_init(spi_pan_node, ctrl_pdata, cmd_cfg_cont_splash);
+	if (rc) {
+		pr_err("%s: spi panel init failed\n", __func__);
+		goto error_pan_node;
+	}
+
+	rc = spi_panel_device_register(spi_pan_node, ctrl_pdata);
+	if (rc) {
+		pr_err("%s: spi panel dev reg failed\n", __func__);
+		goto error_pan_node;
+	}
+
+	ctrl_pdata->panel_data.event_handler = mdss_spi_panel_event_handler;
+
+
+	init_completion(&ctrl_pdata->spi_panel_te);
+
+	rc = devm_request_irq(&pdev->dev,
+		gpio_to_irq(ctrl_pdata->disp_te_gpio),
+		spi_panel_te_handler, IRQF_TRIGGER_RISING,
+		"TE_GPIO", ctrl_pdata);
+	if (rc) {
+		pr_err("TE request_irq failed.\n");
+		return rc;
+	}
+
+	pr_debug("%s: spi panel  initialized\n", __func__);
+	return 0;
+
+error_pan_node:
+	of_node_put(spi_pan_node);
+error_vreg:
+	mdss_spi_put_dt_vreg_data(&pdev->dev,
+			&ctrl_pdata->panel_power_data);
+error_no_mem:
+	devm_kfree(&pdev->dev, ctrl_pdata);
+	return rc;
+}
+
+
+static const struct of_device_id mdss_spi_panel_match[] = {
+	{ .compatible = "qcom,mdss-spi-display" },
+	{},
+};
+
+static struct platform_driver this_driver = {
+	.probe = mdss_spi_panel_probe,
+	.driver = {
+	.name = "spi_panel",
+	.owner  = THIS_MODULE,
+	.of_match_table = mdss_spi_panel_match,
+	},
+};
+
+static int __init mdss_spi_display_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&this_driver);
+	return 0;
+}
+module_init(mdss_spi_display_init);
+
+MODULE_DEVICE_TABLE(of, mdss_spi_panel_match);
diff --git a/kernel/drivers/video/msm/mdss/mdss_spi_panel.h b/kernel/drivers/video/msm/mdss/mdss_spi_panel.h
new file mode 100755
index 0000000..54e526a
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_spi_panel.h
@@ -0,0 +1,123 @@
+/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#ifndef __MDSS_SPI_PANEL_H__
+#define __MDSS_SPI_PANEL_H__
+
+#if defined(CONFIG_FB_MSM_MDSS_SPI_PANEL) && defined(CONFIG_SPI_QUP)
+#include <linux/list.h>
+#include <linux/mdss_io_util.h>
+#include <linux/irqreturn.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/gpio.h>
+
+#include "mdss_panel.h"
+
+#define MDSS_MAX_BL_BRIGHTNESS 255
+
+#define MDSS_SPI_RST_SEQ_LEN	10
+
+#define NONE_PANEL "none"
+
+#define CTRL_STATE_UNKNOWN		0x00
+#define CTRL_STATE_PANEL_INIT		BIT(0)
+#define CTRL_STATE_MDP_ACTIVE		BIT(1)
+
+#define MDSS_PINCTRL_STATE_DEFAULT "mdss_default"
+#define MDSS_PINCTRL_STATE_SLEEP  "mdss_sleep"
+#define SPI_PANEL_TE_TIMEOUT	500
+
+enum spi_panel_data_type {
+	panel_cmd,
+	panel_parameter,
+	panel_pixel,
+	UNKNOWN_FORMAT,
+};
+
+
+enum spi_panel_bl_ctrl {
+	BL_PWM,
+	BL_WLED,
+	BL_DCS_CMD,
+	UNKNOWN_CTRL,
+};
+
+struct spi_pinctrl_res {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *gpio_state_active;
+	struct pinctrl_state *gpio_state_suspend;
+};
+#define SPI_PANEL_DST_FORMAT_RGB565		0
+
+struct spi_ctrl_hdr {
+	char wait;	/* ms */
+	char dlen;	/* 8 bits */
+};
+
+struct spi_cmd_desc {
+	struct spi_ctrl_hdr dchdr;
+	char *command;
+	char *parameter;
+};
+
+struct spi_panel_cmds {
+	char *buf;
+	int blen;
+	struct spi_cmd_desc *cmds;
+	int cmd_cnt;
+};
+
+struct spi_panel_data {
+	struct mdss_panel_data panel_data;
+	struct mdss_util_intf *mdss_util;
+	struct spi_pinctrl_res pin_res;
+	struct dss_module_power panel_power_data;
+	struct completion spi_panel_te;
+	int byte_pre_frame;
+	char *tx_buf;
+	u8 ctrl_state;
+	int disp_te_gpio;
+	int rst_gpio;
+	struct spi_panel_cmds on_cmds;
+	struct spi_panel_cmds off_cmds;
+	int (*on)(struct mdss_panel_data *pdata);
+	int (*off)(struct mdss_panel_data *pdata);
+	struct pwm_device *pwm_bl;
+	int bklt_ctrl;	/* backlight ctrl */
+	bool pwm_pmi;
+	int pwm_period;
+	int pwm_pmic_gpio;
+	int pwm_lpg_chan;
+	int pwm_enabled;
+	int bklt_max;
+};
+int mdss_spi_panel_kickoff(struct mdss_panel_data *pdata,
+				char *buf, int len, int stride);
+int is_spi_panel_continuous_splash_on(struct mdss_panel_data *pdata);
+#else
+
+static inline int mdss_spi_panel_kickoff(struct mdss_panel_data *pdata,
+				char *buf, int len, int stride){
+	return 0;
+}
+
+static inline int is_spi_panel_continuous_splash_on(
+				struct mdss_panel_data *pdata)
+{
+	return 0;
+}
+
+#endif/* End of CONFIG_FB_MSM_MDSS_SPI_PANEL && ONFIG_SPI_QUP */
+
+#endif /* End of __MDSS_SPI_PANEL_H__ */
diff --git a/kernel/drivers/video/msm/msm_fb.c b/kernel/drivers/video/msm/msm_fb.c
old mode 100644
new mode 100755
index a52dad2..5bf9281
--- a/kernel/drivers/video/msm/msm_fb.c
+++ b/kernel/drivers/video/msm/msm_fb.c
@@ -4166,6 +4166,7 @@ int __init msm_fb_init(void)
 {
 	int rc = -ENODEV;
 
+	pr_err("msm_fb_init probe............\n");
 	if (msm_fb_register_driver())
 		return rc;
 
